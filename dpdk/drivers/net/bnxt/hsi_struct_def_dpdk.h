/* SPDX-License-Identifier: BSD-3-Clause
 * Copyright (c) 2014-2023 Broadcom Inc.
 * All rights reserved.
 *
 * DO NOT MODIFY!!! This file is automatically generated.
 */

#ifndef _HSI_STRUCT_DEF_DPDK_H_
#define _HSI_STRUCT_DEF_DPDK_H_

/* This is the HWRM command header. */
/* hwrm_cmd_hdr (size:128b/16B) */
struct hwrm_cmd_hdr {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* This is the HWRM response header. */
/* hwrm_resp_hdr (size:64b/8B) */
struct hwrm_resp_hdr {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
} __rte_packed;

/*
 * TLV encapsulated message. Use the TLV type field of the
 * TLV to determine the type of message encapsulated.
 */
#define CMD_DISCR_TLV_ENCAP UINT32_C(0x8000)
#define CMD_DISCR_LAST     CMD_DISCR_TLV_ENCAP


/* HWRM request message */
#define TLV_TYPE_HWRM_REQUEST                    UINT32_C(0x1)
/* HWRM response message */
#define TLV_TYPE_HWRM_RESPONSE                   UINT32_C(0x2)
/* RoCE slow path command */
#define TLV_TYPE_ROCE_SP_COMMAND                 UINT32_C(0x3)
/* RoCE slow path command to query CC Gen1 support. */
#define TLV_TYPE_QUERY_ROCE_CC_GEN1              UINT32_C(0x4)
/* RoCE slow path command to modify CC Gen1 support. */
#define TLV_TYPE_MODIFY_ROCE_CC_GEN1             UINT32_C(0x5)
/* Engine CKV - The Alias key EC curve and ECC public key information. */
#define TLV_TYPE_ENGINE_CKV_ALIAS_ECC_PUBLIC_KEY UINT32_C(0x8001)
/* Engine CKV - Initialization vector. */
#define TLV_TYPE_ENGINE_CKV_IV                   UINT32_C(0x8003)
/* Engine CKV - Authentication tag. */
#define TLV_TYPE_ENGINE_CKV_AUTH_TAG             UINT32_C(0x8004)
/* Engine CKV - The encrypted data. */
#define TLV_TYPE_ENGINE_CKV_CIPHERTEXT           UINT32_C(0x8005)
/* Engine CKV - Supported host_algorithms. */
#define TLV_TYPE_ENGINE_CKV_HOST_ALGORITHMS      UINT32_C(0x8006)
/* Engine CKV - The Host EC curve name and ECC public key information. */
#define TLV_TYPE_ENGINE_CKV_HOST_ECC_PUBLIC_KEY  UINT32_C(0x8007)
/* Engine CKV - The ECDSA signature. */
#define TLV_TYPE_ENGINE_CKV_ECDSA_SIGNATURE      UINT32_C(0x8008)
/* Engine CKV - The firmware EC curve name and ECC public key information. */
#define TLV_TYPE_ENGINE_CKV_FW_ECC_PUBLIC_KEY    UINT32_C(0x8009)
/* Engine CKV - Supported firmware algorithms. */
#define TLV_TYPE_ENGINE_CKV_FW_ALGORITHMS        UINT32_C(0x800a)
#define TLV_TYPE_LAST \
	TLV_TYPE_ENGINE_CKV_FW_ALGORITHMS


/* tlv (size:64b/8B) */
struct tlv {
	/*
	 * The command discriminator is used to differentiate between various
	 * types of HWRM messages. This includes legacy HWRM and RoCE slowpath
	 * command messages as well as newer TLV encapsulated HWRM commands.
	 *
	 * For TLV encapsulated messages this field must be 0x8000.
	 */
	uint16_t	cmd_discr;
	uint8_t	reserved_8b;
	uint8_t	flags;
	/*
	 * Indicates the presence of additional TLV encapsulated data
	 * follows this TLV.
	 */
	#define TLV_FLAGS_MORE         UINT32_C(0x1)
	/* Last TLV in a sequence of TLVs. */
	#define TLV_FLAGS_MORE_LAST      UINT32_C(0x0)
	/* More TLVs follow this TLV. */
	#define TLV_FLAGS_MORE_NOT_LAST  UINT32_C(0x1)
	/*
	 * When an HWRM receiver detects a TLV type that it does not
	 * support with the TLV required flag set, the receiver must
	 * reject the HWRM message with an error code indicating an
	 * unsupported TLV type.
	 */
	#define TLV_FLAGS_REQUIRED     UINT32_C(0x2)
	/* No */
	#define TLV_FLAGS_REQUIRED_NO    (UINT32_C(0x0) << 1)
	/* Yes */
	#define TLV_FLAGS_REQUIRED_YES   (UINT32_C(0x1) << 1)
	#define TLV_FLAGS_REQUIRED_LAST TLV_FLAGS_REQUIRED_YES
	/*
	 * This field defines the TLV type value which is divided into
	 * two ranges to differentiate between global and local TLV types.
	 * Global TLV types must be unique across all defined TLV types.
	 * Local TLV types are valid only for extensions to a given
	 * HWRM message and may be repeated across different HWRM message
	 * types. There is a direct correlation of each HWRM message type
	 * to a single global TLV type value.
	 *
	 * Global TLV range: `0 - (63k-1)`
	 *
	 * Local TLV range: `63k - (64k-1)`
	 */
	uint16_t	tlv_type;
	/*
	 * Length of the message data encapsulated by this TLV in bytes.
	 * This length does not include the size of the TLV header itself
	 * and it must be an integer multiple of 8B.
	 */
	uint16_t	length;
} __rte_packed;

/* Input */
/* input (size:128b/16B) */
struct input {
	/*
	 * This value indicates what type of request this is.  The format
	 * for the rest of the command is determined by this field.
	 */
	uint16_t	req_type;
	/*
	 * This value indicates the what completion ring the request will
	 * be optionally completed on.  If the value is -1, then no
	 * CR completion will be generated.  Any other value must be a
	 * valid CR ring_id value for this function.
	 */
	uint16_t	cmpl_ring;
	/* This value indicates the command sequence number. */
	uint16_t	seq_id;
	/*
	 * Target ID of this command.
	 *
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * This is the host address where the response will be written
	 * when the request is complete.  This area must be 16B aligned
	 * and must be cleared to zero before the request is made.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* Output */
/* output (size:64b/8B) */
struct output {
	/*
	 * Pass/Fail or error type
	 *
	 * Note: receiver to verify the in parameters, and fail the call
	 * with an error when appropriate
	 */
	uint16_t	error_code;
	/* This field returns the type of original request. */
	uint16_t	req_type;
	/* This field provides original sequence number of the command. */
	uint16_t	seq_id;
	/*
	 * This field is the length of the response in bytes.  The
	 * last byte of the response is a valid flag that will read
	 * as '1' when the command has been completely written to
	 * memory.
	 */
	uint16_t	resp_len;
} __rte_packed;

/* Short Command Structure */
/* hwrm_short_input (size:128b/16B) */
struct hwrm_short_input {
	/*
	 * This field indicates the type of request in the request buffer.
	 * The format for the rest of the command (request) is determined
	 * by this field.
	 */
	uint16_t	req_type;
	/*
	 * This field indicates a signature that is used to identify short
	 * form of the command listed here. This field shall be set to
	 * 17185 (0x4321).
	 */
	uint16_t	signature;
	/* Signature indicating this is a short form of HWRM command */
	#define HWRM_SHORT_INPUT_SIGNATURE_SHORT_CMD UINT32_C(0x4321)
	#define HWRM_SHORT_INPUT_SIGNATURE_LAST \
		HWRM_SHORT_INPUT_SIGNATURE_SHORT_CMD
	/* The target ID of the command */
	uint16_t	target_id;
	/* Default target_id (0x0) to maintain compatibility with old driver */
	#define HWRM_SHORT_INPUT_TARGET_ID_DEFAULT UINT32_C(0x0)
	/* Reserved for user-space HWRM interface */
	#define HWRM_SHORT_INPUT_TARGET_ID_TOOLS   UINT32_C(0xfffd)
	#define HWRM_SHORT_INPUT_TARGET_ID_LAST \
		HWRM_SHORT_INPUT_TARGET_ID_TOOLS
	/* This value indicates the length of the request. */
	uint16_t	size;
	/*
	 * This is the host address where the request was written.
	 * This area must be 16B aligned.
	 */
	uint64_t	req_addr;
} __rte_packed;

/*
 * Command numbering
 * # NOTE - definitions already in hwrm_req_type, in hwrm_types.yaml
 * #        So only structure definition is provided here.
 */
/* cmd_nums (size:64b/8B) */
struct cmd_nums {
	/*
	 * This version of the specification defines the commands listed in
	 * the table below. The following are general implementation
	 * requirements for these commands:
	 *
	 * # All commands listed below that are marked neither
	 * reserved nor experimental shall be implemented by the HWRM.
	 * # A HWRM client compliant to this specification should not use
	 * commands outside of the list below.
	 * # A HWRM client compliant to this specification should not use
	 * command numbers marked reserved below.
	 * # A command marked experimental below may not be implemented
	 * by the HWRM.
	 * # A command marked experimental may change in the
	 * future version of the HWRM specification.
	 * # A command not listed below may be implemented by the HWRM.
	 * The behavior of commands that are not listed below is outside
	 * the scope of this specification.
	 */
	uint16_t	req_type;
	#define HWRM_VER_GET                              UINT32_C(0x0)
	#define HWRM_FUNC_ECHO_RESPONSE                   UINT32_C(0xb)
	#define HWRM_ERROR_RECOVERY_QCFG                  UINT32_C(0xc)
	#define HWRM_FUNC_DRV_IF_CHANGE                   UINT32_C(0xd)
	#define HWRM_FUNC_BUF_UNRGTR                      UINT32_C(0xe)
	#define HWRM_FUNC_VF_CFG                          UINT32_C(0xf)
	/* Reserved for future use. */
	#define HWRM_RESERVED1                            UINT32_C(0x10)
	#define HWRM_FUNC_RESET                           UINT32_C(0x11)
	#define HWRM_FUNC_GETFID                          UINT32_C(0x12)
	#define HWRM_FUNC_VF_ALLOC                        UINT32_C(0x13)
	#define HWRM_FUNC_VF_FREE                         UINT32_C(0x14)
	#define HWRM_FUNC_QCAPS                           UINT32_C(0x15)
	#define HWRM_FUNC_QCFG                            UINT32_C(0x16)
	#define HWRM_FUNC_CFG                             UINT32_C(0x17)
	#define HWRM_FUNC_QSTATS                          UINT32_C(0x18)
	#define HWRM_FUNC_CLR_STATS                       UINT32_C(0x19)
	#define HWRM_FUNC_DRV_UNRGTR                      UINT32_C(0x1a)
	#define HWRM_FUNC_VF_RESC_FREE                    UINT32_C(0x1b)
	#define HWRM_FUNC_VF_VNIC_IDS_QUERY               UINT32_C(0x1c)
	#define HWRM_FUNC_DRV_RGTR                        UINT32_C(0x1d)
	#define HWRM_FUNC_DRV_QVER                        UINT32_C(0x1e)
	#define HWRM_FUNC_BUF_RGTR                        UINT32_C(0x1f)
	#define HWRM_PORT_PHY_CFG                         UINT32_C(0x20)
	#define HWRM_PORT_MAC_CFG                         UINT32_C(0x21)
	/* Experimental */
	#define HWRM_PORT_TS_QUERY                        UINT32_C(0x22)
	#define HWRM_PORT_QSTATS                          UINT32_C(0x23)
	#define HWRM_PORT_LPBK_QSTATS                     UINT32_C(0x24)
	/* Experimental */
	#define HWRM_PORT_CLR_STATS                       UINT32_C(0x25)
	/* Experimental */
	#define HWRM_PORT_LPBK_CLR_STATS                  UINT32_C(0x26)
	#define HWRM_PORT_PHY_QCFG                        UINT32_C(0x27)
	#define HWRM_PORT_MAC_QCFG                        UINT32_C(0x28)
	/* Experimental */
	#define HWRM_PORT_MAC_PTP_QCFG                    UINT32_C(0x29)
	#define HWRM_PORT_PHY_QCAPS                       UINT32_C(0x2a)
	#define HWRM_PORT_PHY_I2C_WRITE                   UINT32_C(0x2b)
	#define HWRM_PORT_PHY_I2C_READ                    UINT32_C(0x2c)
	#define HWRM_PORT_LED_CFG                         UINT32_C(0x2d)
	#define HWRM_PORT_LED_QCFG                        UINT32_C(0x2e)
	#define HWRM_PORT_LED_QCAPS                       UINT32_C(0x2f)
	#define HWRM_QUEUE_QPORTCFG                       UINT32_C(0x30)
	#define HWRM_QUEUE_QCFG                           UINT32_C(0x31)
	#define HWRM_QUEUE_CFG                            UINT32_C(0x32)
	#define HWRM_FUNC_VLAN_CFG                        UINT32_C(0x33)
	#define HWRM_FUNC_VLAN_QCFG                       UINT32_C(0x34)
	#define HWRM_QUEUE_PFCENABLE_QCFG                 UINT32_C(0x35)
	#define HWRM_QUEUE_PFCENABLE_CFG                  UINT32_C(0x36)
	#define HWRM_QUEUE_PRI2COS_QCFG                   UINT32_C(0x37)
	#define HWRM_QUEUE_PRI2COS_CFG                    UINT32_C(0x38)
	#define HWRM_QUEUE_COS2BW_QCFG                    UINT32_C(0x39)
	#define HWRM_QUEUE_COS2BW_CFG                     UINT32_C(0x3a)
	#define HWRM_QUEUE_DSCP_QCAPS                     UINT32_C(0x3b)
	#define HWRM_QUEUE_DSCP2PRI_QCFG                  UINT32_C(0x3c)
	#define HWRM_QUEUE_DSCP2PRI_CFG                   UINT32_C(0x3d)
	#define HWRM_VNIC_ALLOC                           UINT32_C(0x40)
	#define HWRM_VNIC_FREE                            UINT32_C(0x41)
	#define HWRM_VNIC_CFG                             UINT32_C(0x42)
	#define HWRM_VNIC_QCFG                            UINT32_C(0x43)
	#define HWRM_VNIC_TPA_CFG                         UINT32_C(0x44)
	/* Experimental */
	#define HWRM_VNIC_TPA_QCFG                        UINT32_C(0x45)
	#define HWRM_VNIC_RSS_CFG                         UINT32_C(0x46)
	#define HWRM_VNIC_RSS_QCFG                        UINT32_C(0x47)
	#define HWRM_VNIC_PLCMODES_CFG                    UINT32_C(0x48)
	#define HWRM_VNIC_PLCMODES_QCFG                   UINT32_C(0x49)
	#define HWRM_VNIC_QCAPS                           UINT32_C(0x4a)
	/* Updates specific fields in RX VNIC structure */
	#define HWRM_VNIC_UPDATE                          UINT32_C(0x4b)
	#define HWRM_RING_ALLOC                           UINT32_C(0x50)
	#define HWRM_RING_FREE                            UINT32_C(0x51)
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS        UINT32_C(0x52)
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS     UINT32_C(0x53)
	#define HWRM_RING_AGGINT_QCAPS                    UINT32_C(0x54)
	#define HWRM_RING_SCHQ_ALLOC                      UINT32_C(0x55)
	#define HWRM_RING_SCHQ_CFG                        UINT32_C(0x56)
	#define HWRM_RING_SCHQ_FREE                       UINT32_C(0x57)
	#define HWRM_RING_RESET                           UINT32_C(0x5e)
	#define HWRM_RING_GRP_ALLOC                       UINT32_C(0x60)
	#define HWRM_RING_GRP_FREE                        UINT32_C(0x61)
	#define HWRM_RING_CFG                             UINT32_C(0x62)
	#define HWRM_RING_QCFG                            UINT32_C(0x63)
	/* Reserved for future use. */
	#define HWRM_RESERVED5                            UINT32_C(0x64)
	/* Reserved for future use. */
	#define HWRM_RESERVED6                            UINT32_C(0x65)
	#define HWRM_VNIC_RSS_COS_LB_CTX_ALLOC            UINT32_C(0x70)
	#define HWRM_VNIC_RSS_COS_LB_CTX_FREE             UINT32_C(0x71)
	#define HWRM_QUEUE_MPLS_QCAPS                     UINT32_C(0x80)
	#define HWRM_QUEUE_MPLSTC2PRI_QCFG                UINT32_C(0x81)
	#define HWRM_QUEUE_MPLSTC2PRI_CFG                 UINT32_C(0x82)
	#define HWRM_QUEUE_VLANPRI_QCAPS                  UINT32_C(0x83)
	#define HWRM_QUEUE_VLANPRI2PRI_QCFG               UINT32_C(0x84)
	#define HWRM_QUEUE_VLANPRI2PRI_CFG                UINT32_C(0x85)
	#define HWRM_QUEUE_GLOBAL_CFG                     UINT32_C(0x86)
	#define HWRM_QUEUE_GLOBAL_QCFG                    UINT32_C(0x87)
	#define HWRM_CFA_L2_FILTER_ALLOC                  UINT32_C(0x90)
	#define HWRM_CFA_L2_FILTER_FREE                   UINT32_C(0x91)
	#define HWRM_CFA_L2_FILTER_CFG                    UINT32_C(0x92)
	#define HWRM_CFA_L2_SET_RX_MASK                   UINT32_C(0x93)
	#define HWRM_CFA_VLAN_ANTISPOOF_CFG               UINT32_C(0x94)
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC              UINT32_C(0x95)
	#define HWRM_CFA_TUNNEL_FILTER_FREE               UINT32_C(0x96)
	/* Experimental */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC               UINT32_C(0x97)
	/* Experimental */
	#define HWRM_CFA_ENCAP_RECORD_FREE                UINT32_C(0x98)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC              UINT32_C(0x99)
	#define HWRM_CFA_NTUPLE_FILTER_FREE               UINT32_C(0x9a)
	#define HWRM_CFA_NTUPLE_FILTER_CFG                UINT32_C(0x9b)
	/* Experimental */
	#define HWRM_CFA_EM_FLOW_ALLOC                    UINT32_C(0x9c)
	/* Experimental */
	#define HWRM_CFA_EM_FLOW_FREE                     UINT32_C(0x9d)
	/* Experimental */
	#define HWRM_CFA_EM_FLOW_CFG                      UINT32_C(0x9e)
	#define HWRM_TUNNEL_DST_PORT_QUERY                UINT32_C(0xa0)
	#define HWRM_TUNNEL_DST_PORT_ALLOC                UINT32_C(0xa1)
	#define HWRM_TUNNEL_DST_PORT_FREE                 UINT32_C(0xa2)
	#define HWRM_STAT_CTX_ENG_QUERY                   UINT32_C(0xaf)
	#define HWRM_STAT_CTX_ALLOC                       UINT32_C(0xb0)
	#define HWRM_STAT_CTX_FREE                        UINT32_C(0xb1)
	#define HWRM_STAT_CTX_QUERY                       UINT32_C(0xb2)
	#define HWRM_STAT_CTX_CLR_STATS                   UINT32_C(0xb3)
	#define HWRM_PORT_QSTATS_EXT                      UINT32_C(0xb4)
	#define HWRM_PORT_PHY_MDIO_WRITE                  UINT32_C(0xb5)
	#define HWRM_PORT_PHY_MDIO_READ                   UINT32_C(0xb6)
	#define HWRM_PORT_PHY_MDIO_BUS_ACQUIRE            UINT32_C(0xb7)
	#define HWRM_PORT_PHY_MDIO_BUS_RELEASE            UINT32_C(0xb8)
	#define HWRM_PORT_QSTATS_EXT_PFC_WD               UINT32_C(0xb9)
	/* Reserved. */
	#define HWRM_RESERVED7                            UINT32_C(0xba)
	#define HWRM_PORT_TX_FIR_CFG                      UINT32_C(0xbb)
	#define HWRM_PORT_TX_FIR_QCFG                     UINT32_C(0xbc)
	#define HWRM_PORT_ECN_QSTATS                      UINT32_C(0xbd)
	#define HWRM_FW_LIVEPATCH_QUERY                   UINT32_C(0xbe)
	#define HWRM_FW_LIVEPATCH                         UINT32_C(0xbf)
	#define HWRM_FW_RESET                             UINT32_C(0xc0)
	#define HWRM_FW_QSTATUS                           UINT32_C(0xc1)
	#define HWRM_FW_HEALTH_CHECK                      UINT32_C(0xc2)
	#define HWRM_FW_SYNC                              UINT32_C(0xc3)
	#define HWRM_FW_STATE_QCAPS                       UINT32_C(0xc4)
	#define HWRM_FW_STATE_QUIESCE                     UINT32_C(0xc5)
	#define HWRM_FW_STATE_BACKUP                      UINT32_C(0xc6)
	#define HWRM_FW_STATE_RESTORE                     UINT32_C(0xc7)
	/* Experimental */
	#define HWRM_FW_SET_TIME                          UINT32_C(0xc8)
	/* Experimental */
	#define HWRM_FW_GET_TIME                          UINT32_C(0xc9)
	/* Experimental */
	#define HWRM_FW_SET_STRUCTURED_DATA               UINT32_C(0xca)
	/* Experimental */
	#define HWRM_FW_GET_STRUCTURED_DATA               UINT32_C(0xcb)
	/* Experimental */
	#define HWRM_FW_IPC_MAILBOX                       UINT32_C(0xcc)
	#define HWRM_FW_ECN_CFG                           UINT32_C(0xcd)
	#define HWRM_FW_ECN_QCFG                          UINT32_C(0xce)
	#define HWRM_FW_SECURE_CFG                        UINT32_C(0xcf)
	#define HWRM_EXEC_FWD_RESP                        UINT32_C(0xd0)
	#define HWRM_REJECT_FWD_RESP                      UINT32_C(0xd1)
	#define HWRM_FWD_RESP                             UINT32_C(0xd2)
	#define HWRM_FWD_ASYNC_EVENT_CMPL                 UINT32_C(0xd3)
	#define HWRM_OEM_CMD                              UINT32_C(0xd4)
	/* Tells the fw to run PRBS test on a given port and lane. */
	#define HWRM_PORT_PRBS_TEST                       UINT32_C(0xd5)
	#define HWRM_PORT_SFP_SIDEBAND_CFG                UINT32_C(0xd6)
	#define HWRM_PORT_SFP_SIDEBAND_QCFG               UINT32_C(0xd7)
	#define HWRM_FW_STATE_UNQUIESCE                   UINT32_C(0xd8)
	/* Tells the fw to collect dsc dump on a given port and lane. */
	#define HWRM_PORT_DSC_DUMP                        UINT32_C(0xd9)
	#define HWRM_PORT_EP_TX_QCFG                      UINT32_C(0xda)
	#define HWRM_PORT_EP_TX_CFG                       UINT32_C(0xdb)
	#define HWRM_PORT_CFG                             UINT32_C(0xdc)
	#define HWRM_PORT_QCFG                            UINT32_C(0xdd)
	#define HWRM_TEMP_MONITOR_QUERY                   UINT32_C(0xe0)
	#define HWRM_REG_POWER_QUERY                      UINT32_C(0xe1)
	#define HWRM_CORE_FREQUENCY_QUERY                 UINT32_C(0xe2)
	#define HWRM_REG_POWER_HISTOGRAM                  UINT32_C(0xe3)
	#define HWRM_WOL_FILTER_ALLOC                     UINT32_C(0xf0)
	#define HWRM_WOL_FILTER_FREE                      UINT32_C(0xf1)
	#define HWRM_WOL_FILTER_QCFG                      UINT32_C(0xf2)
	#define HWRM_WOL_REASON_QCFG                      UINT32_C(0xf3)
	/* Experimental */
	#define HWRM_CFA_METER_QCAPS                      UINT32_C(0xf4)
	/* Experimental */
	#define HWRM_CFA_METER_PROFILE_ALLOC              UINT32_C(0xf5)
	/* Experimental */
	#define HWRM_CFA_METER_PROFILE_FREE               UINT32_C(0xf6)
	/* Experimental */
	#define HWRM_CFA_METER_PROFILE_CFG                UINT32_C(0xf7)
	/* Experimental */
	#define HWRM_CFA_METER_INSTANCE_ALLOC             UINT32_C(0xf8)
	/* Experimental */
	#define HWRM_CFA_METER_INSTANCE_FREE              UINT32_C(0xf9)
	/* Experimental */
	#define HWRM_CFA_METER_INSTANCE_CFG               UINT32_C(0xfa)
	/* Experimental */
	#define HWRM_CFA_VFR_ALLOC                        UINT32_C(0xfd)
	/* Experimental */
	#define HWRM_CFA_VFR_FREE                         UINT32_C(0xfe)
	/* Experimental */
	#define HWRM_CFA_VF_PAIR_ALLOC                    UINT32_C(0x100)
	/* Experimental */
	#define HWRM_CFA_VF_PAIR_FREE                     UINT32_C(0x101)
	/* Experimental */
	#define HWRM_CFA_VF_PAIR_INFO                     UINT32_C(0x102)
	/* Experimental */
	#define HWRM_CFA_FLOW_ALLOC                       UINT32_C(0x103)
	/* Experimental */
	#define HWRM_CFA_FLOW_FREE                        UINT32_C(0x104)
	/* Experimental */
	#define HWRM_CFA_FLOW_FLUSH                       UINT32_C(0x105)
	#define HWRM_CFA_FLOW_STATS                       UINT32_C(0x106)
	#define HWRM_CFA_FLOW_INFO                        UINT32_C(0x107)
	/* Experimental */
	#define HWRM_CFA_DECAP_FILTER_ALLOC               UINT32_C(0x108)
	/* Experimental */
	#define HWRM_CFA_DECAP_FILTER_FREE                UINT32_C(0x109)
	#define HWRM_CFA_VLAN_ANTISPOOF_QCFG              UINT32_C(0x10a)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC       UINT32_C(0x10b)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE        UINT32_C(0x10c)
	/* Experimental */
	#define HWRM_CFA_PAIR_ALLOC                       UINT32_C(0x10d)
	/* Experimental */
	#define HWRM_CFA_PAIR_FREE                        UINT32_C(0x10e)
	/* Experimental */
	#define HWRM_CFA_PAIR_INFO                        UINT32_C(0x10f)
	/* Experimental */
	#define HWRM_FW_IPC_MSG                           UINT32_C(0x110)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO        UINT32_C(0x111)
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE       UINT32_C(0x112)
	/* Experimental */
	#define HWRM_CFA_FLOW_AGING_TIMER_RESET           UINT32_C(0x113)
	/* Experimental */
	#define HWRM_CFA_FLOW_AGING_CFG                   UINT32_C(0x114)
	/* Experimental */
	#define HWRM_CFA_FLOW_AGING_QCFG                  UINT32_C(0x115)
	/* Experimental */
	#define HWRM_CFA_FLOW_AGING_QCAPS                 UINT32_C(0x116)
	/* Experimental */
	#define HWRM_CFA_CTX_MEM_RGTR                     UINT32_C(0x117)
	/* Experimental */
	#define HWRM_CFA_CTX_MEM_UNRGTR                   UINT32_C(0x118)
	/* Experimental */
	#define HWRM_CFA_CTX_MEM_QCTX                     UINT32_C(0x119)
	/* Experimental */
	#define HWRM_CFA_CTX_MEM_QCAPS                    UINT32_C(0x11a)
	/* Experimental */
	#define HWRM_CFA_COUNTER_QCAPS                    UINT32_C(0x11b)
	/* Experimental */
	#define HWRM_CFA_COUNTER_CFG                      UINT32_C(0x11c)
	/* Experimental */
	#define HWRM_CFA_COUNTER_QCFG                     UINT32_C(0x11d)
	/* Experimental */
	#define HWRM_CFA_COUNTER_QSTATS                   UINT32_C(0x11e)
	/* Experimental */
	#define HWRM_CFA_TCP_FLAG_PROCESS_QCFG            UINT32_C(0x11f)
	/* Experimental */
	#define HWRM_CFA_EEM_QCAPS                        UINT32_C(0x120)
	/* Experimental */
	#define HWRM_CFA_EEM_CFG                          UINT32_C(0x121)
	/* Experimental */
	#define HWRM_CFA_EEM_QCFG                         UINT32_C(0x122)
	/* Experimental */
	#define HWRM_CFA_EEM_OP                           UINT32_C(0x123)
	/* Experimental */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS              UINT32_C(0x124)
	/* Experimental - DEPRECATED */
	#define HWRM_CFA_TFLIB                            UINT32_C(0x125)
	/* Experimental */
	#define HWRM_CFA_LAG_GROUP_MEMBER_RGTR            UINT32_C(0x126)
	/* Experimental */
	#define HWRM_CFA_LAG_GROUP_MEMBER_UNRGTR          UINT32_C(0x127)
	/* Experimental */
	#define HWRM_CFA_TLS_FILTER_ALLOC                 UINT32_C(0x128)
	/* Experimental */
	#define HWRM_CFA_TLS_FILTER_FREE                  UINT32_C(0x129)
	/* Engine CKV - Get the current allocation status of keys provisioned in the key vault. */
	#define HWRM_ENGINE_CKV_STATUS                    UINT32_C(0x12e)
	/* Engine CKV - Add a new CKEK used to encrypt keys. */
	#define HWRM_ENGINE_CKV_CKEK_ADD                  UINT32_C(0x12f)
	/* Engine CKV - Delete a previously added CKEK. */
	#define HWRM_ENGINE_CKV_CKEK_DELETE               UINT32_C(0x130)
	/* Engine CKV - Add a new key to the key vault. */
	#define HWRM_ENGINE_CKV_KEY_ADD                   UINT32_C(0x131)
	/* Engine CKV - Delete a key from the key vault. */
	#define HWRM_ENGINE_CKV_KEY_DELETE                UINT32_C(0x132)
	/* Engine CKV - Delete all keys from the key vault. */
	#define HWRM_ENGINE_CKV_FLUSH                     UINT32_C(0x133)
	/* Engine CKV - Get random data. */
	#define HWRM_ENGINE_CKV_RNG_GET                   UINT32_C(0x134)
	/* Engine CKV - Generate and encrypt a new AES key. */
	#define HWRM_ENGINE_CKV_KEY_GEN                   UINT32_C(0x135)
	/* Engine CKV - Configure a label index with a label value. */
	#define HWRM_ENGINE_CKV_KEY_LABEL_CFG             UINT32_C(0x136)
	/* Engine CKV - Query a label */
	#define HWRM_ENGINE_CKV_KEY_LABEL_QCFG            UINT32_C(0x137)
	/* Engine - Query the available queue groups configuration. */
	#define HWRM_ENGINE_QG_CONFIG_QUERY               UINT32_C(0x13c)
	/* Engine - Query the queue groups assigned to a function. */
	#define HWRM_ENGINE_QG_QUERY                      UINT32_C(0x13d)
	/* Engine - Query the available queue group meter profile configuration. */
	#define HWRM_ENGINE_QG_METER_PROFILE_CONFIG_QUERY UINT32_C(0x13e)
	/* Engine - Query the configuration of a queue group meter profile. */
	#define HWRM_ENGINE_QG_METER_PROFILE_QUERY        UINT32_C(0x13f)
	/* Engine - Allocate a queue group meter profile. */
	#define HWRM_ENGINE_QG_METER_PROFILE_ALLOC        UINT32_C(0x140)
	/* Engine - Free a queue group meter profile. */
	#define HWRM_ENGINE_QG_METER_PROFILE_FREE         UINT32_C(0x141)
	/* Engine - Query the meters assigned to a queue group. */
	#define HWRM_ENGINE_QG_METER_QUERY                UINT32_C(0x142)
	/* Engine - Bind a queue group meter profile to a queue group. */
	#define HWRM_ENGINE_QG_METER_BIND                 UINT32_C(0x143)
	/* Engine - Unbind a queue group meter profile from a queue group. */
	#define HWRM_ENGINE_QG_METER_UNBIND               UINT32_C(0x144)
	/* Engine - Bind a queue group to a function. */
	#define HWRM_ENGINE_QG_FUNC_BIND                  UINT32_C(0x145)
	/* Engine - Query the scheduling group configuration. */
	#define HWRM_ENGINE_SG_CONFIG_QUERY               UINT32_C(0x146)
	/* Engine - Query the queue groups assigned to a scheduling group. */
	#define HWRM_ENGINE_SG_QUERY                      UINT32_C(0x147)
	/* Engine - Query the configuration of a scheduling group's meter profiles. */
	#define HWRM_ENGINE_SG_METER_QUERY                UINT32_C(0x148)
	/* Engine - Configure a scheduling group's meter profiles. */
	#define HWRM_ENGINE_SG_METER_CONFIG               UINT32_C(0x149)
	/* Engine - Bind a queue group to a scheduling group. */
	#define HWRM_ENGINE_SG_QG_BIND                    UINT32_C(0x14a)
	/* Engine - Unbind a queue group from its scheduling group. */
	#define HWRM_ENGINE_QG_SG_UNBIND                  UINT32_C(0x14b)
	/* Engine - Query the Engine configuration. */
	#define HWRM_ENGINE_CONFIG_QUERY                  UINT32_C(0x154)
	/* Engine - Configure the statistics accumulator for an Engine. */
	#define HWRM_ENGINE_STATS_CONFIG                  UINT32_C(0x155)
	/* Engine - Clear the statistics accumulator for an Engine. */
	#define HWRM_ENGINE_STATS_CLEAR                   UINT32_C(0x156)
	/* Engine - Query the statistics accumulator for an Engine. */
	#define HWRM_ENGINE_STATS_QUERY                   UINT32_C(0x157)
	/* Engine - Query statistics counters for continuous errors from all CDDIP Engines. */
	#define HWRM_ENGINE_STATS_QUERY_CONTINUOUS_ERROR  UINT32_C(0x158)
	/* Engine - Allocate an Engine RQ. */
	#define HWRM_ENGINE_RQ_ALLOC                      UINT32_C(0x15e)
	/* Engine - Free an Engine RQ. */
	#define HWRM_ENGINE_RQ_FREE                       UINT32_C(0x15f)
	/* Engine - Allocate an Engine CQ. */
	#define HWRM_ENGINE_CQ_ALLOC                      UINT32_C(0x160)
	/* Engine - Free an Engine CQ. */
	#define HWRM_ENGINE_CQ_FREE                       UINT32_C(0x161)
	/* Engine - Allocate an NQ. */
	#define HWRM_ENGINE_NQ_ALLOC                      UINT32_C(0x162)
	/* Engine - Free an NQ. */
	#define HWRM_ENGINE_NQ_FREE                       UINT32_C(0x163)
	/* Engine - Set the on-die RQE credit update location. */
	#define HWRM_ENGINE_ON_DIE_RQE_CREDITS            UINT32_C(0x164)
	/* Engine - Query the engine function configuration. */
	#define HWRM_ENGINE_FUNC_QCFG                     UINT32_C(0x165)
	/* Experimental */
	#define HWRM_FUNC_RESOURCE_QCAPS                  UINT32_C(0x190)
	/* Experimental */
	#define HWRM_FUNC_VF_RESOURCE_CFG                 UINT32_C(0x191)
	/* Experimental */
	#define HWRM_FUNC_BACKING_STORE_QCAPS             UINT32_C(0x192)
	/* Experimental */
	#define HWRM_FUNC_BACKING_STORE_CFG               UINT32_C(0x193)
	/* Experimental */
	#define HWRM_FUNC_BACKING_STORE_QCFG              UINT32_C(0x194)
	/* Configures the BW of any VF */
	#define HWRM_FUNC_VF_BW_CFG                       UINT32_C(0x195)
	/* Queries the BW of any VF */
	#define HWRM_FUNC_VF_BW_QCFG                      UINT32_C(0x196)
	/* Queries pf ids belong to specified host(s) */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY               UINT32_C(0x197)
	/* Queries extended stats per function */
	#define HWRM_FUNC_QSTATS_EXT                      UINT32_C(0x198)
	/* Queries extended statistics context */
	#define HWRM_STAT_EXT_CTX_QUERY                   UINT32_C(0x199)
	/* Configure SoC packet DMA settings */
	#define HWRM_FUNC_SPD_CFG                         UINT32_C(0x19a)
	/* Query SoC packet DMA settings */
	#define HWRM_FUNC_SPD_QCFG                        UINT32_C(0x19b)
	/* PTP - Queries configuration of timesync IO pins. */
	#define HWRM_FUNC_PTP_PIN_QCFG                    UINT32_C(0x19c)
	/* PTP - Configuration of timesync IO pins. */
	#define HWRM_FUNC_PTP_PIN_CFG                     UINT32_C(0x19d)
	/* PTP - Configuration for disciplining PHC. */
	#define HWRM_FUNC_PTP_CFG                         UINT32_C(0x19e)
	/* PTP - Queries for PHC timestamps. */
	#define HWRM_FUNC_PTP_TS_QUERY                    UINT32_C(0x19f)
	/* PTP - Extended PTP configuration. */
	#define HWRM_FUNC_PTP_EXT_CFG                     UINT32_C(0x1a0)
	/* PTP - Query extended PTP configuration. */
	#define HWRM_FUNC_PTP_EXT_QCFG                    UINT32_C(0x1a1)
	/* The command is used to allocate KTLS or QUIC key contexts. */
	#define HWRM_FUNC_KEY_CTX_ALLOC                   UINT32_C(0x1a2)
	/* The is the new API to configure backing stores. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2            UINT32_C(0x1a3)
	/* The is the new API to query backing store configurations. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2           UINT32_C(0x1a4)
	/* To support doorbell pacing configuration. */
	#define HWRM_FUNC_DBR_PACING_CFG                  UINT32_C(0x1a5)
	/* To query doorbell pacing configuration. */
	#define HWRM_FUNC_DBR_PACING_QCFG                 UINT32_C(0x1a6)
	/*
	 * To broadcast the doorbell event to the drivers to
	 * initiate pacing of doorbells.
	 */
	#define HWRM_FUNC_DBR_PACING_BROADCAST_EVENT      UINT32_C(0x1a7)
	/* The is the new API to query backing store capabilities. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2          UINT32_C(0x1a8)
	/* To query doorbell pacing NQ id list configuration. */
	#define HWRM_FUNC_DBR_PACING_NQLIST_QUERY         UINT32_C(0x1a9)
	/*
	 * To notify the firmware that recovery cycle has been
	 * completed by host function drivers.
	 */
	#define HWRM_FUNC_DBR_RECOVERY_COMPLETED          UINT32_C(0x1aa)
	/* Configures SyncE configurations. */
	#define HWRM_FUNC_SYNCE_CFG                       UINT32_C(0x1ab)
	/* Queries SyncE configurations. */
	#define HWRM_FUNC_SYNCE_QCFG                      UINT32_C(0x1ac)
	/* Experimental */
	#define HWRM_SELFTEST_QLIST                       UINT32_C(0x200)
	/* Experimental */
	#define HWRM_SELFTEST_EXEC                        UINT32_C(0x201)
	/* Experimental */
	#define HWRM_SELFTEST_IRQ                         UINT32_C(0x202)
	/* Experimental */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA        UINT32_C(0x203)
	/* Experimental */
	#define HWRM_PCIE_QSTATS                          UINT32_C(0x204)
	/* Experimental */
	#define HWRM_MFG_FRU_WRITE_CONTROL                UINT32_C(0x205)
	/* Returns the current value of a free running counter from the device. */
	#define HWRM_MFG_TIMERS_QUERY                     UINT32_C(0x206)
	/* Experimental */
	#define HWRM_MFG_OTP_CFG                          UINT32_C(0x207)
	/* Experimental */
	#define HWRM_MFG_OTP_QCFG                         UINT32_C(0x208)
	/*
	 * Tells the fw to run the DMA read from the host and DMA write
	 * to the host test.
	 */
	#define HWRM_MFG_HDMA_TEST                        UINT32_C(0x209)
	/* Tells the fw to program the fru memory */
	#define HWRM_MFG_FRU_EEPROM_WRITE                 UINT32_C(0x20a)
	/* Tells the fw to read the fru memory */
	#define HWRM_MFG_FRU_EEPROM_READ                  UINT32_C(0x20b)
	/* Used to provision SoC software images */
	#define HWRM_MFG_SOC_IMAGE                        UINT32_C(0x20c)
	/* Retrieves the SoC status and image provisioning information */
	#define HWRM_MFG_SOC_QSTATUS                      UINT32_C(0x20d)
	/* Tells the fw to program the seeprom memory */
	#define HWRM_MFG_PARAM_SEEPROM_SYNC               UINT32_C(0x20e)
	/* Tells the fw to read the seeprom memory */
	#define HWRM_MFG_PARAM_SEEPROM_READ               UINT32_C(0x20f)
	/* Tells the fw to get the health of seeprom data */
	#define HWRM_MFG_PARAM_SEEPROM_HEALTH             UINT32_C(0x210)
	/*
	 * The command is used for certificate provisioning to export a
	 * Certificate Signing Request (CSR) from the device.
	 */
	#define HWRM_MFG_PRVSN_EXPORT_CSR                 UINT32_C(0x211)
	/*
	 * The command is used for certificate provisioning to import a
	 * CA-signed certificate chain to the device.
	 */
	#define HWRM_MFG_PRVSN_IMPORT_CERT                UINT32_C(0x212)
	/*
	 * The command is used for certificate provisioning to query the
	 * provisioned state.
	 */
	#define HWRM_MFG_PRVSN_GET_STATE                  UINT32_C(0x213)
	/*
	 * The command is used to get the hash of the NVM configuration that is
	 * calculated during firmware boot.
	 */
	#define HWRM_MFG_GET_NVM_MEASUREMENT              UINT32_C(0x214)
	/* Retrieves the PSOC status and provisioning information. */
	#define HWRM_MFG_PSOC_QSTATUS                     UINT32_C(0x215)
	/*
	 * This command allows manufacturing tool to determine which selftests
	 * are available to be run.
	 */
	#define HWRM_MFG_SELFTEST_QLIST                   UINT32_C(0x216)
	/*
	 * This command allows manufacturing tool to request which selftests
	 * to run.
	 */
	#define HWRM_MFG_SELFTEST_EXEC                    UINT32_C(0x217)
	/* Queries the generic stats */
	#define HWRM_STAT_GENERIC_QSTATS                  UINT32_C(0x218)
	/* Experimental */
	#define HWRM_TF                                   UINT32_C(0x2bc)
	/* Experimental */
	#define HWRM_TF_VERSION_GET                       UINT32_C(0x2bd)
	/* Experimental */
	#define HWRM_TF_SESSION_OPEN                      UINT32_C(0x2c6)
	/* Experimental */
	#define HWRM_TF_SESSION_ATTACH                    UINT32_C(0x2c7)
	/* Experimental */
	#define HWRM_TF_SESSION_REGISTER                  UINT32_C(0x2c8)
	/* Experimental */
	#define HWRM_TF_SESSION_UNREGISTER                UINT32_C(0x2c9)
	/* Experimental */
	#define HWRM_TF_SESSION_CLOSE                     UINT32_C(0x2ca)
	/* Experimental */
	#define HWRM_TF_SESSION_QCFG                      UINT32_C(0x2cb)
	/* Experimental */
	#define HWRM_TF_SESSION_RESC_QCAPS                UINT32_C(0x2cc)
	/* Experimental */
	#define HWRM_TF_SESSION_RESC_ALLOC                UINT32_C(0x2cd)
	/* Experimental */
	#define HWRM_TF_SESSION_RESC_FREE                 UINT32_C(0x2ce)
	/* Experimental */
	#define HWRM_TF_SESSION_RESC_FLUSH                UINT32_C(0x2cf)
	/* Experimental */
	#define HWRM_TF_SESSION_RESC_INFO                 UINT32_C(0x2d0)
	/* Experimental */
	#define HWRM_TF_SESSION_HOTUP_STATE_SET           UINT32_C(0x2d1)
	/* Experimental */
	#define HWRM_TF_SESSION_HOTUP_STATE_GET           UINT32_C(0x2d2)
	/* Experimental */
	#define HWRM_TF_TBL_TYPE_GET                      UINT32_C(0x2da)
	/* Experimental */
	#define HWRM_TF_TBL_TYPE_SET                      UINT32_C(0x2db)
	/* Experimental */
	#define HWRM_TF_TBL_TYPE_BULK_GET                 UINT32_C(0x2dc)
	/* Experimental */
	#define HWRM_TF_CTXT_MEM_ALLOC                    UINT32_C(0x2e2)
	/* Experimental */
	#define HWRM_TF_CTXT_MEM_FREE                     UINT32_C(0x2e3)
	/* Experimental */
	#define HWRM_TF_CTXT_MEM_RGTR                     UINT32_C(0x2e4)
	/* Experimental */
	#define HWRM_TF_CTXT_MEM_UNRGTR                   UINT32_C(0x2e5)
	/* Experimental */
	#define HWRM_TF_EXT_EM_QCAPS                      UINT32_C(0x2e6)
	/* Experimental */
	#define HWRM_TF_EXT_EM_OP                         UINT32_C(0x2e7)
	/* Experimental */
	#define HWRM_TF_EXT_EM_CFG                        UINT32_C(0x2e8)
	/* Experimental */
	#define HWRM_TF_EXT_EM_QCFG                       UINT32_C(0x2e9)
	/* Experimental */
	#define HWRM_TF_EM_INSERT                         UINT32_C(0x2ea)
	/* Experimental */
	#define HWRM_TF_EM_DELETE                         UINT32_C(0x2eb)
	/* Experimental */
	#define HWRM_TF_EM_HASH_INSERT                    UINT32_C(0x2ec)
	/* Experimental */
	#define HWRM_TF_EM_MOVE                           UINT32_C(0x2ed)
	/* Experimental */
	#define HWRM_TF_TCAM_SET                          UINT32_C(0x2f8)
	/* Experimental */
	#define HWRM_TF_TCAM_GET                          UINT32_C(0x2f9)
	/* Experimental */
	#define HWRM_TF_TCAM_MOVE                         UINT32_C(0x2fa)
	/* Experimental */
	#define HWRM_TF_TCAM_FREE                         UINT32_C(0x2fb)
	/* Experimental */
	#define HWRM_TF_GLOBAL_CFG_SET                    UINT32_C(0x2fc)
	/* Experimental */
	#define HWRM_TF_GLOBAL_CFG_GET                    UINT32_C(0x2fd)
	/* Experimental */
	#define HWRM_TF_IF_TBL_SET                        UINT32_C(0x2fe)
	/* Experimental */
	#define HWRM_TF_IF_TBL_GET                        UINT32_C(0x2ff)
	/* TruFlow command to check firmware table scope capabilities. */
	#define HWRM_TFC_TBL_SCOPE_QCAPS                  UINT32_C(0x380)
	/* TruFlow command to allocate a table scope ID and create the pools. */
	#define HWRM_TFC_TBL_SCOPE_ID_ALLOC               UINT32_C(0x381)
	/* TruFlow command to configure the table scope memory. */
	#define HWRM_TFC_TBL_SCOPE_CONFIG                 UINT32_C(0x382)
	/* TruFlow command to deconfigure a table scope memory. */
	#define HWRM_TFC_TBL_SCOPE_DECONFIG               UINT32_C(0x383)
	/* TruFlow command to add a FID to a table scope. */
	#define HWRM_TFC_TBL_SCOPE_FID_ADD                UINT32_C(0x384)
	/* TruFlow command to remove a FID from a table scope. */
	#define HWRM_TFC_TBL_SCOPE_FID_REM                UINT32_C(0x385)
	/* TruFlow command to allocate a table scope pool. */
	#define HWRM_TFC_TBL_SCOPE_POOL_ALLOC             UINT32_C(0x386)
	/* TruFlow command to free a table scope pool. */
	#define HWRM_TFC_TBL_SCOPE_POOL_FREE              UINT32_C(0x387)
	/* Experimental */
	#define HWRM_TFC_SESSION_ID_ALLOC                 UINT32_C(0x388)
	/* Experimental */
	#define HWRM_TFC_SESSION_FID_ADD                  UINT32_C(0x389)
	/* Experimental */
	#define HWRM_TFC_SESSION_FID_REM                  UINT32_C(0x38a)
	/* Experimental */
	#define HWRM_TFC_IDENT_ALLOC                      UINT32_C(0x38b)
	/* Experimental */
	#define HWRM_TFC_IDENT_FREE                       UINT32_C(0x38c)
	/* TruFlow command to allocate an index table entry */
	#define HWRM_TFC_IDX_TBL_ALLOC                    UINT32_C(0x38d)
	/* TruFlow command to allocate and set an index table entry */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET                UINT32_C(0x38e)
	/* TruFlow command to set an index table entry */
	#define HWRM_TFC_IDX_TBL_SET                      UINT32_C(0x38f)
	/* TruFlow command to get an index table entry */
	#define HWRM_TFC_IDX_TBL_GET                      UINT32_C(0x390)
	/* TruFlow command to free an index table entry */
	#define HWRM_TFC_IDX_TBL_FREE                     UINT32_C(0x391)
	/* TruFlow command to allocate resources for a global id. */
	#define HWRM_TFC_GLOBAL_ID_ALLOC                  UINT32_C(0x392)
	/* TruFlow command to set TCAM entry. */
	#define HWRM_TFC_TCAM_SET                         UINT32_C(0x393)
	/* TruFlow command to get TCAM entry. */
	#define HWRM_TFC_TCAM_GET                         UINT32_C(0x394)
	/* TruFlow command to allocate a TCAM entry. */
	#define HWRM_TFC_TCAM_ALLOC                       UINT32_C(0x395)
	/* TruFlow command allocate and set TCAM entry. */
	#define HWRM_TFC_TCAM_ALLOC_SET                   UINT32_C(0x396)
	/* TruFlow command to free a TCAM entry. */
	#define HWRM_TFC_TCAM_FREE                        UINT32_C(0x397)
	/* Experimental */
	#define HWRM_SV                                   UINT32_C(0x400)
	/* Experimental */
	#define HWRM_DBG_READ_DIRECT                      UINT32_C(0xff10)
	/* Experimental */
	#define HWRM_DBG_READ_INDIRECT                    UINT32_C(0xff11)
	/* Experimental */
	#define HWRM_DBG_WRITE_DIRECT                     UINT32_C(0xff12)
	/* Experimental */
	#define HWRM_DBG_WRITE_INDIRECT                   UINT32_C(0xff13)
	#define HWRM_DBG_DUMP                             UINT32_C(0xff14)
	/* Experimental */
	#define HWRM_DBG_ERASE_NVM                        UINT32_C(0xff15)
	/* Experimental */
	#define HWRM_DBG_CFG                              UINT32_C(0xff16)
	/* Experimental */
	#define HWRM_DBG_COREDUMP_LIST                    UINT32_C(0xff17)
	/* Experimental */
	#define HWRM_DBG_COREDUMP_INITIATE                UINT32_C(0xff18)
	/* Experimental */
	#define HWRM_DBG_COREDUMP_RETRIEVE                UINT32_C(0xff19)
	/* Experimental */
	#define HWRM_DBG_FW_CLI                           UINT32_C(0xff1a)
	/*  */
	#define HWRM_DBG_I2C_CMD                          UINT32_C(0xff1b)
	/*  */
	#define HWRM_DBG_RING_INFO_GET                    UINT32_C(0xff1c)
	/* Experimental */
	#define HWRM_DBG_CRASHDUMP_HEADER                 UINT32_C(0xff1d)
	/* Experimental */
	#define HWRM_DBG_CRASHDUMP_ERASE                  UINT32_C(0xff1e)
	/* Send driver debug information to firmware */
	#define HWRM_DBG_DRV_TRACE                        UINT32_C(0xff1f)
	/* Query debug capabilities of firmware */
	#define HWRM_DBG_QCAPS                            UINT32_C(0xff20)
	/* Retrieve debug settings of firmware */
	#define HWRM_DBG_QCFG                             UINT32_C(0xff21)
	/* Set destination parameters for crashdump medium */
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG             UINT32_C(0xff22)
	/* Experimental */
	#define HWRM_DBG_USEQ_ALLOC                       UINT32_C(0xff23)
	/* Experimental */
	#define HWRM_DBG_USEQ_FREE                        UINT32_C(0xff24)
	/* Experimental */
	#define HWRM_DBG_USEQ_FLUSH                       UINT32_C(0xff25)
	/* Experimental */
	#define HWRM_DBG_USEQ_QCAPS                       UINT32_C(0xff26)
	/* Experimental */
	#define HWRM_DBG_USEQ_CW_CFG                      UINT32_C(0xff27)
	/* Experimental */
	#define HWRM_DBG_USEQ_SCHED_CFG                   UINT32_C(0xff28)
	/* Experimental */
	#define HWRM_DBG_USEQ_RUN                         UINT32_C(0xff29)
	/* Experimental */
	#define HWRM_DBG_USEQ_DELIVERY_REQ                UINT32_C(0xff2a)
	/* Experimental */
	#define HWRM_DBG_USEQ_RESP_HDR                    UINT32_C(0xff2b)
	#define HWRM_NVM_DEFRAG                           UINT32_C(0xffec)
	#define HWRM_NVM_REQ_ARBITRATION                  UINT32_C(0xffed)
	/* Experimental */
	#define HWRM_NVM_FACTORY_DEFAULTS                 UINT32_C(0xffee)
	#define HWRM_NVM_VALIDATE_OPTION                  UINT32_C(0xffef)
	#define HWRM_NVM_FLUSH                            UINT32_C(0xfff0)
	#define HWRM_NVM_GET_VARIABLE                     UINT32_C(0xfff1)
	#define HWRM_NVM_SET_VARIABLE                     UINT32_C(0xfff2)
	#define HWRM_NVM_INSTALL_UPDATE                   UINT32_C(0xfff3)
	#define HWRM_NVM_MODIFY                           UINT32_C(0xfff4)
	#define HWRM_NVM_VERIFY_UPDATE                    UINT32_C(0xfff5)
	#define HWRM_NVM_GET_DEV_INFO                     UINT32_C(0xfff6)
	#define HWRM_NVM_ERASE_DIR_ENTRY                  UINT32_C(0xfff7)
	#define HWRM_NVM_MOD_DIR_ENTRY                    UINT32_C(0xfff8)
	#define HWRM_NVM_FIND_DIR_ENTRY                   UINT32_C(0xfff9)
	#define HWRM_NVM_GET_DIR_ENTRIES                  UINT32_C(0xfffa)
	#define HWRM_NVM_GET_DIR_INFO                     UINT32_C(0xfffb)
	#define HWRM_NVM_RAW_DUMP                         UINT32_C(0xfffc)
	#define HWRM_NVM_READ                             UINT32_C(0xfffd)
	#define HWRM_NVM_WRITE                            UINT32_C(0xfffe)
	#define HWRM_NVM_RAW_WRITE_BLK                    UINT32_C(0xffff)
	#define HWRM_LAST                                HWRM_NVM_RAW_WRITE_BLK
	uint16_t	unused_0[3];
} __rte_packed;

/* Return Codes */
/* ret_codes (size:64b/8B) */
struct ret_codes {
	uint16_t	error_code;
	/* Request was successfully executed by the HWRM. */
	#define HWRM_ERR_CODE_SUCCESS                      UINT32_C(0x0)
	/* The HWRM failed to execute the request. */
	#define HWRM_ERR_CODE_FAIL                         UINT32_C(0x1)
	/*
	 * The request contains invalid argument(s) or input
	 * parameters.
	 */
	#define HWRM_ERR_CODE_INVALID_PARAMS               UINT32_C(0x2)
	/*
	 * The requester is not allowed to access the requested
	 * resource. This error code shall be provided in a
	 * response to a request to query or modify an existing
	 * resource that is not accessible by the requester.
	 */
	#define HWRM_ERR_CODE_RESOURCE_ACCESS_DENIED       UINT32_C(0x3)
	/*
	 * The HWRM is unable to allocate the requested resource.
	 * This code only applies to requests for HWRM resource
	 * allocations.
	 */
	#define HWRM_ERR_CODE_RESOURCE_ALLOC_ERROR         UINT32_C(0x4)
	/*
	 * Invalid combination of flags is specified in the
	 * request.
	 */
	#define HWRM_ERR_CODE_INVALID_FLAGS                UINT32_C(0x5)
	/*
	 * Invalid combination of enables fields is specified in
	 * the request.
	 */
	#define HWRM_ERR_CODE_INVALID_ENABLES              UINT32_C(0x6)
	/*
	 * Request contains a required TLV that is not supported by
	 * the installed version of firmware.
	 */
	#define HWRM_ERR_CODE_UNSUPPORTED_TLV              UINT32_C(0x7)
	/*
	 * No firmware buffer available to accept the request. Driver
	 * should retry the request.
	 */
	#define HWRM_ERR_CODE_NO_BUFFER                    UINT32_C(0x8)
	/*
	 * This error code is only reported by firmware when some
	 * sub-option of a supported HWRM command is unsupported.
	 */
	#define HWRM_ERR_CODE_UNSUPPORTED_OPTION_ERR       UINT32_C(0x9)
	/*
	 * This error code is only reported by firmware when the specific
	 * request is not able to process when the HOT reset in progress.
	 */
	#define HWRM_ERR_CODE_HOT_RESET_PROGRESS           UINT32_C(0xa)
	/*
	 * This error code is only reported by firmware when the registered
	 * driver instances are not capable of hot reset.
	 */
	#define HWRM_ERR_CODE_HOT_RESET_FAIL               UINT32_C(0xb)
	/*
	 * This error code is only reported by the firmware when during
	 * flow allocation when a request for a flow counter fails because
	 * the number of flow counters are exhausted.
	 */
	#define HWRM_ERR_CODE_NO_FLOW_COUNTER_DURING_ALLOC UINT32_C(0xc)
	/*
	 * This error code is only reported by firmware when the registered
	 * driver instances requested to offloaded a flow but was unable to because
	 * the requested key's hash collides with the installed keys.
	 */
	#define HWRM_ERR_CODE_KEY_HASH_COLLISION           UINT32_C(0xd)
	/*
	 * This error code is only reported by firmware when the registered
	 * driver instances requested to offloaded a flow but was unable to because
	 * the same key has already been installed.
	 */
	#define HWRM_ERR_CODE_KEY_ALREADY_EXISTS           UINT32_C(0xe)
	/*
	 * Generic HWRM execution error that represents an
	 * internal error.
	 */
	#define HWRM_ERR_CODE_HWRM_ERROR                   UINT32_C(0xf)
	/*
	 * Firmware is unable to service the request at the present time. Caller
	 * may try again later.
	 */
	#define HWRM_ERR_CODE_BUSY                         UINT32_C(0x10)
	/*
	 * This error code is reported by Firmware when an operation requested
	 * by the host is not allowed due to a secure lock violation.
	 */
	#define HWRM_ERR_CODE_RESOURCE_LOCKED              UINT32_C(0x11)
	/*
	 * This error code is reported by Firmware when an operation requested
	 * by a VF cannot be forwarded to the parent PF as required, either
	 * because the PF is down or otherwise doesn't have an appropriate
	 * async completion ring or associated forwarding buffers configured.
	 */
	#define HWRM_ERR_CODE_PF_UNAVAILABLE               UINT32_C(0x12)
	/*
	 * This value indicates that the HWRM response is in TLV format and
	 * should be interpreted as one or more TLVs starting with the
	 * hwrm_resp_hdr TLV. This value is not an indication of any error
	 * by itself, just an indication that the response should be parsed
	 * as TLV and the actual error code will be in the hwrm_resp_hdr TLV.
	 */
	#define HWRM_ERR_CODE_TLV_ENCAPSULATED_RESPONSE    UINT32_C(0x8000)
	/* Unknown error */
	#define HWRM_ERR_CODE_UNKNOWN_ERR                  UINT32_C(0xfffe)
	/* Unsupported or invalid command */
	#define HWRM_ERR_CODE_CMD_NOT_SUPPORTED            UINT32_C(0xffff)
	#define HWRM_ERR_CODE_LAST \
		HWRM_ERR_CODE_CMD_NOT_SUPPORTED
	uint16_t	unused_0[3];
} __rte_packed;

/* Output */
/* hwrm_err_output (size:128b/16B) */
struct hwrm_err_output {
	/*
	 * Pass/Fail or error type
	 *
	 * Note: receiver to verify the in parameters, and fail the call
	 * with an error when appropriate
	 */
	uint16_t	error_code;
	/* This field returns the type of original request. */
	uint16_t	req_type;
	/* This field provides original sequence number of the command. */
	uint16_t	seq_id;
	/*
	 * This field is the length of the response in bytes.  The
	 * last byte of the response is a valid flag that will read
	 * as '1' when the command has been completely written to
	 * memory.
	 */
	uint16_t	resp_len;
	/* debug info for this error response. */
	uint32_t	opaque_0;
	/* debug info for this error response. */
	uint16_t	opaque_1;
	/*
	 * In the case of an error response, command specific error
	 * code is returned in this field.
	 */
	uint8_t	cmd_err;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;
/*
 * Following is the signature for HWRM message field that indicates not
 * applicable (All F's). Need to cast it the size of the field if needed.
 */
#define HWRM_NA_SIGNATURE ((uint32_t)(-1))
/* hwrm_func_buf_rgtr */
#define HWRM_MAX_REQ_LEN 128
/* hwrm_cfa_flow_info */
#define HWRM_MAX_RESP_LEN 704
/* 7 bit indirection table index. */
#define HW_HASH_INDEX_SIZE 0x80
#define HW_HASH_KEY_SIZE 40
/* valid key for HWRM response */
#define HWRM_RESP_VALID_KEY 1
/* Reserved for BONO processor */
#define HWRM_TARGET_ID_BONO 0xFFF8
/* Reserved for KONG processor */
#define HWRM_TARGET_ID_KONG 0xFFF9
/* Reserved for APE processor */
#define HWRM_TARGET_ID_APE 0xFFFA
/*
 * This value will be used by tools for User-space HWRM Interface.
 * When tool execute any HWRM command with this target_id, firmware
 * will copy the response and/or data payload via register space instead
 * of DMAing it.
 */
#define HWRM_TARGET_ID_TOOLS 0xFFFD
#define HWRM_VERSION_MAJOR 1
#define HWRM_VERSION_MINOR 10
#define HWRM_VERSION_UPDATE 2
/* non-zero means beta version */
#define HWRM_VERSION_RSVD 138
#define HWRM_VERSION_STR "1.10.2.138"

/****************
 * hwrm_ver_get *
 ****************/


/* hwrm_ver_get_input (size:192b/24B) */
struct hwrm_ver_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This field represents the major version of HWRM interface
	 * specification supported by the driver HWRM implementation.
	 * The interface major version is intended to change only when
	 * non backward compatible changes are made to the HWRM
	 * interface specification.
	 */
	uint8_t	hwrm_intf_maj;
	/*
	 * This field represents the minor version of HWRM interface
	 * specification supported by the driver HWRM implementation.
	 * A change in interface minor version is used to reflect
	 * significant backward compatible modification to HWRM
	 * interface specification.
	 * This can be due to addition or removal of functionality.
	 * HWRM interface specifications with the same major version
	 * but different minor versions are compatible.
	 */
	uint8_t	hwrm_intf_min;
	/*
	 * This field represents the update version of HWRM interface
	 * specification supported by the driver HWRM implementation.
	 * The interface update version is used to reflect minor
	 * changes or bug fixes to a released HWRM interface
	 * specification.
	 */
	uint8_t	hwrm_intf_upd;
	uint8_t	unused_0[5];
} __rte_packed;

/* hwrm_ver_get_output (size:1408b/176B) */
struct hwrm_ver_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field represents the major version of HWRM interface
	 * specification supported by the HWRM implementation.
	 * The interface major version is intended to change only when
	 * non backward compatible changes are made to the HWRM
	 * interface specification.
	 * A HWRM implementation that is compliant with this
	 * specification shall provide value of 1 in this field.
	 */
	uint8_t	hwrm_intf_maj_8b;
	/*
	 * This field represents the minor version of HWRM interface
	 * specification supported by the HWRM implementation.
	 * A change in interface minor version is used to reflect
	 * significant backward compatible modification to HWRM
	 * interface specification.
	 * This can be due to addition or removal of functionality.
	 * HWRM interface specifications with the same major version
	 * but different minor versions are compatible.
	 * A HWRM implementation that is compliant with this
	 * specification shall provide value of 2 in this field.
	 */
	uint8_t	hwrm_intf_min_8b;
	/*
	 * This field represents the update version of HWRM interface
	 * specification supported by the HWRM implementation.
	 * The interface update version is used to reflect minor
	 * changes or bug fixes to a released HWRM interface
	 * specification.
	 * A HWRM implementation that is compliant with this
	 * specification shall provide value of 2 in this field.
	 */
	uint8_t	hwrm_intf_upd_8b;
	uint8_t	hwrm_intf_rsvd_8b;
	/*
	 * This field represents the major version of HWRM firmware.
	 * A change in firmware major version represents a major
	 * firmware release.
	 */
	uint8_t	hwrm_fw_maj_8b;
	/*
	 * This field represents the minor version of HWRM firmware.
	 * A change in firmware minor version represents significant
	 * firmware functionality changes.
	 */
	uint8_t	hwrm_fw_min_8b;
	/*
	 * This field represents the build version of HWRM firmware.
	 * A change in firmware build version represents bug fixes
	 * to a released firmware.
	 */
	uint8_t	hwrm_fw_bld_8b;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version of the
	 * HWRM firmware.
	 */
	uint8_t	hwrm_fw_rsvd_8b;
	/*
	 * This field represents the major version of mgmt firmware.
	 * A change in major version represents a major release.
	 */
	uint8_t	mgmt_fw_maj_8b;
	/*
	 * This field represents the minor version of mgmt firmware.
	 * A change in minor version represents significant
	 * functionality changes.
	 */
	uint8_t	mgmt_fw_min_8b;
	/*
	 * This field represents the build version of mgmt firmware.
	 * A change in update version represents bug fixes.
	 */
	uint8_t	mgmt_fw_bld_8b;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version
	 */
	uint8_t	mgmt_fw_rsvd_8b;
	/*
	 * This field represents the major version of network
	 * control firmware.
	 * A change in major version represents a major release.
	 */
	uint8_t	netctrl_fw_maj_8b;
	/*
	 * This field represents the minor version of network
	 * control firmware.
	 * A change in minor version represents significant
	 * functionality changes.
	 */
	uint8_t	netctrl_fw_min_8b;
	/*
	 * This field represents the build version of network
	 * control firmware.
	 * A change in update version represents bug fixes.
	 */
	uint8_t	netctrl_fw_bld_8b;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version
	 */
	uint8_t	netctrl_fw_rsvd_8b;
	/*
	 * This field is used to indicate device's capabilities and
	 * configurations.
	 */
	uint32_t	dev_caps_cfg;
	/*
	 * If set to 1, then secure firmware update behavior
	 * is supported.
	 * If set to 0, then secure firmware update behavior is
	 * not supported.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_SECURE_FW_UPD_SUPPORTED \
		UINT32_C(0x1)
	/*
	 * If set to 1, then firmware based DCBX agent is supported.
	 * If set to 0, then firmware based DCBX agent capability
	 * is not supported on this device.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_FW_DCBX_AGENT_SUPPORTED \
		UINT32_C(0x2)
	/*
	 * If set to 1, then HWRM short command format is supported.
	 * If set to 0, then HWRM short command format is not supported.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_SHORT_CMD_SUPPORTED \
		UINT32_C(0x4)
	/*
	 * If set to 1, then HWRM short command format is required.
	 * If set to 0, then HWRM short command format is not required.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_SHORT_CMD_REQUIRED \
		UINT32_C(0x8)
	/*
	 * If set to 1, then the KONG host mailbox channel is supported.
	 * If set to 0, then the KONG host mailbox channel is not supported.
	 * By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_KONG_MB_CHNL_SUPPORTED \
		UINT32_C(0x10)
	/*
	 * If set to 1, then the 64bit flow handle is supported in addition to the
	 * legacy 16bit flow handle. If set to 0, then the 64bit flow handle is not
	 * supported. By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_FLOW_HANDLE_64BIT_SUPPORTED \
		UINT32_C(0x20)
	/*
	 * If set to 1, then filter type can be provided in filter_alloc or filter_cfg
	 * filter types like L2 for l2 traffic and ROCE for roce & l2 traffic.
	 * If set to 0, then filter types not supported.
	 * By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_L2_FILTER_TYPES_ROCE_OR_L2_SUPPORTED \
		UINT32_C(0x40)
	/*
	 * If set to 1, firmware is capable to support virtio vSwitch offload model.
	 * If set to 0, firmware can't supported virtio vSwitch offload model.
	 * By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_VIRTIO_VSWITCH_OFFLOAD_SUPPORTED \
		UINT32_C(0x80)
	/*
	 * If set to 1, firmware is capable to support trusted VF.
	 * If set to 0, firmware is not capable to support trusted VF.
	 * By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_TRUSTED_VF_SUPPORTED \
		UINT32_C(0x100)
	/*
	 * If set to 1, firmware is capable to support flow aging.
	 * If set to 0, firmware is not capable to support flow aging.
	 * By default, this flag should be 0 for older version of core firmware.
	 * (deprecated)
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_FLOW_AGING_SUPPORTED \
		UINT32_C(0x200)
	/*
	 * If set to 1, firmware is capable to support advanced flow counters like,
	 * Meter drop counters and EEM counters.
	 * If set to 0, firmware is not capable to support advanced flow counters.
	 * By default, this flag should be 0 for older version of core firmware.
	 * (deprecated)
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_ADV_FLOW_COUNTERS_SUPPORTED \
		UINT32_C(0x400)
	/*
	 * If set to 1, the firmware is able to support the use of the CFA
	 * Extended Exact Match(EEM) feature.
	 * If set to 0, firmware is not capable to support the use of the
	 * CFA EEM feature.
	 * By default, this flag should be 0 for older version of core firmware.
	 * (deprecated)
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_CFA_EEM_SUPPORTED \
		UINT32_C(0x800)
	/*
	 * If set to 1, the firmware is able to support advance CFA flow management
	 * features reported in the HWRM_CFA_FLOW_MGNT_QCAPS.
	 * If set to 0, then the firmware doesnt support the advance CFA flow management
	 * features.
	 * By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_CFA_ADV_FLOW_MGNT_SUPPORTED \
		UINT32_C(0x1000)
	/*
	 * Deprecated and replaced with cfa_truflow_supported.
	 * If set to 1, the firmware is able to support TFLIB features.
	 * If set to 0, then the firmware doesnt support TFLIB features.
	 * By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_CFA_TFLIB_SUPPORTED \
		UINT32_C(0x2000)
	/*
	 * If set to 1, the firmware is able to support TruFlow features.
	 * If set to 0, then the firmware doesnt support TruFlow features.
	 * By default, this flag should be 0 for older version of
	 * core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_CFA_TRUFLOW_SUPPORTED \
		UINT32_C(0x4000)
	/*
	 * If set to 1, then firmware supports secure boot.
	 * If set to 0, then firmware doesn't support secure boot.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_SECURE_BOOT_CAPABLE \
		UINT32_C(0x8000)
	/*
	 * This field represents the major version of RoCE firmware.
	 * A change in major version represents a major release.
	 */
	uint8_t	roce_fw_maj_8b;
	/*
	 * This field represents the minor version of RoCE firmware.
	 * A change in minor version represents significant
	 * functionality changes.
	 */
	uint8_t	roce_fw_min_8b;
	/*
	 * This field represents the build version of RoCE firmware.
	 * A change in update version represents bug fixes.
	 */
	uint8_t	roce_fw_bld_8b;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version
	 */
	uint8_t	roce_fw_rsvd_8b;
	/*
	 * This field represents the name of HWRM FW (ASCII chars
	 * with NULL at the end).
	 */
	char	hwrm_fw_name[16];
	/*
	 * This field represents the name of mgmt FW (ASCII chars
	 * with NULL at the end).
	 */
	char	mgmt_fw_name[16];
	/*
	 * This field represents the name of network control
	 * firmware (ASCII chars with NULL at the end).
	 */
	char	netctrl_fw_name[16];
	/* This field represents the active board package name. */
	char	active_pkg_name[16];
	/*
	 * This field represents the name of RoCE FW (ASCII chars
	 * with NULL at the end).
	 */
	char	roce_fw_name[16];
	/* This field returns the chip number. */
	uint16_t	chip_num;
	/* This field returns the revision of chip. */
	uint8_t	chip_rev;
	/* This field returns the chip metal number. */
	uint8_t	chip_metal;
	/* This field returns the bond id of the chip. */
	uint8_t	chip_bond_id;
	/* This value indicates the type of platform used for chip implementation. */
	uint8_t	chip_platform_type;
	/* ASIC */
	#define HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_ASIC      UINT32_C(0x0)
	/* FPGA platform of the chip. */
	#define HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_FPGA      UINT32_C(0x1)
	/* Palladium platform of the chip. */
	#define HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_PALLADIUM UINT32_C(0x2)
	#define HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_LAST \
		HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_PALLADIUM
	/*
	 * This field returns the maximum value of request window that
	 * is supported by the HWRM. The request window is mapped
	 * into device address space using MMIO.
	 */
	uint16_t	max_req_win_len;
	/*
	 * This field returns the maximum value of response buffer in
	 * bytes.
	 */
	uint16_t	max_resp_len;
	/*
	 * This field returns the default request timeout value in
	 * milliseconds.
	 */
	uint16_t	def_req_timeout;
	/*
	 * This field will indicate if any subsystems is not fully
	 * initialized.
	 */
	uint8_t	flags;
	/*
	 * If set to 1, it will indicate to host drivers that firmware is
	 * not ready to start full blown HWRM commands. Host drivers should
	 * re-try HWRM_VER_GET with some timeout period. The timeout period
	 * can be selected up to 5 seconds. Host drivers should also check
	 * for dev_not_rdy_backing_store to identify if flag is set due to
	 * backing store not been available.
	 * For Example, PCIe hot-plug:
	 *     Hot plug timing is system dependent. It generally takes up to
	 *     600 milliseconds for firmware to clear DEV_NOT_RDY flag.
	 * If set to 0, device is ready to accept all HWRM commands.
	 */
	#define HWRM_VER_GET_OUTPUT_FLAGS_DEV_NOT_RDY \
		UINT32_C(0x1)
	/*
	 * If set to 1, external version present.
	 * If set to 0, external version not present.
	 */
	#define HWRM_VER_GET_OUTPUT_FLAGS_EXT_VER_AVAIL \
		UINT32_C(0x2)
	/*
	 * Firmware sets this flag along with dev_not_rdy flag to indicate
	 * host drivers that it has not completed resource initialization
	 * required for data path operations. Host drivers should not send
	 * any HWRM command that requires data path resources. Firmware will
	 * fail those commands with HWRM_ERR_CODE_BUSY. Host drivers can retry
	 * those commands once both the flags are cleared.
	 * If this flag and dev_not_rdy flag are set to 0, device is ready
	 * to accept all HWRM commands.
	 */
	#define HWRM_VER_GET_OUTPUT_FLAGS_DEV_NOT_RDY_BACKING_STORE \
		UINT32_C(0x4)
	uint8_t	unused_0[2];
	/*
	 * For backward compatibility this field must be set to 1.
	 * Older drivers might look for this field to be 1 before
	 * processing the message.
	 */
	uint8_t	always_1;
	/*
	 * This field represents the major version of HWRM interface
	 * specification supported by the HWRM implementation.
	 * The interface major version is intended to change only when
	 * non backward compatible changes are made to the HWRM
	 * interface specification. A HWRM implementation that is
	 * compliant with this specification shall provide value of 1
	 * in this field.
	 */
	uint16_t	hwrm_intf_major;
	/*
	 * This field represents the minor version of HWRM interface
	 * specification supported by the HWRM implementation.
	 * A change in interface minor version is used to reflect
	 * significant backward compatible modification to HWRM
	 * interface specification. This can be due to addition or
	 * removal of functionality. HWRM interface specifications
	 * with the same major version but different minor versions are
	 * compatible. A HWRM implementation that is compliant with
	 * this specification shall provide value of 2 in this field.
	 */
	uint16_t	hwrm_intf_minor;
	/*
	 * This field represents the update version of HWRM interface
	 * specification supported by the HWRM implementation. The
	 * interface update version is used to reflect minor changes or
	 * bug fixes to a released HWRM interface specification.
	 * A HWRM implementation that is compliant with this
	 * specification shall provide value of 2 in this field.
	 */
	uint16_t	hwrm_intf_build;
	/*
	 * This field represents the patch version of HWRM interface
	 * specification supported by the HWRM implementation.
	 */
	uint16_t	hwrm_intf_patch;
	/*
	 * This field represents the major version of HWRM firmware.
	 * A change in firmware major version represents a major
	 * firmware release.
	 */
	uint16_t	hwrm_fw_major;
	/*
	 * This field represents the minor version of HWRM firmware.
	 * A change in firmware minor version represents significant
	 * firmware functionality changes.
	 */
	uint16_t	hwrm_fw_minor;
	/*
	 * This field represents the build version of HWRM firmware.
	 * A change in firmware build version represents bug fixes to
	 * a released firmware.
	 */
	uint16_t	hwrm_fw_build;
	/*
	 * This field is a reserved field.
	 * This field can be used to represent firmware branches or customer
	 * specific releases tied to a specific (major,minor,update) version
	 * of the HWRM firmware.
	 */
	uint16_t	hwrm_fw_patch;
	/*
	 * This field represents the major version of mgmt firmware.
	 * A change in major version represents a major release.
	 */
	uint16_t	mgmt_fw_major;
	/*
	 * This field represents the minor version of HWRM firmware.
	 * A change in firmware minor version represents significant
	 * firmware functionality changes.
	 */
	uint16_t	mgmt_fw_minor;
	/*
	 * This field represents the build version of mgmt firmware.
	 * A change in update version represents bug fixes.
	 */
	uint16_t	mgmt_fw_build;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version.
	 */
	uint16_t	mgmt_fw_patch;
	/*
	 * This field represents the major version of network control
	 * firmware. A change in major version represents
	 * a major release.
	 */
	uint16_t	netctrl_fw_major;
	/*
	 * This field represents the minor version of network control
	 * firmware. A change in minor version represents significant
	 * functionality changes.
	 */
	uint16_t	netctrl_fw_minor;
	/*
	 * This field represents the build version of network control
	 * firmware. A change in update version represents bug fixes.
	 */
	uint16_t	netctrl_fw_build;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version
	 */
	uint16_t	netctrl_fw_patch;
	/*
	 * This field represents the major version of RoCE firmware.
	 * A change in major version represents a major release.
	 */
	uint16_t	roce_fw_major;
	/*
	 * This field represents the minor version of RoCE firmware.
	 * A change in minor version represents significant
	 * functionality changes.
	 */
	uint16_t	roce_fw_minor;
	/*
	 * This field represents the build version of RoCE firmware.
	 * A change in update version represents bug fixes.
	 */
	uint16_t	roce_fw_build;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version
	 */
	uint16_t	roce_fw_patch;
	/*
	 * This field returns the maximum extended request length acceptable
	 * by the device which allows requests greater than mailbox size when
	 * used with the short cmd request format.
	 */
	uint16_t	max_ext_req_len;
	/*
	 * This field returns the maximum request timeout value in seconds.
	 * For backward compatibility, a value of zero should be interpreted
	 * as the default value of 40 seconds. Drivers should always honor the
	 * maximum timeout, but are permitted to warn if a longer duration than
	 * this default is advertised. Values larger than 40 seconds should
	 * only be used as a stopgap measure to address a device limitation or
	 * for the purposes of test and debugging. The long term goal is for
	 * firmware to significantly reduce this value in the passage of time.
	 */
	uint16_t	max_req_timeout;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* cfa_bds_read_cmd_data_msg (size:128b/16B) */
struct cfa_bds_read_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/*
	 * This is read command. From 32 to 128B can be read from a table
	 * using this command.
	 */
	#define CFA_BDS_READ_CMD_DATA_MSG_OPCODE_READ UINT32_C(0x0)
	#define CFA_BDS_READ_CMD_DATA_MSG_OPCODE_LAST \
		CFA_BDS_READ_CMD_DATA_MSG_OPCODE_READ
	/* This value selects the table type to be acted upon. */
	uint8_t	table_type;
	/* This value selects the table type to be acted upon. */
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_MASK  UINT32_C(0xf)
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_SFT   0
	/* This command acts on the action table of the specified scope. */
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_ACTION  UINT32_C(0x0)
	/* This command acts on the exact match table of the specified scope. */
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_EM      UINT32_C(0x1)
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_LAST \
		CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_EM
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed. A
	 * value of zero is invalid. Maximum value is 4.
	 */
	uint8_t	data_size;
	#define CFA_BDS_READ_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_READ_CMD_DATA_MSG_DATA_SIZE_SFT 0
	/* This is the 32B index into the selected table to access. */
	uint32_t	table_index;
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_INDEX_MASK UINT32_C(0x3ffffff)
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_INDEX_SFT 0
	/*
	 * This is the 64b host address where you want the data returned to. The
	 * data will be written to the same function as the one that owns the SQ
	 * this command is read from. The bottom two bits of this value must be
	 * zero. The size of the write is controlled by the data_size field.
	 */
	uint64_t	host_address;
} __rte_packed;

/* cfa_bds_write_cmd_data_msg (size:1152b/144B) */
struct cfa_bds_write_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/*
	 * This is write command. From 32 to 128B can be written to a table
	 * using this command.
	 */
	#define CFA_BDS_WRITE_CMD_DATA_MSG_OPCODE_WRITE UINT32_C(0x1)
	#define CFA_BDS_WRITE_CMD_DATA_MSG_OPCODE_LAST \
		CFA_BDS_WRITE_CMD_DATA_MSG_OPCODE_WRITE
	/* This value selects the table type to be acted upon. */
	uint8_t	write_thru_table_type;
	/* This value selects the table type to be acted upon. */
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_MASK  UINT32_C(0xf)
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_SFT   0
	/* This command acts on the action table of the specified scope. */
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_ACTION  UINT32_C(0x0)
	/* This command acts on the exact match table of the specified scope. */
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_EM      UINT32_C(0x1)
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_LAST \
		CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_EM
	/*
	 * Indicates write-through control. Indicates write-through when set,
	 * or write back when cleared.
	 */
	#define CFA_BDS_WRITE_CMD_DATA_MSG_WRITE_THRU       UINT32_C(0x10)
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed. A
	 * value of zero is invalid. Maximum value is 4.
	 */
	uint8_t	data_size;
	#define CFA_BDS_WRITE_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_WRITE_CMD_DATA_MSG_DATA_SIZE_SFT 0
	/* This is the 32B index into the selected table to access. */
	uint32_t	table_index;
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_INDEX_MASK UINT32_C(0x3ffffff)
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_INDEX_SFT 0
	uint32_t	unused0;
	uint32_t	unused1;
	/*
	 * This is the data to be written. Data length is determined by the
	 * data_size field. The bd_cnt in the encapsulating BD must also be set
	 * correctly to ensure that the BD is processed correctly and the full
	 * WRITE_CMD message is extracted from the BD.
	 */
	uint32_t	dta[32];
} __rte_packed;

/* cfa_bds_read_clr_cmd_data_msg (size:256b/32B) */
struct cfa_bds_read_clr_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/*
	 * This is read-clear command. 32B can be read from a table and
	 * a 16b mask can be used to clear specific 16b units after the
	 * read as an atomic operation.
	 */
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_OPCODE_READ_CLR UINT32_C(0x2)
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_OPCODE_LAST \
		CFA_BDS_READ_CLR_CMD_DATA_MSG_OPCODE_READ_CLR
	/* This value selects the table type to be acted upon. */
	uint8_t	table_type;
	/* This value selects the table type to be acted upon. */
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_MASK  UINT32_C(0xf)
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_SFT   0
	/* This command acts on the action table of the specified scope. */
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_ACTION  UINT32_C(0x0)
	/* This command acts on the exact match table of the specified scope. */
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_EM      UINT32_C(0x1)
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_LAST \
		CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_EM
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed.
	 * Always set the value to 1.
	 */
	uint8_t	data_size;
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_DATA_SIZE_SFT 0
	/* This is the 32B index into the selected table to access. */
	uint32_t	table_index;
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_INDEX_MASK \
		UINT32_C(0x3ffffff)
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_INDEX_SFT 0
	/*
	 * This is the 64b host address where you want the data returned to. The
	 * data will be written to the same function as the one that owns the SQ
	 * this command is read from. The bottom two bits of this value must be
	 * zero. The size of the write is controlled by the data_size field.
	 */
	uint64_t	host_address;
	/*
	 * This is active high clear mask for the 32B of data that this command
	 * can read. Bit 0 of the field will clear bits 15:0 of the first word
	 * of data read when set to '1'.
	 */
	uint16_t	clear_mask;
	uint16_t	unused0[3];
	uint16_t	unused1[4];
} __rte_packed;

/* cfa_bds_em_insert_cmd_data_msg (size:1152b/144B) */
struct cfa_bds_em_insert_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/*
	 * An exact match table insert will be attempted into the table.
	 * If there is a free location in the bucket, the payload will
	 * be written to the bucket.
	 */
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_OPCODE_EM_INSERT UINT32_C(0x3)
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_OPCODE_LAST \
		CFA_BDS_EM_INSERT_CMD_DATA_MSG_OPCODE_EM_INSERT
	/*
	 * Indicates write-through control. Indicates write-through when set,
	 * or write back when cleared.
	 */
	uint8_t	write_thru;
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_UNUSED_MASK    UINT32_C(0xf)
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_UNUSED_SFT     0
	/*
	 * Indicates write-through control. Indicates write-through when set,
	 * or write back when cleared.
	 */
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_WRITE_THRU     UINT32_C(0x10)
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed. A
	 * value of zero is invalid. Maximum value is 4.
	 */
	uint8_t	data_size;
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_DATA_SIZE_SFT 0
	/* This is the 32B index into the selected table to access. */
	uint32_t	table_index;
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_TABLE_INDEX_MASK \
		UINT32_C(0x3ffffff)
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_TABLE_INDEX_SFT 0
	/*
	 * This is the 64b host address where you want the data returned to. The
	 * data will be written to the same function as the one that owns the SQ
	 */
	uint64_t	host_address;
	/*
	 * This is the Exact Match Lookup Record. Data length is determined by
	 * the data_size field. The bd_cnt in the encapsulating BD must also be
	 */
	uint32_t	dta[32];
} __rte_packed;

/* cfa_bds_em_delete_cmd_data_msg (size:256b/32B) */
struct cfa_bds_em_delete_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/* An exact match table delete will be attempted. */
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_OPCODE_EM_DELETE UINT32_C(0x4)
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_OPCODE_LAST \
		CFA_BDS_EM_DELETE_CMD_DATA_MSG_OPCODE_EM_DELETE
	/*
	 * Indicates write-through control. Indicates write-through when set,
	 * or write back when cleared.
	 */
	uint8_t	write_thru;
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_UNUSED_MASK    UINT32_C(0xf)
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_UNUSED_SFT     0
	/*
	 * Indicates write-through control. Indicates write-through when set,
	 * or write back when cleared.
	 */
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_WRITE_THRU     UINT32_C(0x10)
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed. A
	 * value of zero is invalid. Maximum value is 4.
	 */
	uint8_t	data_size;
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_DATA_SIZE_SFT 0
	uint32_t	unused0;
	/*
	 * This is the 64b host address where you want the data returned to. The
	 * data will be written to the same function as the one that owns the SQ
	 */
	uint64_t	host_address;
	/*
	 * This is the Exact Match Lookup Record. Data length is determined by
	 * the data_size field. The bd_cnt in the encapsulating BD must also be
	 */
	uint64_t	dta;
	uint32_t	unused1[2];
} __rte_packed;

/* cfa_bds_invalidate_cmd_data_msg (size:128b/16B) */
struct cfa_bds_invalidate_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/*
	 * The specified table area will be invalidated. If it is needed.
	 * again, it will be read from the backing store.
	 */
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_OPCODE_INVALIDATE UINT32_C(0x5)
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_OPCODE_LAST \
		CFA_BDS_INVALIDATE_CMD_DATA_MSG_OPCODE_INVALIDATE
	/* This value selects the table type to be acted upon. */
	uint8_t	table_type;
	/* This value selects the table type to be acted upon. */
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_MASK  UINT32_C(0xf)
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_SFT   0
	/* This command acts on the action table of the specified scope. */
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_ACTION \
		UINT32_C(0x0)
	/* This command acts on the exact match table of the specified scope. */
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_EM \
		UINT32_C(0x1)
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_LAST \
		CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_EM
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/* This value specifies the number of cache lines to invalidate. */
	uint8_t	data_size;
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_DATA_SIZE_SFT 0
	/* This is the 32B index into the selected table to access. */
	uint32_t	table_index;
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_INDEX_MASK \
		UINT32_C(0x3ffffff)
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_INDEX_SFT 0
	uint32_t	unused[2];
} __rte_packed;

/* cfa_bds_event_collect_cmd_data_msg (size:128b/16B) */
struct cfa_bds_event_collect_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/* Reads notification messages from the Host Notification Queue. */
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_OPCODE_EVENT_COLLECT \
		UINT32_C(0x6)
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_OPCODE_LAST \
		CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_OPCODE_EVENT_COLLECT
	uint8_t	unused0;
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_TABLE_SCOPE_MASK \
		UINT32_C(0x1f)
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed. A
	 * value of zero is invalid. Maximum value is 4.
	 */
	uint8_t	data_size;
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_DATA_SIZE_SFT 0
	uint32_t	unused1;
	/*
	 * This is the 64b host address where you want the data returned to. The
	 * data will be written to the same function as the one that owns the SQ
	 */
	uint64_t	host_address;
} __rte_packed;

/* ce_bds_add_data_msg (size:576b/72B) */
struct ce_bds_add_data_msg {
	uint32_t	version_algorithm_kid_opcode;
	/*
	 * This value selects the operation for the mid-path command for the
	 * crypto blocks.
	 */
	#define CE_BDS_ADD_DATA_MSG_OPCODE_MASK               UINT32_C(0xf)
	#define CE_BDS_ADD_DATA_MSG_OPCODE_SFT                0
	/*
	 * This is the add command. Using this opcode, Host Driver can add
	 * information required for kTLS processing. The information is
	 * updated in the CFCK context.
	 */
	#define CE_BDS_ADD_DATA_MSG_OPCODE_ADD                  UINT32_C(0x1)
	#define CE_BDS_ADD_DATA_MSG_OPCODE_LAST \
		CE_BDS_ADD_DATA_MSG_OPCODE_ADD
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated kTLS offloaded connection.
	 */
	#define CE_BDS_ADD_DATA_MSG_KID_MASK \
		UINT32_C(0xfffff0)
	#define CE_BDS_ADD_DATA_MSG_KID_SFT                   4
	/*
	 * Currently only two algorithms are supported, AES_GCM_128 and
	 * AES_GCM_256. Additional bits for future growth.
	 */
	#define CE_BDS_ADD_DATA_MSG_ALGORITHM_MASK \
		UINT32_C(0xf000000)
	#define CE_BDS_ADD_DATA_MSG_ALGORITHM_SFT             24
	/* AES_GCM_128 Algorithm */
	#define CE_BDS_ADD_DATA_MSG_ALGORITHM_AES_GCM_128 \
		UINT32_C(0x1000000)
	/* AES_GCM_256 Algorithm */
	#define CE_BDS_ADD_DATA_MSG_ALGORITHM_AES_GCM_256 \
		UINT32_C(0x2000000)
	/*
	 * Version number of TLS connection. HW will provide registers that
	 * converts the 4b encoded version number to 16b of actual version
	 * number in the TLS Header. This field is initialized/updated by
	 * this "KTLS crypto add" mid-path command.
	 */
	#define CE_BDS_ADD_DATA_MSG_VERSION_MASK \
		UINT32_C(0xf0000000)
	#define CE_BDS_ADD_DATA_MSG_VERSION_SFT               28
	/* TLS1.2 Version */
	#define CE_BDS_ADD_DATA_MSG__TLS1_2 \
		(UINT32_C(0x0) << 28)
	/* TLS1.3 Version */
	#define CE_BDS_ADD_DATA_MSG__TLS1_3 \
		(UINT32_C(0x1) << 28)
	#define CE_BDS_ADD_DATA_MSG__LAST \
		CE_BDS_ADD_DATA_MSG__TLS1_3
	uint8_t	ctx_kind;
	/* This field selects the context kind for the request. */
	#define CE_BDS_ADD_DATA_MSG_CTX_KIND_MASK UINT32_C(0x1f)
	#define CE_BDS_ADD_DATA_MSG_CTX_KIND_SFT  0
	/* Crypto key transmit context */
	#define CE_BDS_ADD_DATA_MSG_CTX_KIND_CK_TX  UINT32_C(0x11)
	/* Crypto key receive context */
	#define CE_BDS_ADD_DATA_MSG_CTX_KIND_CK_RX  UINT32_C(0x12)
	#define CE_BDS_ADD_DATA_MSG_CTX_KIND_LAST \
		CE_BDS_ADD_DATA_MSG_CTX_KIND_CK_RX
	uint8_t	unused0[3];
	/*
	 * Salt is part of the nonce that is used as the Initial Vector (IV) in
	 * AES-GCM cipher suites. These are exchanged as part of the handshake
	 * process and is either the client_write_iv (when the client is
	 * sending) or server_write_iv (when the server is sending). In
	 * TLS1.2, 4B of Salt is concatenated with 8B of explicit_nonce to
	 * generate the 12B of IV. In TLS1.3, 8B of TLS record sequence number
	 * is zero padded to 12B and then xor'ed with the 4B of salt to generate
	 * the 12B of IV. This value is initialized by this mid-path command.
	 */
	uint8_t	salt[4];
	uint8_t	unused1[4];
	/*
	 * This field keeps track of the TCP sequence number that is expected as
	 * the first byte in the next TCP packet. This field is calculated by HW
	 * using the output of the parser. The field is initialized as part of
	 * the Mid-path BD download/update of a kTLS connection. For every TCP
	 * packet processed, TCE HW will update the value to Current packet TCP
	 * sequence number + Current packet TCP Payload Length.
	 */
	uint32_t	pkt_tcp_seq_num;
	/*
	 * This field maintains the TCP sequence number of the first byte in the
	 * header of the active TLS record. This field is initialized as part of
	 * the Mid-path BD download/update of a kTLS connection. For every
	 * record that is processed, TCE HW copies the value from the
	 * next_tls_header_tcp_seq_num field.
	 */
	uint32_t	tls_header_tcp_seq_num;
	/*
	 * This is sequence number for the TLS record in a particular session.
	 * In TLS1.2, record sequence number is part of the Associated Data (AD)
	 * in the AEAD algorithm. In TLS1.3, record sequence number is part of
	 * the Initial Vector (IV). The field is initialized as part of the
	 * mid-path BD download/update of a kTLS connection. TCE HW increments
	 * the field after that for every record processed as it parses the TCP
	 * packet.
	 */
	uint64_t	record_seq_num;
	/*
	 * Key used for encrypting or decrypting TLS records. The Key is
	 * exchanged during the hand-shake protocol by the client-server and
	 * provided to HW through this mid-path BD.
	 */
	uint8_t	session_key[32];
	/*
	 * Additional IV that is exchanged as part of sessions setup between
	 * the two end points. This field is used for TLS1.3 only.
	 */
	uint8_t	addl_iv[8];
} __rte_packed;

/* ce_bds_delete_data_msg (size:32b/4B) */
struct ce_bds_delete_data_msg {
	uint32_t	kid_opcode_ctx_kind;
	/*
	 * This value selects the operation for the mid-path command for the
	 * crypto blocks.
	 */
	#define CE_BDS_DELETE_DATA_MSG_OPCODE_MASK     UINT32_C(0xf)
	#define CE_BDS_DELETE_DATA_MSG_OPCODE_SFT      0
	/*
	 * This is the delete command. Using this opcode, the host Driver
	 * can remove a key context from the CFCK. If context is deleted
	 * and packets with the same KID come through the pipeline, the
	 * following actions are taken. For transmit packets, no crypto
	 * operation will be performed, payload will be zero'ed out. For
	 * receive packets, no crypto operation will be performed,
	 * payload will be unmodified.
	 */
	#define CE_BDS_DELETE_DATA_MSG_OPCODE_DELETE     UINT32_C(0x2)
	#define CE_BDS_DELETE_DATA_MSG_OPCODE_LAST \
		CE_BDS_DELETE_DATA_MSG_OPCODE_DELETE
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated kTLS offloaded connection.
	 */
	#define CE_BDS_DELETE_DATA_MSG_KID_MASK        UINT32_C(0xfffff0)
	#define CE_BDS_DELETE_DATA_MSG_KID_SFT         4
	/* This field selects the context kind for the request. */
	#define CE_BDS_DELETE_DATA_MSG_CTX_KIND_MASK   UINT32_C(0x1f000000)
	#define CE_BDS_DELETE_DATA_MSG_CTX_KIND_SFT    24
	/* Crypto Key Transmit Context. */
	#define CE_BDS_DELETE_DATA_MSG_CTX_KIND_CK_TX    (UINT32_C(0x11) << 24)
	/* Crypto Key Receive Context. */
	#define CE_BDS_DELETE_DATA_MSG_CTX_KIND_CK_RX    (UINT32_C(0x12) << 24)
	/* QUIC Key Transmit Context. */
	#define CE_BDS_DELETE_DATA_MSG_CTX_KIND_QUIC_TX  (UINT32_C(0x14) << 24)
	/* QUIC Key Receive Context. */
	#define CE_BDS_DELETE_DATA_MSG_CTX_KIND_QUIC_RX  (UINT32_C(0x15) << 24)
	#define CE_BDS_DELETE_DATA_MSG_CTX_KIND_LAST \
		CE_BDS_DELETE_DATA_MSG_CTX_KIND_QUIC_RX
} __rte_packed;

/* ce_bds_resync_resp_ack_msg (size:128b/16B) */
struct ce_bds_resync_resp_ack_msg {
	uint32_t	resync_status_kid_opcode;
	/*
	 * This value selects the operation for the mid-path command for the
	 * crypto blocks.
	 */
	#define CE_BDS_RESYNC_RESP_ACK_MSG_OPCODE_MASK       UINT32_C(0xf)
	#define CE_BDS_RESYNC_RESP_ACK_MSG_OPCODE_SFT        0
	/*
	 * This command is used by the driver as a response to the resync
	 * request sent by the crypto engine.
	 */
	#define CE_BDS_RESYNC_RESP_ACK_MSG_OPCODE_RESYNC       UINT32_C(0x3)
	#define CE_BDS_RESYNC_RESP_ACK_MSG_OPCODE_LAST \
		CE_BDS_RESYNC_RESP_ACK_MSG_OPCODE_RESYNC
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated kTLS offloaded connection.
	 */
	#define CE_BDS_RESYNC_RESP_ACK_MSG_KID_MASK          UINT32_C(0xfffff0)
	#define CE_BDS_RESYNC_RESP_ACK_MSG_KID_SFT           4
	/*
	 * This field indicates if the resync request resulted in a success or
	 * a failure.
	 */
	#define CE_BDS_RESYNC_RESP_ACK_MSG_RESYNC_STATUS \
		UINT32_C(0x1000000)
	/*
	 * An ACK indicates that the driver was able to find the TLS record
	 * associated with TCP sequence number provided by the HW
	 */
	#define CE_BDS_RESYNC_RESP_ACK_MSG_RESYNC_STATUS_ACK \
		(UINT32_C(0x0) << 24)
	#define CE_BDS_RESYNC_RESP_ACK_MSG_RESYNC_STATUS_LAST \
		CE_BDS_RESYNC_RESP_ACK_MSG_RESYNC_STATUS_ACK
	/*
	 * This field is the echo of the TCP sequence number provided in the
	 * resync request by the HW. If HW sent multiple resync requests, it
	 * only tracks the latest TCP sequence number. When the response from
	 * the Driver doesn't match the latest request, HW will drop the resync
	 * response.
	 */
	uint32_t	resync_record_tcp_seq_num;
	/*
	 * This field indicates the TLS record sequence number associated with
	 * the resync request. HW will take this number and add the delta records
	 * it has found since sending the resync request, update the context and
	 * resume decrypting records.
	 */
	uint64_t	resync_record_seq_num;
} __rte_packed;

/* ce_bds_resync_resp_nack_msg (size:64b/8B) */
struct ce_bds_resync_resp_nack_msg {
	uint32_t	resync_status_kid_opcode;
	/*
	 * This value selects the operation for the mid-path command for the
	 * crypto blocks.
	 */
	#define CE_BDS_RESYNC_RESP_NACK_MSG_OPCODE_MASK       UINT32_C(0xf)
	#define CE_BDS_RESYNC_RESP_NACK_MSG_OPCODE_SFT        0
	/*
	 * This command is used by the driver as a response to the resync
	 * request sent by the crypto engine.
	 */
	#define CE_BDS_RESYNC_RESP_NACK_MSG_OPCODE_RESYNC       UINT32_C(0x3)
	#define CE_BDS_RESYNC_RESP_NACK_MSG_OPCODE_LAST \
		CE_BDS_RESYNC_RESP_NACK_MSG_OPCODE_RESYNC
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated kTLS offloaded connection.
	 */
	#define CE_BDS_RESYNC_RESP_NACK_MSG_KID_MASK \
		UINT32_C(0xfffff0)
	#define CE_BDS_RESYNC_RESP_NACK_MSG_KID_SFT           4
	/*
	 * This field indicates if the resync request resulted in a success or
	 * a failure.
	 */
	#define CE_BDS_RESYNC_RESP_NACK_MSG_RESYNC_STATUS \
		UINT32_C(0x1000000)
	/*
	 * An NAK indicates that the driver wasn't able to find the TLS
	 * record associated with TCP sequence number provided by the HW
	 */
	#define CE_BDS_RESYNC_RESP_NACK_MSG_RESYNC_STATUS_NACK \
		(UINT32_C(0x1) << 24)
	#define CE_BDS_RESYNC_RESP_NACK_MSG_RESYNC_STATUS_LAST \
		CE_BDS_RESYNC_RESP_NACK_MSG_RESYNC_STATUS_NACK
	/*
	 * This field is the echo of the TCP sequence number provided in the
	 * resync request by the HW. If HW sent multiple resync requests, it
	 * only tracks the latest TCP sequence number. When the response from
	 * the Driver doesn't match the latest request, HW will drop the resync
	 * response.
	 */
	uint32_t	resync_record_tcp_seq_num;
} __rte_packed;

/* crypto_presync_bd_cmd (size:256b/32B) */
struct crypto_presync_bd_cmd {
	uint8_t	flags;
	/*
	 * Typically, presync BDs are used for packet retransmissions. Source
	 * port sends all the packets in order over the network to destination
	 * port and packets get dropped in the network. The destination port
	 * will request retranmission of dropped packets and source port driver
	 * will send presync BD to setup the transmitter appropriately. It will
	 * provide the start and end TCP sequence number of the data to be
	 * transmitted. HW keeps two sets of context variable, one for in order
	 * traffic and one for retransmission traffic. HW is designed to
	 * transmit everything posted in the presync BD and return to in order
	 * mode after that. No inorder context variables are updated in the
	 * process. There is a special case where packets can be dropped
	 * between the TCP stack and Device Driver (Berkeley Packet Filter for
	 * ex) and HW still needs to transmit rest of the traffic. In this
	 * mode, driver will send a presync BD as if it is a retransmission but
	 * at the end of the transmission, the in order variables need to be
	 * updated. This flag is used by driver to indicate that in order
	 * variables needs to be updated at the end of completing the task
	 * associated with the presync BD.
	 */
	#define CRYPTO_PRESYNC_BD_CMD_FLAGS_UPDATE_IN_ORDER_VAR \
		UINT32_C(0x1)
	/*
	 * When packet with an authentication TAG is lost in the network,
	 * During retransmission Device driver will post the entire record for
	 * the hardware to recalculate the TAG. Hardware is set to retransmit
	 * only portions of the record, it does so by looking at the Header
	 * TCP Sequence Number and Start TCP Sequence Number. However, there
	 * is a case where the header packet gets dropped in the stack for ex
	 * BPF packet filter and it is impossible for the Hardware to
	 * determine if this is a case of full replay for only the TAG
	 * generation.
	 */
	#define CRYPTO_PRESYNC_BD_CMD_FLAGS_FULL_REPLAY_RETRAN \
		UINT32_C(0x2)
	uint8_t	unused0;
	uint16_t	unused1;
	/*
	 * This field maintains the TCP sequence number of the first byte in the
	 * Header of the active TLS record. This field is set to 0 during
	 * mid-path BD updates, but is set to correct value when a presync BD is
	 * detected. For every record that is processed, the value from the
	 * next_tls_header_tcp_seq_num field is copied.
	 */
	uint32_t	header_tcp_seq_num;
	/*
	 * When a retransmitted packet has a TLS authentication TAG present and
	 * the data spans multiple TCP Packets, HW is required to read the entire
	 * record to recalculate the TAG but only transmit what is required. This
	 * field is the start TCP sequence number of the packet(s) that need to
	 * be re-transmitted. This field is initialized to 0 during Mid-path BD
	 * add command and initialized to value provided by the driver when
	 * Pre-sync BD is detected. This field is never updated unless another
	 * Pre-sync BD signaling a new retransmission is scheduled.
	 */
	uint32_t	start_tcp_seq_num;
	/*
	 * When a retransmitted packet has a TLS authentication TAG present and
	 * the data spans multiple TCP Packets, HW is required to read the
	 * entire record to recalculate the TAG but only transmit what is
	 * required. This field is the end TCP sequence number of the packet(s)
	 * that need to be re-transmitted. This field is initialized to 0 during
	 * Mid-path BD add command and initialized to value provided by the
	 * driver when Pre-sync BD is detected. This field is never updated
	 * unless another Pre-sync BD signaling a new retransmission is
	 * scheduled.
	 */
	uint32_t	end_tcp_seq_num;
	/*
	 * For TLS1.2, an explicit nonce is used as part of the IV (concatenated
	 * with the SALT). For retrans packets, this field is extracted from the
	 * TLS record, field right after the TLS Header and stored in the
	 * context. This field needs to be stored in context as TCP segmentation
	 * could have split the field into multiple TCP packets. This value is
	 * initialized to 0 when presync BD is detected by taking the value from
	 * the first TLS header. When subsequent TLS Headers are detected, the
	 * value is extracted from packet.
	 */
	uint8_t	explicit_nonce[8];
	/*
	 * This is sequence number for the TLS record in a particular session. In
	 * TLS1.2, record sequence number is part of the Associated Data (AD) in
	 * the AEAD algorithm. In TLS1.3, record sequence number is part of the
	 * Initial Vector (IV). The field is initialized to 0 during Mid-path BD
	 * download. Is initialized to correct value when a pre-sync BD is
	 * detected. TCE HW increments the field after that for every record
	 * processed as it parses the TCP packet. Subsequent pre-sync BDs
	 * delivering more retransmission instruction will also update this
	 * field.
	 */
	uint64_t	record_seq_num;
} __rte_packed;

/* ce_bds_quic_add_data_msg (size:832b/104B) */
struct ce_bds_quic_add_data_msg {
	uint32_t	ver_algo_kid_opcode;
	/*
	 * This value selects the operation for the mid-path command for the
	 * crypto blocks.
	 */
	#define CE_BDS_QUIC_ADD_DATA_MSG_OPCODE_MASK          UINT32_C(0xf)
	#define CE_BDS_QUIC_ADD_DATA_MSG_OPCODE_SFT           0
	/*
	 * This is the add command. Using this opcode, Host Driver can add
	 * information required for QUIC processing. The information is
	 * updated in the CFCK context.
	 */
	#define CE_BDS_QUIC_ADD_DATA_MSG_OPCODE_ADD             UINT32_C(0x1)
	#define CE_BDS_QUIC_ADD_DATA_MSG_OPCODE_LAST \
		CE_BDS_QUIC_ADD_DATA_MSG_OPCODE_ADD
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated QUIC offloaded connection.
	 */
	#define CE_BDS_QUIC_ADD_DATA_MSG_KID_MASK \
		UINT32_C(0xfffff0)
	#define CE_BDS_QUIC_ADD_DATA_MSG_KID_SFT              4
	/* Algorithm used for encryption and decryption. */
	#define CE_BDS_QUIC_ADD_DATA_MSG_ALGORITHM_MASK \
		UINT32_C(0xf000000)
	#define CE_BDS_QUIC_ADD_DATA_MSG_ALGORITHM_SFT        24
	/* AES_GCM_128 Algorithm. */
	#define CE_BDS_QUIC_ADD_DATA_MSG_ALGORITHM_AES_GCM_128 \
		(UINT32_C(0x1) << 24)
	/* AES_GCM_256 Algorithm. */
	#define CE_BDS_QUIC_ADD_DATA_MSG_ALGORITHM_AES_GCM_256 \
		(UINT32_C(0x2) << 24)
	/* Chacha20 Algorithm. */
	#define CE_BDS_QUIC_ADD_DATA_MSG_ALGORITHM_CHACHA20 \
		(UINT32_C(0x3) << 24)
	#define CE_BDS_QUIC_ADD_DATA_MSG_ALGORITHM_LAST \
		CE_BDS_QUIC_ADD_DATA_MSG_ALGORITHM_CHACHA20
	/* Version number of QUIC connection. */
	#define CE_BDS_QUIC_ADD_DATA_MSG_VERSION_MASK \
		UINT32_C(0xf0000000)
	#define CE_BDS_QUIC_ADD_DATA_MSG_VERSION_SFT          28
	/* TLS1.2 Version */
	#define CE_BDS_QUIC_ADD_DATA_MSG__TLS1_2 \
		(UINT32_C(0x0) << 28)
	/* TLS1.3 Version */
	#define CE_BDS_QUIC_ADD_DATA_MSG__TLS1_3 \
		(UINT32_C(0x1) << 28)
	/* DTLS1.2 Version */
	#define CE_BDS_QUIC_ADD_DATA_MSG__DTLS1_2 \
		(UINT32_C(0x2) << 28)
	/* DTLS1.2 for RoCE Version */
	#define CE_BDS_QUIC_ADD_DATA_MSG__DTLS1_2_ROCE \
		(UINT32_C(0x3) << 28)
	/* QUIC Version */
	#define CE_BDS_QUIC_ADD_DATA_MSG__QUIC \
		(UINT32_C(0x4) << 28)
	#define CE_BDS_QUIC_ADD_DATA_MSG__LAST \
		CE_BDS_QUIC_ADD_DATA_MSG__QUIC
	uint32_t	ctx_kind_dcid_width_key_phase;
	/* Key phase. */
	#define CE_BDS_QUIC_ADD_DATA_MSG_KEY_PHASE       UINT32_C(0x1)
	/* Destination connection ID width. */
	#define CE_BDS_QUIC_ADD_DATA_MSG_DCID_WIDTH_MASK UINT32_C(0x3e)
	#define CE_BDS_QUIC_ADD_DATA_MSG_DCID_WIDTH_SFT  1
	/* This field selects the context kind for the request. */
	#define CE_BDS_QUIC_ADD_DATA_MSG_CTX_KIND_MASK   UINT32_C(0x7c0)
	#define CE_BDS_QUIC_ADD_DATA_MSG_CTX_KIND_SFT    6
	/* QUIC key transmit context */
	#define CE_BDS_QUIC_ADD_DATA_MSG_CTX_KIND_QUIC_TX \
		(UINT32_C(0x14) << 6)
	/* QUIC key receive context */
	#define CE_BDS_QUIC_ADD_DATA_MSG_CTX_KIND_QUIC_RX \
		(UINT32_C(0x15) << 6)
	#define CE_BDS_QUIC_ADD_DATA_MSG_CTX_KIND_LAST \
		CE_BDS_QUIC_ADD_DATA_MSG_CTX_KIND_QUIC_RX
	uint32_t	unused_0[2];
	/*
	 * Least-significant 64 bits (of 96) of additional IV that is
	 * exchanged as part of sessions setup between the two end
	 * points for QUIC operations.
	 */
	uint64_t	quic_iv_lo;
	/*
	 * Most-significant 32 bits (of 96) of additional IV that is
	 * exchanged as part of sessions setup between the two end
	 * points for QUIC operations.
	 */
	uint32_t	quic_iv_hi;
	uint32_t	unused_1;
	/*
	 * Key used for encrypting or decrypting records. The Key is exchanged
	 * as part of sessions setup between the two end points through this
	 * mid-path BD.
	 */
	uint32_t	session_key[8];
	/* Header protection key. */
	uint32_t	hp_key[8];
	/* Packet number associated with the QUIC connection. */
	uint64_t	pkt_number;
} __rte_packed;

/* bd_base (size:64b/8B) */
struct bd_base {
	uint8_t	type;
	/* This value identifies the type of buffer descriptor. */
	#define BD_BASE_TYPE_MASK             UINT32_C(0x3f)
	#define BD_BASE_TYPE_SFT              0
	/*
	 * Indicates that this BD is 16B long and is used for
	 * normal L2 packet transmission.
	 */
	#define BD_BASE_TYPE_TX_BD_SHORT        UINT32_C(0x0)
	/*
	 * Indicates that this BD is 1BB long and is an empty
	 * TX BD. Not valid for use by the driver.
	 */
	#define BD_BASE_TYPE_TX_BD_EMPTY        UINT32_C(0x1)
	/*
	 * Indicates that this BD is 16B long and is an RX Producer
	 * (i.e. empty) buffer descriptor.
	 */
	#define BD_BASE_TYPE_RX_PROD_PKT        UINT32_C(0x4)
	/*
	 * Indicates that this BD is 16B long and is an RX
	 * Producer Buffer BD.
	 */
	#define BD_BASE_TYPE_RX_PROD_BFR        UINT32_C(0x5)
	/*
	 * Indicates that this BD is 16B long and is an
	 * RX Producer Assembly Buffer Descriptor.
	 */
	#define BD_BASE_TYPE_RX_PROD_AGG        UINT32_C(0x6)
	/*
	 * Indicates that this BD is used to issue a command to one of
	 * the mid-path destinations.
	 */
	#define BD_BASE_TYPE_TX_BD_MP_CMD       UINT32_C(0x8)
	/*
	 * Indicates that this BD is used to issue a cryptographic pre-
	 * sync command through the fast path and destined for TCE.
	 */
	#define BD_BASE_TYPE_TX_BD_PRESYNC_CMD  UINT32_C(0x9)
	/*
	 * Indicates a timed transmit BD. This is a 16b BD that is inserted
	 * into a packet BD chain immediately after the first BD. It is used
	 * to control the flow in a timed transmit operation.
	 */
	#define BD_BASE_TYPE_TX_BD_TIMEDTX      UINT32_C(0xa)
	/*
	 * Indicates that this BD is 32B long and is used for
	 * normal L2 packet transmission.
	 */
	#define BD_BASE_TYPE_TX_BD_LONG         UINT32_C(0x10)
	/*
	 * Indicates that this BD is 32B long and is used for
	 * L2 packet transmission for small packets that require
	 * low latency.
	 */
	#define BD_BASE_TYPE_TX_BD_LONG_INLINE  UINT32_C(0x11)
	#define BD_BASE_TYPE_LAST              BD_BASE_TYPE_TX_BD_LONG_INLINE
	uint8_t	unused_1[7];
} __rte_packed;

/* tx_bd_short (size:128b/16B) */
struct tx_bd_short {
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Only the packet_end bit must be valid for the remaining BDs
	 * of a packet.
	 */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define TX_BD_SHORT_TYPE_MASK            UINT32_C(0x3f)
	#define TX_BD_SHORT_TYPE_SFT             0
	/*
	 * Indicates that this BD is 16B long and is used for
	 * normal L2 packet transmission.
	 */
	#define TX_BD_SHORT_TYPE_TX_BD_SHORT       UINT32_C(0x0)
	#define TX_BD_SHORT_TYPE_LAST             TX_BD_SHORT_TYPE_TX_BD_SHORT
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Only the packet_end bit must be valid for the remaining BDs
	 * of a packet.
	 */
	#define TX_BD_SHORT_FLAGS_MASK           UINT32_C(0xffc0)
	#define TX_BD_SHORT_FLAGS_SFT            6
	/*
	 * If set to 1, the packet ends with the data in the buffer
	 * pointed to by this descriptor. This flag must be
	 * valid on every BD.
	 */
	#define TX_BD_SHORT_FLAGS_PACKET_END      UINT32_C(0x40)
	/*
	 * If set to 1, the device will not generate a completion for
	 * this transmit packet unless there is an error in it's
	 * processing.
	 * If this bit
	 * is set to 0, then the packet will be completed normally.
	 *
	 * This bit must be valid only on the first BD of a packet.
	 */
	#define TX_BD_SHORT_FLAGS_NO_CMPL         UINT32_C(0x80)
	/*
	 * This value indicates how many 16B BD locations are consumed
	 * in the ring by this packet.
	 * A value of 1 indicates that this BD is the only BD (and that
	 * it is a short BD). A value
	 * of 3 indicates either 3 short BDs or 1 long BD and one short
	 * BD in the packet. A value of 0 indicates
	 * that there are 32 BD locations in the packet (the maximum).
	 *
	 * This field is valid only on the first BD of a packet.
	 */
	#define TX_BD_SHORT_FLAGS_BD_CNT_MASK     UINT32_C(0x1f00)
	#define TX_BD_SHORT_FLAGS_BD_CNT_SFT      8
	/*
	 * This value is a hint for the length of the entire packet.
	 * It is used by the chip to optimize internal processing.
	 *
	 * The packet will be dropped if the hint is too short.
	 *
	 * This field is valid only on the first BD of a packet.
	 */
	#define TX_BD_SHORT_FLAGS_LHINT_MASK      UINT32_C(0x6000)
	#define TX_BD_SHORT_FLAGS_LHINT_SFT       13
	/* indicates packet length < 512B */
	#define TX_BD_SHORT_FLAGS_LHINT_LT512       (UINT32_C(0x0) << 13)
	/* indicates 512 <= packet length < 1KB */
	#define TX_BD_SHORT_FLAGS_LHINT_LT1K        (UINT32_C(0x1) << 13)
	/* indicates 1KB <= packet length < 2KB */
	#define TX_BD_SHORT_FLAGS_LHINT_LT2K        (UINT32_C(0x2) << 13)
	/* indicates packet length >= 2KB */
	#define TX_BD_SHORT_FLAGS_LHINT_GTE2K       (UINT32_C(0x3) << 13)
	#define TX_BD_SHORT_FLAGS_LHINT_LAST \
		TX_BD_SHORT_FLAGS_LHINT_GTE2K
	/*
	 * If set to 1, the device immediately updates the Send Consumer
	 * Index after the buffer associated with this descriptor has
	 * been transferred via DMA to NIC memory from host memory. An
	 * interrupt may or may not be generated according to the state
	 * of the interrupt avoidance mechanisms. If this bit
	 * is set to 0, then the Consumer Index is only updated as soon
	 * as one of the host interrupt coalescing conditions has been met.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_SHORT_FLAGS_COAL_NOW        UINT32_C(0x8000)
	/*
	 * This is the length of the host physical buffer this BD describes
	 * in bytes.
	 *
	 * This field must be valid on all BDs of a packet.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to the completion and can be
	 * used for any data that the driver wants to associate with the
	 * transmit BD.
	 *
	 * This field must be valid on the first BD of a packet. If completion
	 * coalescing is enabled on the TX ring, it is suggested that the driver
	 * populate the opaque field to indicate the specific TX ring with which
	 * the completion is associated, then utilize the opaque and sq_cons_idx
	 * fields in the coalesced completion record to determine the specific
	 * packets that are to be completed on that ring.
	 */
	uint32_t	opaque;
	/*
	 * This is the host physical address for the portion of the packet
	 * described by this TX BD.
	 *
	 * This value must be valid on all BDs of a packet.
	 */
	uint64_t	address;
} __rte_packed;

/* tx_bd_long (size:128b/16B) */
struct tx_bd_long {
	/* This value identifies the type of buffer descriptor. */
	uint16_t	flags_type;
	/*
	 * This value indicates the type of buffer descriptor.
	 * packet.
	 */
	#define TX_BD_LONG_TYPE_MASK            UINT32_C(0x3f)
	#define TX_BD_LONG_TYPE_SFT             0
	/*
	 * Indicates that this BD is 32B long and is used for
	 * normal L2 packet transmission.
	 */
	#define TX_BD_LONG_TYPE_TX_BD_LONG        UINT32_C(0x10)
	#define TX_BD_LONG_TYPE_LAST             TX_BD_LONG_TYPE_TX_BD_LONG
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Only the packet_end bit must be valid for the remaining BDs
	 * of a packet.
	 */
	#define TX_BD_LONG_FLAGS_MASK           UINT32_C(0xffc0)
	#define TX_BD_LONG_FLAGS_SFT            6
	/*
	 * If set to 1, the packet ends with the data in the buffer
	 * pointed to by this descriptor. This flag must be
	 * valid on every BD.
	 */
	#define TX_BD_LONG_FLAGS_PACKET_END      UINT32_C(0x40)
	/*
	 * If set to 1, the device will not generate a completion for
	 * this transmit packet unless there is an error in it's
	 * processing.
	 * If this bit
	 * is set to 0, then the packet will be completed normally.
	 *
	 * This bit must be valid only on the first BD of a packet.
	 */
	#define TX_BD_LONG_FLAGS_NO_CMPL         UINT32_C(0x80)
	/*
	 * This value indicates how many 16B BD locations are consumed
	 * in the ring by this packet.
	 * A value of 1 indicates that this BD is the only BD (and that
	 * it is a short BD). A value
	 * of 3 indicates either 3 short BDs or 1 long BD and one short
	 * BD in the packet. A value of 0 indicates
	 * that there are 32 BD locations in the packet (the maximum).
	 *
	 * This field is valid only on the first BD of a packet.
	 */
	#define TX_BD_LONG_FLAGS_BD_CNT_MASK     UINT32_C(0x1f00)
	#define TX_BD_LONG_FLAGS_BD_CNT_SFT      8
	/*
	 * This value is a hint for the length of the entire packet.
	 * It is used by the chip to optimize internal processing.
	 *
	 * The packet will be dropped if the hint is too short.
	 *
	 * This field is valid only on the first BD of a packet.
	 */
	#define TX_BD_LONG_FLAGS_LHINT_MASK      UINT32_C(0x6000)
	#define TX_BD_LONG_FLAGS_LHINT_SFT       13
	/* indicates packet length < 512B */
	#define TX_BD_LONG_FLAGS_LHINT_LT512       (UINT32_C(0x0) << 13)
	/* indicates 512 <= packet length < 1KB */
	#define TX_BD_LONG_FLAGS_LHINT_LT1K        (UINT32_C(0x1) << 13)
	/* indicates 1KB <= packet length < 2KB */
	#define TX_BD_LONG_FLAGS_LHINT_LT2K        (UINT32_C(0x2) << 13)
	/* indicates packet length >= 2KB */
	#define TX_BD_LONG_FLAGS_LHINT_GTE2K       (UINT32_C(0x3) << 13)
	#define TX_BD_LONG_FLAGS_LHINT_LAST       TX_BD_LONG_FLAGS_LHINT_GTE2K
	/*
	 * If set to 1, the device immediately updates the Send Consumer
	 * Index after the buffer associated with this descriptor has
	 * been transferred via DMA to NIC memory from host memory. An
	 * interrupt may or may not be generated according to the state
	 * of the interrupt avoidance mechanisms. If this bit
	 * is set to 0, then the Consumer Index is only updated as soon
	 * as one of the host interrupt coalescing conditions has been met.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_FLAGS_COAL_NOW        UINT32_C(0x8000)
	/*
	 * This is the length of the host physical buffer this BD describes
	 * in bytes.
	 *
	 * This field must be valid on all BDs of a packet.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is passed through to the completion and can be
	 * used for any data that the driver wants to associate with the
	 * transmit BD.
	 *
	 * This field must be valid on the first BD of a packet. If completion
	 * coalescing is enabled on the TX ring, it is suggested that the driver
	 * populate the opaque field to indicate the specific TX ring with which
	 * the completion is associated, then utilize the opaque and sq_cons_idx
	 * fields in the coalesced completion record to determine the specific
	 * packets that are to be completed on that ring.
	 */
	uint32_t	opaque;
	/*
	 * This is the host physical address for the portion of the packet
	 * described by this TX BD.
	 *
	 * This value must be valid on all BDs of a packet.
	 */
	uint64_t	address;
} __rte_packed;

/* Last 16 bytes of tx_bd_long. */
/* tx_bd_long_hi (size:128b/16B) */
struct tx_bd_long_hi {
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Their value on other BDs of the packet will be ignored.
	 */
	uint16_t	lflags;
	/*
	 * If set to 1, the controller replaces the TCP/UPD checksum
	 * fields of normal TCP/UPD checksum, or the inner TCP/UDP
	 * checksum field of the encapsulated TCP/UDP packets with the
	 * hardware calculated TCP/UDP checksum for the packet associated
	 * with this descriptor. The flag is ignored if the LSO flag is set.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_LFLAGS_TCP_UDP_CHKSUM     UINT32_C(0x1)
	/*
	 * If set to 1, the controller replaces the IP checksum of the
	 * normal packets, or the inner IP checksum of the encapsulated
	 * packets with the hardware calculated IP checksum for the
	 * packet associated with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_LFLAGS_IP_CHKSUM          UINT32_C(0x2)
	/*
	 * If set to 1, the controller will not append an Ethernet CRC
	 * to the end of the frame.
	 *
	 * This bit must be valid on the first BD of a packet.
	 *
	 * Packet must be 64B or longer when this flag is set. It is not
	 * useful to use this bit with any form of TX offload such as
	 * CSO or LSO. The intent is that the packet from the host already
	 * has a valid Ethernet CRC on the packet.
	 */
	#define TX_BD_LONG_LFLAGS_NOCRC              UINT32_C(0x4)
	/*
	 * This bit, in conjunction with the stamp_1step bit, controls whether
	 * a TX packet timestamp is collected and the type of timestamp that
	 * is collected.
	 *
	 * This bit must be valid on the first BD of a packet.
	 *
	 * Enumerations of the concatenation { stamp, stamp_1step } are
	 * as follows:
	 *
	 * - 2'b00: ts_none - no timestamp
	 * - 2'b01: ts_ptp_1step - 1-step PTP
	 * - 2'b10: ts_2cmpl - 2-step PTP timestamp or PA timestamp
	 * - 2'b11: ts_rsvd - reserved, same behavior as ts_none
	 * For the ts_2cmpl enumeration, an additional completion is returned.
	 * This additional completion may carry a 2-step PTP timestamp or a PA
	 * timestamp, depending on parsing of the transmitted packet.
	 */
	#define TX_BD_LONG_LFLAGS_STAMP              UINT32_C(0x8)
	/*
	 * If set to 1, The controller replaces the tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header
	 * of the packet associated with this descriptor.
	 *
	 * For outer UDP checksum, global outer UDP checksum TE_NIC register
	 * needs to be enabled. If the global outer UDP checksum TE_NIC
	 * register bit is set, outer UDP checksum will be calculated for
	 * the following cases:
	 * 1. Packets with tcp_udp_chksum flag set to offload checksum for
	 * inner packet AND the inner packet is TCP/UDP. If the inner packet
	 * is ICMP for example (non-TCP/UDP), even if the tcp_udp_chksum is
	 * set, the outer UDP checksum will not be calculated.
	 * 2. Packets with lso flag set which implies inner TCP checksum
	 * calculation as part of LSO operation.
	 */
	#define TX_BD_LONG_LFLAGS_T_IP_CHKSUM        UINT32_C(0x10)
	/*
	 * If set to 1, the device will treat this packet with LSO(Large
	 * Send Offload) processing for both normal or encapsulated
	 * packets, which is a form of TCP segmentation. When this bit
	 * is 1, the hdr_size and mss fields must be valid. The driver
	 * doesn't need to set ot_ip_chksum, t_ip_chksum, ip_chksum, and
	 * tcp_udp_chksum flags since the controller will replace the
	 * appropriate checksum fields for segmented packets.
	 *
	 * When this bit is 1, the hdr_size and mss fields must be valid.
	 */
	#define TX_BD_LONG_LFLAGS_LSO                UINT32_C(0x20)
	/*
	 * If set to zero when LSO is '1', then the IPID will be treated
	 * as a 16b number and will be wrapped if it exceeds a value of
	 * 0xffff.
	 *
	 * If set to one when LSO is '1', then the IPID will be treated
	 * as a 15b number and will be wrapped if it exceeds a value 0f
	 * 0x7fff.
	 */
	#define TX_BD_LONG_LFLAGS_IPID_FMT           UINT32_C(0x40)
	/*
	 * If set to zero when LSO is '1', then the IPID of the tunnel
	 * IP header will not be modified during LSO operations.
	 *
	 * If set to one when LSO is '1', then the IPID of the tunnel
	 * IP header will be incremented for each subsequent segment of an
	 * LSO operation.
	 *
	 * The flag is ignored if the LSO packet is a normal (non-tunneled)
	 * TCP packet.
	 */
	#define TX_BD_LONG_LFLAGS_T_IPID             UINT32_C(0x80)
	/*
	 * If set to '1', then the RoCE ICRC will be appended to the
	 * packet. Packet must be a valid RoCE format packet.
	 */
	#define TX_BD_LONG_LFLAGS_ROCE_CRC           UINT32_C(0x100)
	/*
	 * If set to '1', then the FCoE CRC will be appended to the
	 * packet. Packet must be a valid FCoE format packet.
	 */
	#define TX_BD_LONG_LFLAGS_FCOE_CRC           UINT32_C(0x200)
	/*
	 * If set to '1', then the timestamp from the BD is used. If cleared
	 * to 0, then TWE provides the timestamp.
	 */
	#define TX_BD_LONG_LFLAGS_BD_TS_EN           UINT32_C(0x400)
	/*
	 * If set to '1', this operation will cause a trace capture in each
	 * block it passes through.
	 */
	#define TX_BD_LONG_LFLAGS_DEBUG_TRACE        UINT32_C(0x800)
	/*
	 * This bit, in conjunction with the stamp bit, controls whether a
	 * TX packet timestamp is collected and the type of timestamp that
	 * is collected.
	 *
	 * See the stamp field for a description of the valid combinations of
	 * stamp and stamp_1step.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_LFLAGS_STAMP_1STEP        UINT32_C(0x1000)
	/*
	 * If set to '1', the controller replaces the Outer-tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header of the
	 * packet associated with this descriptor. For outer UDP checksum, it
	 * will be the following behavior for all cases independent of
	 * settings of inner LSO and checksum offload BD flags.
	 * If outer UDP checksum is 0, then do not update it.
	 * If outer UDP checksum is non zero, then  the hardware should
	 * compute and update it.
	 */
	#define TX_BD_LONG_LFLAGS_OT_IP_CHKSUM       UINT32_C(0x2000)
	/*
	 * If set to zero when LSO is '1', then the IPID of the Outer-tunnel
	 * IP header will not be modified during LSO operations. If set to one
	 * when LSO is '1', then the IPID of the Outer-tunnel IP header will
	 * be incremented for each subsequent segment of an LSO operation. The
	 * flag is ignored if the LSO packet is a normal (non-tunneled) TCP
	 * packet.
	 */
	#define TX_BD_LONG_LFLAGS_OT_IPID            UINT32_C(0x4000)
	/*
	 * If set to '1', When set to 1, KTLS encryption will be enabled for
	 * the packet.
	 */
	#define TX_BD_LONG_LFLAGS_CRYPTO_EN          UINT32_C(0x8000)
	uint16_t	kid_or_ts_low_hdr_size;
	/*
	 * When LSO is '1', this field must contain the offset of the
	 * TCP payload from the beginning of the packet in as
	 * 16b words. In case of encapsulated/tunneling packet, this field
	 * contains the offset of the inner TCP payload from beginning of the
	 * packet as 16-bit words.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_HDR_SIZE_MASK     UINT32_C(0x1ff)
	#define TX_BD_LONG_HDR_SIZE_SFT      0
	/*
	 * If lflags.bd_ts_en is 1, this is the lower 7 bits of the 24-bit
	 * timestamp. If lflags.crypto_en is 1, this is the lower 7 bits of
	 * the 20-bit KID.
	 */
	#define TX_BD_LONG_KID_OR_TS_LOW_MASK UINT32_C(0xfe00)
	#define TX_BD_LONG_KID_OR_TS_LOW_SFT 9
	uint32_t	kid_or_ts_high_mss;
	/*
	 * This is the MSS value that will be used to do the LSO processing.
	 * The value is the length in bytes of the TCP payload for each
	 * segment generated by the LSO operation.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_MSS_MASK           UINT32_C(0x7fff)
	#define TX_BD_LONG_MSS_SFT            0
	/*
	 * If lflags.bd_ts_en is 1, this is the upper 17 bits of the 24-bit
	 * timestamp. If lflags.crypto_en is 1, the least significant 13 bits
	 * of this field contain the upper 13 bits of the 20-bit KID.
	 */
	#define TX_BD_LONG_KID_OR_TS_HIGH_MASK UINT32_C(0xffff8000)
	#define TX_BD_LONG_KID_OR_TS_HIGH_SFT 15
	/*
	 * This value selects bits 25:16 of the CFA action to perform on the
	 * packet. See the cfa_action field for more information.
	 */
	uint16_t	cfa_action_high;
	#define TX_BD_LONG_CFA_ACTION_HIGH_MASK UINT32_C(0x3ff)
	#define TX_BD_LONG_CFA_ACTION_HIGH_SFT 0
	/*
	 * This value selects a CFA action to perform on the packet.
	 * Set this value to zero if no CFA action is desired.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	uint16_t	cfa_action;
	/*
	 * This value is action meta-data that defines CFA edit operations
	 * that are done in addition to any action editing.
	 */
	uint32_t	cfa_meta;
	/* When key=1, This is the VLAN tag VID value. */
	#define TX_BD_LONG_CFA_META_VLAN_VID_MASK        UINT32_C(0xfff)
	#define TX_BD_LONG_CFA_META_VLAN_VID_SFT         0
	/* When key=1, This is the VLAN tag DE value. */
	#define TX_BD_LONG_CFA_META_VLAN_DE              UINT32_C(0x1000)
	/* When key=1, This is the VLAN tag PRI value. */
	#define TX_BD_LONG_CFA_META_VLAN_PRI_MASK        UINT32_C(0xe000)
	#define TX_BD_LONG_CFA_META_VLAN_PRI_SFT         13
	/* When key=1, This is the VLAN tag TPID select value. */
	#define TX_BD_LONG_CFA_META_VLAN_TPID_MASK       UINT32_C(0x70000)
	#define TX_BD_LONG_CFA_META_VLAN_TPID_SFT        16
	/* 0x88a8 */
	#define TX_BD_LONG_CFA_META_VLAN_TPID_TPID88A8 \
		(UINT32_C(0x0) << 16)
	/* 0x8100 */
	#define TX_BD_LONG_CFA_META_VLAN_TPID_TPID8100 \
		(UINT32_C(0x1) << 16)
	/* 0x9100 */
	#define TX_BD_LONG_CFA_META_VLAN_TPID_TPID9100 \
		(UINT32_C(0x2) << 16)
	/* 0x9200 */
	#define TX_BD_LONG_CFA_META_VLAN_TPID_TPID9200 \
		(UINT32_C(0x3) << 16)
	/* 0x9300 */
	#define TX_BD_LONG_CFA_META_VLAN_TPID_TPID9300 \
		(UINT32_C(0x4) << 16)
	/* Value programmed in CFA VLANTPID register. */
	#define TX_BD_LONG_CFA_META_VLAN_TPID_TPIDCFG \
		(UINT32_C(0x5) << 16)
	#define TX_BD_LONG_CFA_META_VLAN_TPID_LAST \
		TX_BD_LONG_CFA_META_VLAN_TPID_TPIDCFG
	/* When key=1, This is the VLAN tag TPID select value. */
	#define TX_BD_LONG_CFA_META_VLAN_RESERVED_MASK   UINT32_C(0xff80000)
	#define TX_BD_LONG_CFA_META_VLAN_RESERVED_SFT    19
	/*
	 * This field identifies the type of edit to be performed
	 * on the packet.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_CFA_META_KEY_MASK             UINT32_C(0xf0000000)
	#define TX_BD_LONG_CFA_META_KEY_SFT              28
	/* No editing */
	#define TX_BD_LONG_CFA_META_KEY_NONE \
		(UINT32_C(0x0) << 28)
	/*
	 * - meta[17:16] - TPID select value (0 = 0x8100).
	 * - meta[15:12] - PRI/DE value.
	 * - meta[11:0] - VID value.
	 */
	#define TX_BD_LONG_CFA_META_KEY_VLAN_TAG \
		(UINT32_C(0x1) << 28)
	/*
	 * Provide metadata
	 * - Wh+/SR - this option is not supported.
	 * - Thor - cfa_meta[15:0] is used for metadata output if en_bd_meta
	 *   is set in the Lookup Table.
	 * - SR2 - {4d0, cfa_meta[27:0]} is used for metadata output if
	 *   en_bd_meta is set in the Lookup Table.
	 */
	#define TX_BD_LONG_CFA_META_KEY_METADATA_TRANSFER \
		(UINT32_C(0x2) << 28)
	#define TX_BD_LONG_CFA_META_KEY_LAST \
		TX_BD_LONG_CFA_META_KEY_METADATA_TRANSFER
} __rte_packed;

/*
 * This structure is used to inform the NIC of packet data that needs to
 * be transmitted with additional processing that requires extra data
 * such as VLAN insertion plus attached inline data.
 * This BD type may be used to improve latency for small packets needing
 * the additional extended features supported by long BDs.
 */
/* tx_bd_long_inline (size:256b/32B) */
struct tx_bd_long_inline {
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define TX_BD_LONG_INLINE_TYPE_MASK             UINT32_C(0x3f)
	#define TX_BD_LONG_INLINE_TYPE_SFT              0
	/*
	 * This type of BD is 32B long and is used for inline L2 packet
	 * transmission.
	 */
	#define TX_BD_LONG_INLINE_TYPE_TX_BD_LONG_INLINE  UINT32_C(0x11)
	#define TX_BD_LONG_INLINE_TYPE_LAST \
		TX_BD_LONG_INLINE_TYPE_TX_BD_LONG_INLINE
	/*
	 * All bits in this field may be set on the first BD of a packet.
	 * Only the packet_end bit may be set in non-first BDs.
	 */
	#define TX_BD_LONG_INLINE_FLAGS_MASK            UINT32_C(0xffc0)
	#define TX_BD_LONG_INLINE_FLAGS_SFT             6
	/*
	 * If set to 1, the packet ends with the data in the buffer
	 * pointed to by this descriptor. This flag must be
	 * valid on every BD.
	 */
	#define TX_BD_LONG_INLINE_FLAGS_PACKET_END       UINT32_C(0x40)
	/*
	 * If set to 1, the device will not generate a completion for
	 * this transmit packet unless there is an error in its processing.
	 * If this bit is set to 0, then the packet will be completed
	 * normally.
	 *
	 * This bit may be set only on the first BD of a packet.
	 */
	#define TX_BD_LONG_INLINE_FLAGS_NO_CMPL          UINT32_C(0x80)
	/*
	 * This value indicates how many 16B BD locations are consumed
	 * in the ring by this packet, including the BD and inline
	 * data.
	 */
	#define TX_BD_LONG_INLINE_FLAGS_BD_CNT_MASK      UINT32_C(0x1f00)
	#define TX_BD_LONG_INLINE_FLAGS_BD_CNT_SFT       8
	/* This field is deprecated. */
	#define TX_BD_LONG_INLINE_FLAGS_LHINT_MASK       UINT32_C(0x6000)
	#define TX_BD_LONG_INLINE_FLAGS_LHINT_SFT        13
	/*
	 * If set to 1, the device immediately updates the Send Consumer
	 * Index after the buffer associated with this descriptor has
	 * been transferred via DMA to NIC memory from host memory. An
	 * interrupt may or may not be generated according to the state
	 * of the interrupt avoidance mechanisms. If this bit
	 * is set to 0, then the Consumer Index is only updated as soon
	 * as one of the host interrupt coalescing conditions has been met.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_INLINE_FLAGS_COAL_NOW         UINT32_C(0x8000)
	/*
	 * This is the length of the inline data, not including BD length, in
	 * bytes.
	 * The maximum value is 480.
	 *
	 * This field must be valid on all BDs of a packet.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is passed through to the completion and can be
	 * used for any data that the driver wants to associate with the
	 * transmit BD. This field must be valid on the first BD of a packet.
	 * If completion coalescing is enabled on the TX ring, it is suggested
	 * that the driver populate the opaque field to indicate the specific
	 * TX ring with which the completion is associated, then utilize the
	 * opaque and sq_cons_idx fields in the coalesced completion record to
	 * determine the specific packets that are to be completed on that ring.
	 *
	 * This field must be valid on the first BD of a packet.
	 */
	uint32_t	opaque;
	uint64_t	unused1;
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Their value on other BDs of the packet is ignored.
	 */
	uint16_t	lflags;
	/*
	 * If set to 1, the controller replaces the TCP/UPD checksum
	 * fields of normal TCP/UPD checksum, or the inner TCP/UDP
	 * checksum field of the encapsulated TCP/UDP packets with the
	 * hardware calculated TCP/UDP checksum for the packet associated
	 * with this descriptor. The flag is ignored if the LSO flag is set.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_TCP_UDP_CHKSUM     UINT32_C(0x1)
	/*
	 * If set to 1, the controller replaces the IP checksum of the
	 * normal packets, or the inner IP checksum of the encapsulated
	 * packets with the hardware calculated IP checksum for the
	 * packet associated with this descriptor.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_IP_CHKSUM          UINT32_C(0x2)
	/*
	 * If set to 1, the controller will not append an Ethernet CRC
	 * to the end of the frame.
	 *
	 * Packet must be 64B or longer when this flag is set. It is not
	 * useful to use this bit with any form of TX offload such as
	 * CSO or LSO. The intent is that the packet from the host already
	 * has a valid Ethernet CRC on the packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_NOCRC              UINT32_C(0x4)
	/*
	 * If set to 1, the device will record the time at which the packet
	 * was actually transmitted at the TX MAC for 2-step time sync. This
	 * bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_STAMP              UINT32_C(0x8)
	/*
	 * If set to 1, the controller replaces the tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header
	 * of the packet associated with this descriptor. The hardware
	 * updates an outer UDP checksum if it is non-zero.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_T_IP_CHKSUM        UINT32_C(0x10)
	/*
	 * This bit must be 0 for BDs of this type. LSO is not supported with
	 * inline BDs.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_LSO                UINT32_C(0x20)
	/* Since LSO is not supported with inline BDs, this bit is not used. */
	#define TX_BD_LONG_INLINE_LFLAGS_IPID_FMT           UINT32_C(0x40)
	/* Since LSO is not supported with inline BDs, this bit is not used. */
	#define TX_BD_LONG_INLINE_LFLAGS_T_IPID             UINT32_C(0x80)
	/*
	 * If set to '1', then the RoCE ICRC will be appended to the
	 * packet. Packet must be a valid RoCE format packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_ROCE_CRC           UINT32_C(0x100)
	/*
	 * If set to '1', then the FCoE CRC will be appended to the
	 * packet. Packet must be a valid FCoE format packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_FCOE_CRC           UINT32_C(0x200)
	/*
	 * If set to '1', then the timestamp from the BD is used. If cleared
	 * to 0, then TWE provides the timestamp.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_BD_TS_EN           UINT32_C(0x400)
	/*
	 * If set to '1', this operation will cause a trace capture in each
	 * block it passes through.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_DEBUG_TRACE        UINT32_C(0x800)
	/*
	 * If set to '1', the device will record the time at which the packet
	 * was actually transmitted at the TX MAC for 1-step time sync. This
	 * bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_STAMP_1STEP        UINT32_C(0x1000)
	/*
	 * If set to '1', the controller replaces the Outer-tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header of the
	 * packet associated with this descriptor. For outer UDP checksum, it
	 * will be the following behavior for all cases independent of settings
	 * of inner LSO and checksum offload BD flags. If outer UDP checksum
	 * is 0, then do not update it. If outer UDP checksum is non zero, then
	 * the hardware should compute and update it.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_OT_IP_CHKSUM       UINT32_C(0x2000)
	/*
	 * If set to zero when LSO is '1', then the IPID of the Outer-tunnel IP
	 * header will not be modified during LSO operations. If set to one
	 * when LSO is '1', then the IPID of the Outer-tunnel IP header will be
	 * incremented for each subsequent segment of an LSO operation. The
	 * flag is ignored if the LSO packet is a normal (non-tunneled) TCP
	 * packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_OT_IPID            UINT32_C(0x4000)
	/*
	 * If set to '1', When set to 1, KTLS encryption will be enabled for
	 * the packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_CRYPTO_EN          UINT32_C(0x8000)
	uint8_t	unused2;
	uint8_t	kid_or_ts_low;
	#define TX_BD_LONG_INLINE_UNUSED            UINT32_C(0x1)
	/*
	 * If lflags.bd_ts_en is 1, this is the lower 7 bits of the 24-bit
	 * timestamp. If lflags.crypto_en is 1, this is the lower 7 bits of
	 * the 20-bit KID.
	 */
	#define TX_BD_LONG_INLINE_KID_OR_TS_LOW_MASK UINT32_C(0xfe)
	#define TX_BD_LONG_INLINE_KID_OR_TS_LOW_SFT 1
	uint32_t	kid_or_ts_high;
	#define TX_BD_LONG_INLINE_UNUSED_MASK        UINT32_C(0x7fff)
	#define TX_BD_LONG_INLINE_UNUSED_SFT         0
	/*
	 * If lflags.bd_ts_en is 1, this is the upper 17 bits of the 24-bit
	 * timestamp. If lflags.crypto_en is 1, the least significant 13 bits
	 * of this field contain the upper 13 bits of the 20-bit KID.
	 */
	#define TX_BD_LONG_INLINE_KID_OR_TS_HIGH_MASK UINT32_C(0xffff8000)
	#define TX_BD_LONG_INLINE_KID_OR_TS_HIGH_SFT 15
	/*
	 * This value selects bits 25:16 of the CFA action to perform on the
	 * packet. See the cfa_action field for more information.
	 */
	uint16_t	cfa_action_high;
	#define TX_BD_LONG_INLINE_CFA_ACTION_HIGH_MASK UINT32_C(0x3ff)
	#define TX_BD_LONG_INLINE_CFA_ACTION_HIGH_SFT 0
	/*
	 * This value selects a CFA action to perform on the packet.
	 * Set this value to zero if no CFA action is desired.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	uint16_t	cfa_action;
	/*
	 * This value is action meta-data that defines CFA edit operations
	 * that are done in addition to any action editing.
	 */
	uint32_t	cfa_meta;
	/* When key = 1, this is the VLAN tag VID value. */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_VID_MASK        UINT32_C(0xfff)
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_VID_SFT         0
	/* When key = 1, this is the VLAN tag DE value. */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_DE \
		UINT32_C(0x1000)
	/* When key = 1, this is the VLAN tag PRI value. */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_PRI_MASK \
		UINT32_C(0xe000)
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_PRI_SFT         13
	/* When key = 1, this is the VLAN tag TPID select value. */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_MASK \
		UINT32_C(0x70000)
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_SFT        16
	/* 0x88a8 */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPID88A8 \
		(UINT32_C(0x0) << 16)
	/* 0x8100 */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPID8100 \
		(UINT32_C(0x1) << 16)
	/* 0x9100 */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPID9100 \
		(UINT32_C(0x2) << 16)
	/* 0x9200 */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPID9200 \
		(UINT32_C(0x3) << 16)
	/* 0x9300 */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPID9300 \
		(UINT32_C(0x4) << 16)
	/* Value programmed in CFA VLANTPID register. */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPIDCFG \
		(UINT32_C(0x5) << 16)
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_LAST \
		TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPIDCFG
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_RESERVED_MASK \
		UINT32_C(0xff80000)
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_RESERVED_SFT    19
	/*
	 * This field identifies the type of edit to be performed
	 * on the packet.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_INLINE_CFA_META_KEY_MASK \
		UINT32_C(0xf0000000)
	#define TX_BD_LONG_INLINE_CFA_META_KEY_SFT              28
	/* No editing */
	#define TX_BD_LONG_INLINE_CFA_META_KEY_NONE \
		(UINT32_C(0x0) << 28)
	/*
	 * - meta[17:16] - TPID select value (0 = 0x8100).
	 * - meta[15:12] - PRI/DE value.
	 * - meta[11:0] - VID value.
	 */
	#define TX_BD_LONG_INLINE_CFA_META_KEY_VLAN_TAG \
		(UINT32_C(0x1) << 28)
	/*
	 * Provide metadata
	 * - Wh+/SR - this option is not supported.
	 * - Thor - cfa_meta[15:0] is used for metadata output if en_bd_meta
	 *   is set in the Lookup Table.
	 * - SR2 - {4d0, cfa_meta[27:0]} is used for metadata output if
	 *   en_bd_meta is set in the Lookup Table.
	 */
	#define TX_BD_LONG_INLINE_CFA_META_KEY_METADATA_TRANSFER \
		(UINT32_C(0x2) << 28)
	#define TX_BD_LONG_INLINE_CFA_META_KEY_LAST \
		TX_BD_LONG_INLINE_CFA_META_KEY_METADATA_TRANSFER
} __rte_packed;

/* tx_bd_empty (size:128b/16B) */
struct tx_bd_empty {
	/* This value identifies the type of buffer descriptor. */
	uint8_t	type;
	#define TX_BD_EMPTY_TYPE_MASK       UINT32_C(0x3f)
	#define TX_BD_EMPTY_TYPE_SFT        0
	/*
	 * Indicates that this BD is 1BB long and is an empty
	 * TX BD. Not valid for use by the driver.
	 */
	#define TX_BD_EMPTY_TYPE_TX_BD_EMPTY  UINT32_C(0x1)
	#define TX_BD_EMPTY_TYPE_LAST        TX_BD_EMPTY_TYPE_TX_BD_EMPTY
	uint8_t	unused_1[3];
	uint8_t	unused_2;
	uint8_t	unused_3[3];
	uint8_t	unused_4[8];
} __rte_packed;

/* tx_bd_mp_cmd (size:128b/16B) */
struct tx_bd_mp_cmd {
	/* Unless otherwise stated, sub-fields of this field are always valid. */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define TX_BD_MP_CMD_TYPE_MASK        UINT32_C(0x3f)
	#define TX_BD_MP_CMD_TYPE_SFT         0
	/*
	 * Indicates that this BD is used to issue a command to one of
	 * the mid-path destinations.
	 */
	#define TX_BD_MP_CMD_TYPE_TX_BD_MP_CMD  UINT32_C(0x8)
	#define TX_BD_MP_CMD_TYPE_LAST         TX_BD_MP_CMD_TYPE_TX_BD_MP_CMD
	#define TX_BD_MP_CMD_FLAGS_MASK       UINT32_C(0xffc0)
	#define TX_BD_MP_CMD_FLAGS_SFT        6
	/*  */
	#define TX_BD_MP_CMD_FLAGS_UNUSED_MASK UINT32_C(0xc0)
	#define TX_BD_MP_CMD_FLAGS_UNUSED_SFT  6
	/*
	 * This value indicates the number of 16B BD locations (slots)
	 * consumed in the ring by this mid-path command BD, including the
	 * BD header and the command field.
	 */
	#define TX_BD_MP_CMD_FLAGS_BD_CNT_MASK UINT32_C(0x1f00)
	#define TX_BD_MP_CMD_FLAGS_BD_CNT_SFT  8
	/*
	 * This value defines the length of command field in bytes. The maximum
	 * value shall be 496.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to the completion and can be
	 * used for any data that the driver wants to associate with this
	 * Tx mid-path command.
	 */
	uint32_t	opaque;
	uint64_t	unused1;
} __rte_packed;

/* tx_bd_presync_cmd (size:128b/16B) */
struct tx_bd_presync_cmd {
	/* Unless otherwise stated, sub-fields of this field are always valid. */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define TX_BD_PRESYNC_CMD_TYPE_MASK             UINT32_C(0x3f)
	#define TX_BD_PRESYNC_CMD_TYPE_SFT              0
	/*
	 * Indicates that this BD is used to issue a cryptographic pre-
	 * sync command through the fast path and destined for TCE.
	 */
	#define TX_BD_PRESYNC_CMD_TYPE_TX_BD_PRESYNC_CMD  UINT32_C(0x9)
	#define TX_BD_PRESYNC_CMD_TYPE_LAST \
		TX_BD_PRESYNC_CMD_TYPE_TX_BD_PRESYNC_CMD
	#define TX_BD_PRESYNC_CMD_FLAGS_MASK            UINT32_C(0xffc0)
	#define TX_BD_PRESYNC_CMD_FLAGS_SFT             6
	/*  */
	#define TX_BD_PRESYNC_CMD_FLAGS_UNUSED_MASK      UINT32_C(0xc0)
	#define TX_BD_PRESYNC_CMD_FLAGS_UNUSED_SFT       6
	/*
	 * This value indicates the number of 16B BD locations (slots)
	 * consumed in the ring by this pre-sync command BD, including the
	 * BD header and the command field.
	 */
	#define TX_BD_PRESYNC_CMD_FLAGS_BD_CNT_MASK      UINT32_C(0x1f00)
	#define TX_BD_PRESYNC_CMD_FLAGS_BD_CNT_SFT       8
	/*
	 * This value defines the length of command field in bytes. The maximum
	 * value shall be 496.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to TCE and can be used for
	 * debug.
	 */
	uint32_t	opaque;
	/*
	 * This field is the Crypto Context ID to which the retransmit packet is
	 * applied. The KID references the context fields used by the
	 * associated kTLS offloaded connection.
	 */
	uint32_t	kid;
	/*
	 * The KID value of all-ones is reserved for non-KTLS packets, which
	 * only implies that this value must not be used when filling this
	 * field for crypto packets.
	 */
	#define TX_BD_PRESYNC_CMD_KID_VAL_MASK UINT32_C(0xfffff)
	#define TX_BD_PRESYNC_CMD_KID_VAL_SFT 0
	uint32_t	unused_1;
} __rte_packed;

/* rx_prod_pkt_bd (size:128b/16B) */
struct rx_prod_pkt_bd {
	/* This value identifies the type of buffer descriptor. */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define RX_PROD_PKT_BD_TYPE_MASK         UINT32_C(0x3f)
	#define RX_PROD_PKT_BD_TYPE_SFT          0
	/*
	 * Indicates that this BD is 16B long and is an RX Producer
	 * (i.e. empty) buffer descriptor.
	 */
	#define RX_PROD_PKT_BD_TYPE_RX_PROD_PKT    UINT32_C(0x4)
	#define RX_PROD_PKT_BD_TYPE_LAST \
		RX_PROD_PKT_BD_TYPE_RX_PROD_PKT
	#define RX_PROD_PKT_BD_FLAGS_MASK        UINT32_C(0xffc0)
	#define RX_PROD_PKT_BD_FLAGS_SFT         6
	/*
	 * If set to 1, the packet will be placed at the address plus
	 * 2B. The 2 Bytes of padding will be written as zero.
	 */
	#define RX_PROD_PKT_BD_FLAGS_SOP_PAD      UINT32_C(0x40)
	/*
	 * If set to 1, the packet write will be padded out to the
	 * nearest cache-line with zero value padding.
	 */
	#define RX_PROD_PKT_BD_FLAGS_EOP_PAD      UINT32_C(0x80)
	/*
	 * This field has been deprecated. There can be no additional
	 * BDs for this packet from this ring.
	 *
	 * Old definition:
	 * This value is the number of additional buffers in the ring that
	 * describe the buffer space to be consumed for this packet.
	 * If the value is zero, then the packet must fit within the
	 * space described by this BD. If this value is 1 or more, it
	 * indicates how many additional "buffer" BDs are in the ring
	 * immediately following this BD to be used for the same
	 * network packet. Even if the packet to be placed does not need
	 * all the additional buffers, they will be consumed anyway.
	 */
	#define RX_PROD_PKT_BD_FLAGS_BUFFERS_MASK UINT32_C(0x300)
	#define RX_PROD_PKT_BD_FLAGS_BUFFERS_SFT  8
	/*
	 * This is the length in Bytes of the host physical buffer where
	 * data for the packet may be placed in host memory.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to the completion and can be
	 * used for any data that the driver wants to associate with this
	 * receive buffer set.
	 */
	uint32_t	opaque;
	/*
	 * This is the host physical address where data for the packet may
	 * be placed in host memory.
	 */
	uint64_t	address;
} __rte_packed;

/* rx_prod_bfr_bd (size:128b/16B) */
struct rx_prod_bfr_bd {
	/* This value identifies the type of buffer descriptor. */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define RX_PROD_BFR_BD_TYPE_MASK       UINT32_C(0x3f)
	#define RX_PROD_BFR_BD_TYPE_SFT        0
	/*
	 * Indicates that this BD is 16B long and is an RX
	 * Producer Buffer BD.
	 */
	#define RX_PROD_BFR_BD_TYPE_RX_PROD_BFR  UINT32_C(0x5)
	#define RX_PROD_BFR_BD_TYPE_LAST        RX_PROD_BFR_BD_TYPE_RX_PROD_BFR
	#define RX_PROD_BFR_BD_FLAGS_MASK      UINT32_C(0xffc0)
	#define RX_PROD_BFR_BD_FLAGS_SFT       6
	/*
	 * This is the length in Bytes of the host physical buffer where
	 * data for the packet may be placed in host memory.
	 */
	uint16_t	len;
	/* This field is not used. */
	uint32_t	opaque;
	/*
	 * This is the host physical address where data for the packet may
	 * be placed in host memory.
	 */
	uint64_t	address;
} __rte_packed;

/* rx_prod_agg_bd (size:128b/16B) */
struct rx_prod_agg_bd {
	/* This value identifies the type of buffer descriptor. */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define RX_PROD_AGG_BD_TYPE_MASK         UINT32_C(0x3f)
	#define RX_PROD_AGG_BD_TYPE_SFT          0
	/*
	 * Indicates that this BD is 16B long and is an
	 * RX Producer Assembly Buffer Descriptor.
	 */
	#define RX_PROD_AGG_BD_TYPE_RX_PROD_AGG    UINT32_C(0x6)
	#define RX_PROD_AGG_BD_TYPE_LAST \
		RX_PROD_AGG_BD_TYPE_RX_PROD_AGG
	#define RX_PROD_AGG_BD_FLAGS_MASK        UINT32_C(0xffc0)
	#define RX_PROD_AGG_BD_FLAGS_SFT         6
	/*
	 * If set to 1, the packet write will be padded out to the
	 * nearest cache-line with zero value padding.
	 */
	#define RX_PROD_AGG_BD_FLAGS_EOP_PAD      UINT32_C(0x40)
	/*
	 * This is the length in Bytes of the host physical buffer where
	 * data for the packet may be placed in host memory.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to the completion and can be
	 * used for any data that the driver wants to associate with this
	 * receive assembly buffer.
	 */
	uint32_t	opaque;
	/*
	 * This is the host physical address where data for the packet may
	 * be placed in host memory.
	 */
	uint64_t	address;
} __rte_packed;

/* cfa_cmpls_cmp_data_msg (size:128b/16B) */
struct cfa_cmpls_cmp_data_msg {
	uint32_t	mp_client_dma_length_opcode_status_type;
	/*
	 * This field represents the Mid-Path client that generated the
	 * completion.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_TYPE_MASK                UINT32_C(0x3f)
	#define CFA_CMPLS_CMP_DATA_MSG_TYPE_SFT                 0
	/* Mid Path Short Completion with length = 16B. */
	#define CFA_CMPLS_CMP_DATA_MSG_TYPE_MID_PATH_SHORT \
		UINT32_C(0x1e)
	#define CFA_CMPLS_CMP_DATA_MSG_TYPE_LAST \
		CFA_CMPLS_CMP_DATA_MSG_TYPE_MID_PATH_SHORT
	/* This value indicates the status for the command. */
	#define CFA_CMPLS_CMP_DATA_MSG_STATUS_MASK              UINT32_C(0x3c0)
	#define CFA_CMPLS_CMP_DATA_MSG_STATUS_SFT               6
	/* Completed without error. */
	#define CFA_CMPLS_CMP_DATA_MSG_STATUS_OK \
		(UINT32_C(0x0) << 6)
	/* Indicates an unsupported CFA opcode in the command. */
	#define CFA_CMPLS_CMP_DATA_MSG_STATUS_UNSPRT_ERR \
		(UINT32_C(0x1) << 6)
	/*
	 * Indicates a CFA command formatting error. This error can occur on
	 * any of the supported CFA commands.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_STATUS_FMT_ERR \
		(UINT32_C(0x2) << 6)
	/*
	 * Indicates an SVIF-Table scope error. This error can occur on any
	 * of the supported CFA commands.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_STATUS_SCOPE_ERR \
		(UINT32_C(0x3) << 6)
	/*
	 * Indicates that the table_index is either outside of the
	 * table_scope range set by its EM_SIZE or, for EM Insert, it is in
	 * the static bucket range. This error can occur on EM Insert
	 * commands. It can also occur on Read, Read Clear, Write, and
	 * Invalidate commands if the table_type is EM.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_STATUS_ADDR_ERR \
		(UINT32_C(0x4) << 6)
	/*
	 * Cache operation responded with an error. This error can occur on
	 * Read, Read Clear, Write, EM Insert, and EM Delete commands.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_STATUS_CACHE_ERR \
		(UINT32_C(0x5) << 6)
	/*
	 * Indicates failure on EM Insert or EM Delete Command. Hash index
	 * and hash msb are returned in table_index and hash_msb fields.
	 * Dma_length is set to 1 if the bucket is also returned (as dma
	 * data).
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_STATUS_EM_FAIL \
		(UINT32_C(0x6) << 6)
	/*
	 * Indicates no notifications were available on an Event Collection
	 * command.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_STATUS_EVENT_COLLECT_FAIL \
		(UINT32_C(0x7) << 6)
	#define CFA_CMPLS_CMP_DATA_MSG_STATUS_LAST \
		CFA_CMPLS_CMP_DATA_MSG_STATUS_EVENT_COLLECT_FAIL
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED0_MASK             UINT32_C(0xc00)
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED0_SFT              10
	/* This is the opcode from the command. */
	#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_MASK \
		UINT32_C(0xff000)
	#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_SFT               12
	/*
	 * This is read command. From 32 to 128B can be read from a table
	 * using this command.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_READ \
		(UINT32_C(0x0) << 12)
	/*
	 * This is write command. From 32 to 128B can be written to a table
	 * using this command.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_WRITE \
		(UINT32_C(0x1) << 12)
	/*
	 * This is read-clear command. 32B can be read from a table and a 16b
	 * mask can be used to clear specific 16b units after the read as an
	 * atomic operation.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_READ_CLR \
		(UINT32_C(0x2) << 12)
	/*
	 * An exact match table insert will be attempted into the table. If
	 * there is a free location in the bucket, the payload will be
	 * written to the bucket.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_EM_INSERT \
		(UINT32_C(0x3) << 12)
	/* An exact match table delete will be attempted. */
	#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_EM_DELETE \
		(UINT32_C(0x4) << 12)
	/*
	 * The specified table area will be invalidated. If it is needed
	 * again, it will be read from the backing store.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_INVALIDATE \
		(UINT32_C(0x5) << 12)
	/* Reads notification messages from the Host Notification Queue. */
	#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_EVENT_COLLECT \
		(UINT32_C(0x6) << 12)
	#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_LAST \
		CFA_CMPLS_CMP_DATA_MSG_OPCODE_EVENT_COLLECT
	/*
	 * This field indicates the length of the DMA that accompanies the
	 * completion. Specified in units of DWords (32b). Valid values are
	 * between 0 and 128. A value of zero indicates that there is no DMA
	 * that accompanies the completion.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_DMA_LENGTH_MASK \
		UINT32_C(0xff00000)
	#define CFA_CMPLS_CMP_DATA_MSG_DMA_LENGTH_SFT           20
	/*
	 * This field represents the Mid-Path client that generated the
	 * completion.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_MASK \
		UINT32_C(0xf0000000)
	#define CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_SFT            28
	/* TX configurable flow processing block. */
	#define CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_TE_CFA \
		(UINT32_C(0x2) << 28)
	/* RX configurable flow processing block. */
	#define CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_RE_CFA \
		(UINT32_C(0x3) << 28)
	#define CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_LAST \
		CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_RE_CFA
	/*
	 * This is a copy of the opaque field from the mid path BD of this
	 * command.
	 */
	uint32_t	opaque;
	uint16_t	hash_msb_v;
	/*
	 * This value is written by the NIC such that it will be different for
	 * each pass through the completion queue. The even passes will
	 * write 1. The odd passes will write 0.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_V            UINT32_C(0x1)
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED1_MASK UINT32_C(0xe)
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED1_SFT  1
	/*
	 * This is the upper 12b of the hash, returned on Exact Match
	 * Insertion/Deletion Commands.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_HASH_MSB_MASK UINT32_C(0xfff0)
	#define CFA_CMPLS_CMP_DATA_MSG_HASH_MSB_SFT 4
	/* This is the table type from the command. */
	uint8_t	table_type;
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED2_MASK     UINT32_C(0xf)
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED2_SFT      0
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_MASK  UINT32_C(0xf0)
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_SFT   4
	/* This command acts on the action table of the specified scope. */
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_ACTION  (UINT32_C(0x0) << 4)
	/* This command acts on the exact match table of the specified scope. */
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_EM      (UINT32_C(0x1) << 4)
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_LAST \
		CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_EM
	uint8_t	table_scope;
	/* This is the table scope from the command. */
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_SCOPE_SFT 0
	uint32_t	table_index;
	/*
	 * This is the table index from the command (if it exists). However, if
	 * an Exact Match Insertion/Deletion command failed, then this is the
	 * table index of the calculated static hash bucket.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_INDEX_MASK UINT32_C(0x3ffffff)
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_INDEX_SFT 0
} __rte_packed;

/* CFA Mid-Path 32B DMA Message */
/* cfa_dma32b_data_msg (size:256b/32B) */
struct cfa_dma32b_data_msg {
	/* DMA data value. */
	uint32_t	dta[8];
} __rte_packed;

/* CFA Mid-Path 64B DMA Message */
/* cfa_dma64b_data_msg (size:512b/64B) */
struct cfa_dma64b_data_msg {
	/* DMA data value. */
	uint32_t	dta[16];
} __rte_packed;

/* CFA Mid-Path 96B DMA Message */
/* cfa_dma96b_data_msg (size:768b/96B) */
struct cfa_dma96b_data_msg {
	/* DMA data value. */
	uint32_t	dta[24];
} __rte_packed;

/* CFA Mid-Path 128B DMA Message */
/* cfa_dma128b_data_msg (size:1024b/128B) */
struct cfa_dma128b_data_msg {
	/* DMA data value. */
	uint32_t	dta[32];
} __rte_packed;

/* ce_cmpls_cmp_data_msg (size:128b/16B) */
struct ce_cmpls_cmp_data_msg {
	uint16_t	client_subtype_type;
	/*
	 * This field indicates the exact type of the completion. By
	 * convention, the LSB identifies the length of the record in 16B
	 * units. Even values indicate 16B records. Odd values indicate 32B
	 * records.
	 */
	#define CE_CMPLS_CMP_DATA_MSG_TYPE_MASK          UINT32_C(0x3f)
	#define CE_CMPLS_CMP_DATA_MSG_TYPE_SFT           0
	/* Completion of a Mid Path Command. Length = 16B */
	#define CE_CMPLS_CMP_DATA_MSG_TYPE_MID_PATH_SHORT  UINT32_C(0x1e)
	#define CE_CMPLS_CMP_DATA_MSG_TYPE_LAST \
		CE_CMPLS_CMP_DATA_MSG_TYPE_MID_PATH_SHORT
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED0_MASK       UINT32_C(0xc0)
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED0_SFT        6
	/*
	 * This value indicates the CE sub-type operation that is being
	 * completed.
	 */
	#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_MASK       UINT32_C(0xf00)
	#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_SFT        8
	/* Completion Response for a Solicited Command. */
	#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_SOLICITED    (UINT32_C(0x0) << 8)
	/* Error Completion (Unsolicited). */
	#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_ERR          (UINT32_C(0x1) << 8)
	/* Re-Sync Completion (Unsolicited) */
	#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_RESYNC       (UINT32_C(0x2) << 8)
	#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_LAST \
		CE_CMPLS_CMP_DATA_MSG_SUBTYPE_RESYNC
	/*
	 * This field represents the Mid-Path client that generated the
	 * completion.
	 */
	#define CE_CMPLS_CMP_DATA_MSG_MP_CLIENT_MASK     UINT32_C(0xf000)
	#define CE_CMPLS_CMP_DATA_MSG_MP_CLIENT_SFT      12
	/* TX crypto engine block. */
	#define CE_CMPLS_CMP_DATA_MSG_MP_CLIENT_TCE \
		(UINT32_C(0x0) << 12)
	/* RX crypto engine block. */
	#define CE_CMPLS_CMP_DATA_MSG_MP_CLIENT_RCE \
		(UINT32_C(0x1) << 12)
	#define CE_CMPLS_CMP_DATA_MSG_MP_CLIENT_LAST \
		CE_CMPLS_CMP_DATA_MSG_MP_CLIENT_RCE
	uint16_t	status;
	/* This value indicates the status for the command. */
	#define CE_CMPLS_CMP_DATA_MSG_STATUS_MASK       UINT32_C(0xf)
	#define CE_CMPLS_CMP_DATA_MSG_STATUS_SFT        0
	/* Completed without error. */
	#define CE_CMPLS_CMP_DATA_MSG_STATUS_OK           UINT32_C(0x0)
	/* CFCK load error. */
	#define CE_CMPLS_CMP_DATA_MSG_STATUS_CTX_LD_ERR   UINT32_C(0x1)
	/* FID check error. */
	#define CE_CMPLS_CMP_DATA_MSG_STATUS_FID_CHK_ERR  UINT32_C(0x2)
	/* Context kind / MP version mismatch error. */
	#define CE_CMPLS_CMP_DATA_MSG_STATUS_CTX_VER_ERR  UINT32_C(0x3)
	/* Unsupported Destination Connection ID Length. */
	#define CE_CMPLS_CMP_DATA_MSG_STATUS_DST_ID_ERR   UINT32_C(0x4)
	/*
	 * Invalid MP Command [anything other than ADD or DELETE
	 * triggers this for QUIC].
	 */
	#define CE_CMPLS_CMP_DATA_MSG_STATUS_MP_CMD_ERR   UINT32_C(0x5)
	#define CE_CMPLS_CMP_DATA_MSG_STATUS_LAST \
		CE_CMPLS_CMP_DATA_MSG_STATUS_MP_CMD_ERR
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED1_MASK      UINT32_C(0xfff0)
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED1_SFT       4
	/*
	 * This is a copy of the opaque field from the mid path BD of this
	 * command.
	 */
	uint32_t	opaque;
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes will
	 * write 1. The odd passes will write 0.
	 */
	#define CE_CMPLS_CMP_DATA_MSG_V           UINT32_C(0x1)
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED2_MASK UINT32_C(0xfffffffe)
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED2_SFT 1
	uint32_t	kid;
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated kTLS offloaded connection.
	 */
	#define CE_CMPLS_CMP_DATA_MSG_KID_MASK    UINT32_C(0xfffff)
	#define CE_CMPLS_CMP_DATA_MSG_KID_SFT     0
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED3_MASK UINT32_C(0xfff00000)
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED3_SFT 20
} __rte_packed;

/* cmpl_base (size:128b/16B) */
struct cmpl_base {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CMPL_BASE_TYPE_MASK            UINT32_C(0x3f)
	#define CMPL_BASE_TYPE_SFT             0
	/*
	 * TX L2 completion:
	 * Completion of TX packet. Length = 16B
	 */
	#define CMPL_BASE_TYPE_TX_L2             UINT32_C(0x0)
	/*
	 * NO-OP completion:
	 * Completion of NO-OP. Length = 16B
	 */
	#define CMPL_BASE_TYPE_NO_OP             UINT32_C(0x1)
	/*
	 * TX L2 coalesced completion:
	 * Completion of coalesced TX packet. Length = 16B
	 */
	#define CMPL_BASE_TYPE_TX_L2_COAL        UINT32_C(0x2)
	/*
	 * TX L2 Packet Timestamp completion:
	 * Completion of an L2 Packet Timestamp Packet. Length = 16B
	 */
	#define CMPL_BASE_TYPE_TX_L2_PKT_TS      UINT32_C(0x4)
	/*
	 * RX L2 TPA Start V2 Completion:
	 * Completion of and L2 RX packet. Length = 32B
	 * This is the new version of the RX_TPA_START completion used
	 * in SR2 and later chips.
	 */
	#define CMPL_BASE_TYPE_RX_TPA_START_V2   UINT32_C(0xd)
	/*
	 * RX L2 V2 completion:
	 * Completion of and L2 RX packet. Length = 32B
	 * This is the new version of the RX_L2 completion used in SR2
	 * and later chips.
	 */
	#define CMPL_BASE_TYPE_RX_L2_V2          UINT32_C(0xf)
	/*
	 * RX L2 completion:
	 * This is the compressed version of Rx Completion for performance
	 * applications. Length = 16B
	 */
	#define CMPL_BASE_TYPE_RX_L2_COMPRESS    UINT32_C(0x10)
	/*
	 * RX L2 completion:
	 * Completion of and L2 RX packet. Length = 32B
	 */
	#define CMPL_BASE_TYPE_RX_L2             UINT32_C(0x11)
	/*
	 * RX Aggregation Buffer completion:
	 * Completion of an L2 aggregation buffer in support of
	 * TPA, HDS, or Jumbo packet completion. Length = 16B
	 */
	#define CMPL_BASE_TYPE_RX_AGG            UINT32_C(0x12)
	/*
	 * RX L2 TPA Start Completion:
	 * Completion at the beginning of a TPA operation.
	 * Length = 32B
	 */
	#define CMPL_BASE_TYPE_RX_TPA_START      UINT32_C(0x13)
	/*
	 * RX L2 TPA End Completion:
	 * Completion at the end of a TPA operation.
	 * Length = 32B
	 */
	#define CMPL_BASE_TYPE_RX_TPA_END        UINT32_C(0x15)
	/*
	 * RX TPA Aggregation Buffer Completion:
	 * Completion of an L2 aggregation buffer in support of TPA packet
	 * completion.
	 * Length = 16B
	 */
	#define CMPL_BASE_TYPE_RX_TPA_AGG        UINT32_C(0x16)
	/*
	 * RX L2 completion: Completion of and L2 RX packet.
	 * Length = 32B
	 */
	#define CMPL_BASE_TYPE_RX_L2_V3          UINT32_C(0x17)
	/*
	 * RX L2 TPA Start completion: Completion at the beginning of a TPA
	 * operation.
	 * Length = 32B
	 */
	#define CMPL_BASE_TYPE_RX_TPA_START_V3   UINT32_C(0x19)
	/*
	 * Statistics Ejection Completion:
	 * Completion of statistics data ejection buffer.
	 * Length = 16B
	 */
	#define CMPL_BASE_TYPE_STAT_EJECT        UINT32_C(0x1a)
	/*
	 * VEE Flush Completion:
	 * This completion is inserted manually by
	 * the Primate and processed by the VEE hardware to ensure that
	 * all completions on a VEE function have been processed by the
	 * VEE hardware before FLR process is completed.
	 */
	#define CMPL_BASE_TYPE_VEE_FLUSH         UINT32_C(0x1c)
	/*
	 * Mid Path Short Completion :
	 * Completion of a Mid Path Command. Length = 16B
	 */
	#define CMPL_BASE_TYPE_MID_PATH_SHORT    UINT32_C(0x1e)
	/*
	 * Mid Path Long Completion :
	 * Completion of a Mid Path Command. Length = 32B
	 */
	#define CMPL_BASE_TYPE_MID_PATH_LONG     UINT32_C(0x1f)
	/*
	 * HWRM Command Completion:
	 * Completion of an HWRM command.
	 */
	#define CMPL_BASE_TYPE_HWRM_DONE         UINT32_C(0x20)
	/* Forwarded HWRM Request */
	#define CMPL_BASE_TYPE_HWRM_FWD_REQ      UINT32_C(0x22)
	/* Forwarded HWRM Response */
	#define CMPL_BASE_TYPE_HWRM_FWD_RESP     UINT32_C(0x24)
	/* HWRM Asynchronous Event Information */
	#define CMPL_BASE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
	/* CQ Notification */
	#define CMPL_BASE_TYPE_CQ_NOTIFICATION   UINT32_C(0x30)
	/* SRQ Threshold Event */
	#define CMPL_BASE_TYPE_SRQ_EVENT         UINT32_C(0x32)
	/* DBQ Threshold Event */
	#define CMPL_BASE_TYPE_DBQ_EVENT         UINT32_C(0x34)
	/* QP Async Notification */
	#define CMPL_BASE_TYPE_QP_EVENT          UINT32_C(0x38)
	/* Function Async Notification */
	#define CMPL_BASE_TYPE_FUNC_EVENT        UINT32_C(0x3a)
	#define CMPL_BASE_TYPE_LAST             CMPL_BASE_TYPE_FUNC_EVENT
	/* info1 is 16 b */
	uint16_t	info1;
	/* info2 is 32 b */
	uint32_t	info2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	uint32_t	info3_v;
	#define CMPL_BASE_V         UINT32_C(0x1)
	#define CMPL_BASE_INFO3_MASK UINT32_C(0xfffffffe)
	#define CMPL_BASE_INFO3_SFT 1
	/* info4 is 32 b */
	uint32_t	info4;
} __rte_packed;

/* tx_cmpl (size:128b/16B) */
struct tx_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define TX_CMPL_TYPE_MASK       UINT32_C(0x3f)
	#define TX_CMPL_TYPE_SFT        0
	/*
	 * TX L2 completion:
	 * Completion of TX packet. Length = 16B
	 */
	#define TX_CMPL_TYPE_TX_L2        UINT32_C(0x0)
	#define TX_CMPL_TYPE_LAST        TX_CMPL_TYPE_TX_L2
	#define TX_CMPL_FLAGS_MASK      UINT32_C(0xffc0)
	#define TX_CMPL_FLAGS_SFT       6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define TX_CMPL_FLAGS_ERROR      UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that the packet completed
	 * was transmitted using the push acceleration data provided
	 * by the driver. When this bit is '0', it indicates that the
	 * packet had not push acceleration data written or was executed
	 * as a normal packet even though push data was provided.
	 */
	#define TX_CMPL_FLAGS_PUSH       UINT32_C(0x80)
	/* unused1 is 16 b */
	uint16_t	unused_0;
	/*
	 * This is a copy of the opaque field from the first TX BD of this
	 * transmitted packet. Note that, if the packet was described by a short
	 * CSO or short CSO inline BD, then the 16-bit opaque field from the
	 * short CSO BD will appear in the bottom 16 bits of this field.
	 */
	uint32_t	opaque;
	uint16_t	errors_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define TX_CMPL_V                                  UINT32_C(0x1)
	#define TX_CMPL_ERRORS_MASK                        UINT32_C(0xfffe)
	#define TX_CMPL_ERRORS_SFT                         1
	/*
	 * This error indicates that there was some sort of problem
	 * with the BDs for the packet.
	 */
	#define TX_CMPL_ERRORS_BUFFER_ERROR_MASK            UINT32_C(0xe)
	#define TX_CMPL_ERRORS_BUFFER_ERROR_SFT             1
	/* No error */
	#define TX_CMPL_ERRORS_BUFFER_ERROR_NO_ERROR \
		(UINT32_C(0x0) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
	#define TX_CMPL_ERRORS_BUFFER_ERROR_BAD_FMT \
		(UINT32_C(0x2) << 1)
	#define TX_CMPL_ERRORS_BUFFER_ERROR_LAST \
		TX_CMPL_ERRORS_BUFFER_ERROR_BAD_FMT
	/*
	 * When this bit is '1', it indicates that the length of
	 * the packet was zero. No packet was transmitted.
	 */
	#define TX_CMPL_ERRORS_ZERO_LENGTH_PKT              UINT32_C(0x10)
	/*
	 * When this bit is '1', it indicates that the packet
	 * was longer than the programmed limit in TDI. No
	 * packet was transmitted.
	 */
	#define TX_CMPL_ERRORS_EXCESSIVE_BD_LENGTH          UINT32_C(0x20)
	/*
	 * When this bit is '1', it indicates that one or more of the
	 * BDs associated with this packet generated a PCI error.
	 * This probably means the address was not valid.
	 */
	#define TX_CMPL_ERRORS_DMA_ERROR                    UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that the packet was longer
	 * than indicated by the hint. No packet was transmitted.
	 */
	#define TX_CMPL_ERRORS_HINT_TOO_SHORT               UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates that the packet was
	 * dropped due to Poison TLP error on one or more of the
	 * TLPs in the PXP completion.
	 */
	#define TX_CMPL_ERRORS_POISON_TLP_ERROR             UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates that the packet was dropped
	 * due to a transient internal error in TDC. The packet or LSO can
	 * be retried and may transmit successfully on a subsequent attempt.
	 */
	#define TX_CMPL_ERRORS_INTERNAL_ERROR               UINT32_C(0x200)
	/*
	 * When this bit is '1', it was not possible to collect a timestamp
	 * for a PTP completion, in which case the timestamp_hi and
	 * timestamp_lo fields are invalid. When this bit is '0' for a PTP
	 * completion, the timestamp_hi and timestamp_lo fields are valid.
	 * RJRN will copy the value of this bit into the field of the same
	 * name in all TX completions, regardless of whether such completions
	 * are PTP completions or other TX completions.
	 */
	#define TX_CMPL_ERRORS_TIMESTAMP_INVALID_ERROR      UINT32_C(0x400)
	/* unused2 is 16 b */
	uint16_t	unused_1;
	/* unused3 is 32 b */
	uint32_t	unused_2;
} __rte_packed;

/* tx_cmpl_coal (size:128b/16B) */
struct tx_cmpl_coal {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define TX_CMPL_COAL_TYPE_MASK       UINT32_C(0x3f)
	#define TX_CMPL_COAL_TYPE_SFT        0
	/*
	 * TX L2 coalesced completion:
	 * Completion of TX packet. Length = 16B
	 */
	#define TX_CMPL_COAL_TYPE_TX_L2_COAL   UINT32_C(0x2)
	#define TX_CMPL_COAL_TYPE_LAST        TX_CMPL_COAL_TYPE_TX_L2_COAL
	#define TX_CMPL_COAL_FLAGS_MASK      UINT32_C(0xffc0)
	#define TX_CMPL_COAL_FLAGS_SFT       6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define TX_CMPL_COAL_FLAGS_ERROR      UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that the packet completed
	 * was transmitted using the push acceleration data provided
	 * by the driver. When this bit is '0', it indicates that the
	 * packet had not push acceleration data written or was executed
	 * as a normal packet even though push data was provided.
	 */
	#define TX_CMPL_COAL_FLAGS_PUSH       UINT32_C(0x80)
	/* unused1 is 16 b */
	uint16_t	unused_0;
	/*
	 * This is a copy of the opaque field from the first TX BD of the packet
	 * which corresponds with the reported sq_cons_idx. Note that, with
	 * coalesced completions, completions are generated for only some of the
	 * packets. The driver will see the opaque field for only those packets.
	 * Note that, if the packet was described by a short CSO or short CSO
	 * inline BD, then the 16-bit opaque field from the short CSO BD will
	 * appear in the bottom 16 bits of this field. For TX rings with
	 * completion coalescing enabled (which would use the coalesced
	 * completion record), it is suggested that the driver populate the
	 * opaque field to indicate the specific TX ring with which the
	 * completion is associated, then utilize the opaque and sq_cons_idx
	 * fields in the coalesced completion record to determine the specific
	 * packets that are to be completed on that ring.
	 */
	uint32_t	opaque;
	uint16_t	errors_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define TX_CMPL_COAL_V                                  UINT32_C(0x1)
	#define TX_CMPL_COAL_ERRORS_MASK \
		UINT32_C(0xfffe)
	#define TX_CMPL_COAL_ERRORS_SFT                         1
	/*
	 * This error indicates that there was some sort of problem
	 * with the BDs for the packet.
	 */
	#define TX_CMPL_COAL_ERRORS_BUFFER_ERROR_MASK            UINT32_C(0xe)
	#define TX_CMPL_COAL_ERRORS_BUFFER_ERROR_SFT             1
	/* No error */
	#define TX_CMPL_COAL_ERRORS_BUFFER_ERROR_NO_ERROR \
		(UINT32_C(0x0) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
	#define TX_CMPL_COAL_ERRORS_BUFFER_ERROR_BAD_FMT \
		(UINT32_C(0x2) << 1)
	#define TX_CMPL_COAL_ERRORS_BUFFER_ERROR_LAST \
		TX_CMPL_COAL_ERRORS_BUFFER_ERROR_BAD_FMT
	/*
	 * When this bit is '1', it indicates that the length of
	 * the packet was zero. No packet was transmitted.
	 */
	#define TX_CMPL_COAL_ERRORS_ZERO_LENGTH_PKT              UINT32_C(0x10)
	/*
	 * When this bit is '1', it indicates that the packet
	 * was longer than the programmed limit in TDI. No
	 * packet was transmitted.
	 */
	#define TX_CMPL_COAL_ERRORS_EXCESSIVE_BD_LENGTH          UINT32_C(0x20)
	/*
	 * When this bit is '1', it indicates that one or more of the
	 * BDs associated with this packet generated a PCI error.
	 * This probably means the address was not valid.
	 */
	#define TX_CMPL_COAL_ERRORS_DMA_ERROR                    UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that the packet was longer
	 * than indicated by the hint. No packet was transmitted.
	 */
	#define TX_CMPL_COAL_ERRORS_HINT_TOO_SHORT               UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates that the packet was
	 * dropped due to Poison TLP error on one or more of the
	 * TLPs in the PXP completion.
	 */
	#define TX_CMPL_COAL_ERRORS_POISON_TLP_ERROR \
		UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates that the packet was dropped
	 * due to a transient internal error in TDC. The packet or LSO can
	 * be retried and may transmit successfully on a subsequent attempt.
	 */
	#define TX_CMPL_COAL_ERRORS_INTERNAL_ERROR \
		UINT32_C(0x200)
	/*
	 * When this bit is '1', it was not possible to collect a a timestamp
	 * for a PTP completion, in which case the timestamp_hi and
	 * timestamp_lo fields are invalid. When this bit is '0' for a PTP
	 * completion, the timestamp_hi and timestamp_lo fields are valid.
	 * RJRN will copy the value of this bit into the field of the same
	 * name in all TX completions, regardless of whether such
	 * completions are PTP completions or other TX completions.
	 */
	#define TX_CMPL_COAL_ERRORS_TIMESTAMP_INVALID_ERROR \
		UINT32_C(0x400)
	/* unused2 is 16 b */
	uint16_t	unused_1;
	uint32_t	sq_cons_idx;
	/*
	 * This value is SQ index for the start of the packet following the
	 * last completed packet.
	 */
	#define TX_CMPL_COAL_SQ_CONS_IDX_MASK UINT32_C(0xffffff)
	#define TX_CMPL_COAL_SQ_CONS_IDX_SFT 0
} __rte_packed;

/* tx_cmpl_packet_timestamp (size:128b/16B) */
struct tx_cmpl_packet_timestamp {
	uint16_t	ts_sub_ns_flags_type;
	/*
	 * This field indicates the exact type of the completion. By
	 * convention, the LSB identifies the length of the record in 16B
	 * units. Even values indicate 16B records. Odd values indicate
	 * 32B records.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_TYPE_MASK             UINT32_C(0x3f)
	#define TX_CMPL_PACKET_TIMESTAMP_TYPE_SFT              0
	/*
	 * TX L2 Packet Timestamp completion:
	 * Completion of an L2 Packet Timestamp Packet. Length = 16B
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_TYPE_TX_L2_PKT_TS       UINT32_C(0x4)
	#define TX_CMPL_PACKET_TIMESTAMP_TYPE_LAST \
		TX_CMPL_PACKET_TIMESTAMP_TYPE_TX_L2_PKT_TS
	#define TX_CMPL_PACKET_TIMESTAMP_FLAGS_MASK            UINT32_C(0xfc0)
	#define TX_CMPL_PACKET_TIMESTAMP_FLAGS_SFT             6
	/*
	 * When this bit is '1', it indicates a packet that has an error
	 * of some type. Type of error is indicated in error_flags.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_FLAGS_ERROR            UINT32_C(0x40)
	/*
	 * This field indicates the TX packet timestamp type that is
	 * represented by a TX Packet Timestamp Completion. Note that
	 * this field is invalid if the timestamp_invalid_error flag
	 * is set.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_FLAGS_TS_TYPE          UINT32_C(0x80)
	/* The packet timestamp came from PM. */
	#define TX_CMPL_PACKET_TIMESTAMP_FLAGS_TS_TYPE_TS_PM \
		(UINT32_C(0x0) << 7)
	/* The packet timestamp came from PA. */
	#define TX_CMPL_PACKET_TIMESTAMP_FLAGS_TS_TYPE_TS_PA \
		(UINT32_C(0x1) << 7)
	#define TX_CMPL_PACKET_TIMESTAMP_FLAGS_TS_TYPE_LAST \
		TX_CMPL_PACKET_TIMESTAMP_FLAGS_TS_TYPE_TS_PA
	/*
	 * This flag indicates that the timestamp should have come from PM,
	 * but came instead from PA because all PM timestamp resources were
	 * in use. This can occur in the following circumstances:
	 * 1. The BD specified ts_2cmpl_auto and the packet was a PTP packet
	 *    but PA could not request a PM timestamp
	 * 2. The BD specified ts_2cmpl_pm, but PA could not request a PM
	 *    timestamp
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_FLAGS_TS_FALLBACK      UINT32_C(0x100)
	/*
	 * For 2-step PTP timestamps, bits[3:0] of this field represent the
	 * sub-nanosecond portion of the packet timestamp, returned from PM
	 * for 2-step PTP timestamps. For PA timestamps, this field also
	 * represents the sub-nanosecond portion of the packet timestamp;
	 * however, due to synchronization uncertainties, the accuracy of
	 * PA timestamps is limited to approximately +/- 4 ns. Therefore
	 * this field is of dubious value for PA timestamps.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_TS_SUB_NS_MASK        UINT32_C(0xf000)
	#define TX_CMPL_PACKET_TIMESTAMP_TS_SUB_NS_SFT         12
	/*
	 * This is bits [47:32] of the nanoseconds portion of the packet
	 * timestamp, returned from PM for 2-step PTP timestamps or from
	 * PA for PA timestamps. This field is in units of 2^32 ns.
	 */
	uint16_t	ts_ns_mid;
	/*
	 * This is a copy of the opaque field from the first TX BD of this
	 * transmitted packet. Note that, if the packet was described by a
	 * short CSO or short CSO inline BD, then the 16-bit opaque field
	 * from the short CSO BD will appear in the bottom 16 bits of this
	 * field.
	 */
	uint32_t	opaque;
	uint16_t	errors_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_V \
		UINT32_C(0x1)
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_MASK \
		UINT32_C(0xfffe)
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_SFT                         1
	/*
	 * This field was previously used to indicate fatal errors, which
	 * now result in aborting and bringing down the ring. This field
	 * is deprecated.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_BUFFER_ERROR_MASK \
		UINT32_C(0xe)
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_BUFFER_ERROR_SFT             1
	/* No error. */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_BUFFER_ERROR_NO_ERROR \
		(UINT32_C(0x0) << 1)
	/* Deprecated. */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_BUFFER_ERROR_BAD_FMT \
		(UINT32_C(0x2) << 1)
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_BUFFER_ERROR_LAST \
		TX_CMPL_PACKET_TIMESTAMP_ERRORS_BUFFER_ERROR_BAD_FMT
	/*
	 * This error is fatal and results in aborting and bringing down the
	 * ring, thus is deprecated.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_ZERO_LENGTH_PKT \
		UINT32_C(0x10)
	/*
	 * This error is fatal and results in aborting and bringing down the
	 * ring, thus is deprecated.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_EXCESSIVE_BD_LENGTH \
		UINT32_C(0x20)
	/*
	 * When this bit is '1', it indicates that one or more of the BDs
	 * associated with this packet generated a PCI error when accessing
	 * header/payload data from host memory. It most likely indicates
	 * that the address was not valid. Note that this bit has no meaning
	 * for the timestamp completion and will always be '0'.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_DMA_ERROR \
		UINT32_C(0x40)
	/*
	 * This error is fatal and results in aborting and bringing down the
	 * ring, thus is deprecated.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_HINT_TOO_SHORT \
		UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates that the packet was dropped
	 * due to Poison TLP error on one or more of the TLPs in one or more
	 * of the associated PXP completion(s) when accessing header/payload
	 * data from host memory. Note that this bit has no meaning for the
	 * timestamp completion, and will always be '0'.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_POISON_TLP_ERROR \
		UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates that the packet was dropped
	 * due to a transient internal error in TDC. The packet or LSO can
	 * be retried and may transmit successfully on a subsequent attempt.
	 * Note that this bit has no meaning for the timestamp completion
	 * and will always be '0'.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_INTERNAL_ERROR \
		UINT32_C(0x200)
	/*
	 * When this bit is '1', it was not possible to collect a timestamp
	 * for a timestamp completion, in which case the ts_ns and ts_sub_ns
	 * fields are invalid. When this bit is '0' in a timestamp
	 * completion record, the ts_sub_ns, ts_ns_lo, and ts_ns_mid fields
	 * are valid. Note that this bit has meaning only for the timestamp
	 * completion. For types other than the timestamp completion, this
	 * bit will always be '0'.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_TIMESTAMP_INVALID_ERROR \
		UINT32_C(0x400)
	/*
	 * When this bit is '1', it indicates that a Timed Transmit
	 * SO-TXTIME packet violated the max_ttx_overtime constraint i.e.,
	 * the time the packet was processed for transmission in TWE was
	 * later than the time given by (TimedTx_BD.tx_time +
	 * max_ttx_overtime) and as result, the packet was dropped.
	 * Note that max_ttx_overtime is a global configuration in TWE.
	 * Note that this bit has no meaning in a timestamp completion,
	 * and will always be '0'.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_TTX_OVERTIME_ERROR \
		UINT32_C(0x800)
	/* unused2 is 16 b */
	uint16_t	unused_2;
	/*
	 * This is bits [31:0] of the nanoseconds portion of the packet
	 * timestamp, returned from PM for 2-step PTP timestamp or from
	 * PA for PA timestamps. This field is in units of ns.
	 */
	uint32_t	ts_ns_lo;
} __rte_packed;

/* rx_pkt_cmpl (size:128b/16B) */
struct rx_pkt_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_PKT_CMPL_TYPE_MASK                      UINT32_C(0x3f)
	#define RX_PKT_CMPL_TYPE_SFT                       0
	/*
	 * RX L2 completion:
	 * Completion of and L2 RX packet. Length = 32B
	 */
	#define RX_PKT_CMPL_TYPE_RX_L2                       UINT32_C(0x11)
	#define RX_PKT_CMPL_TYPE_LAST \
		RX_PKT_CMPL_TYPE_RX_L2
	#define RX_PKT_CMPL_FLAGS_MASK                     UINT32_C(0xffc0)
	#define RX_PKT_CMPL_FLAGS_SFT                      6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define RX_PKT_CMPL_FLAGS_ERROR                     UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_PKT_CMPL_FLAGS_PLACEMENT_MASK            UINT32_C(0x380)
	#define RX_PKT_CMPL_FLAGS_PLACEMENT_SFT             7
	/*
	 * Normal:
	 * Packet was placed using normal algorithm.
	 */
	#define RX_PKT_CMPL_FLAGS_PLACEMENT_NORMAL \
		(UINT32_C(0x0) << 7)
	/*
	 * Jumbo:
	 * Packet was placed using jumbo algorithm.
	 */
	#define RX_PKT_CMPL_FLAGS_PLACEMENT_JUMBO \
		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
	#define RX_PKT_CMPL_FLAGS_PLACEMENT_HDS \
		(UINT32_C(0x2) << 7)
	#define RX_PKT_CMPL_FLAGS_PLACEMENT_LAST \
		RX_PKT_CMPL_FLAGS_PLACEMENT_HDS
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_PKT_CMPL_FLAGS_RSS_VALID                 UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory.
	 */
	#define RX_PKT_CMPL_FLAGS_PKT_METADATA_PRESENT      UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_PKT_CMPL_FLAGS_ITYPE_MASK                UINT32_C(0xf000)
	#define RX_PKT_CMPL_FLAGS_ITYPE_SFT                 12
	/*
	 * Not Known:
	 * Indicates that the packet type was not known.
	 */
	#define RX_PKT_CMPL_FLAGS_ITYPE_NOT_KNOWN \
		(UINT32_C(0x0) << 12)
	/*
	 * IP Packet:
	 * Indicates that the packet was an IP packet, but further
	 * classification was not possible.
	 */
	#define RX_PKT_CMPL_FLAGS_ITYPE_IP \
		(UINT32_C(0x1) << 12)
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 * This indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_CMPL_FLAGS_ITYPE_TCP \
		(UINT32_C(0x2) << 12)
	/*
	 * UDP Packet:
	 * Indicates that the packet was IP and UDP.
	 * This indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_CMPL_FLAGS_ITYPE_UDP \
		(UINT32_C(0x3) << 12)
	/*
	 * FCoE Packet:
	 * Indicates that the packet was recognized as a FCoE.
	 * This also indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_CMPL_FLAGS_ITYPE_FCOE \
		(UINT32_C(0x4) << 12)
	/*
	 * RoCE Packet:
	 * Indicates that the packet was recognized as a RoCE.
	 * This also indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_CMPL_FLAGS_ITYPE_ROCE \
		(UINT32_C(0x5) << 12)
	/*
	 * ICMP Packet:
	 * Indicates that the packet was recognized as ICMP.
	 * This indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_CMPL_FLAGS_ITYPE_ICMP \
		(UINT32_C(0x7) << 12)
	/*
	 * PTP packet wo/timestamp:
	 * Indicates that the packet was recognized as a PTP
	 * packet.
	 */
	#define RX_PKT_CMPL_FLAGS_ITYPE_PTP_WO_TIMESTAMP \
		(UINT32_C(0x8) << 12)
	/*
	 * PTP packet w/timestamp:
	 * Indicates that the packet was recognized as a PTP
	 * packet and that a timestamp was taken for the packet.
	 */
	#define RX_PKT_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP \
		(UINT32_C(0x9) << 12)
	#define RX_PKT_CMPL_FLAGS_ITYPE_LAST \
		RX_PKT_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP
	/*
	 * This is the length of the data for the packet stored in the
	 * buffer(s) identified by the opaque value. This includes
	 * the packet BD and any associated buffer BDs. This does not include
	 * the length of any data places in aggregation BDs.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	uint8_t	agg_bufs_v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_CMPL_V1           UINT32_C(0x1)
	/*
	 * This value is the number of aggregation buffers that follow this
	 * entry in the completion ring that are a part of this packet.
	 * If the value is zero, then the packet is completely contained
	 * in the buffer space provided for the packet in the RX ring.
	 */
	#define RX_PKT_CMPL_AGG_BUFS_MASK UINT32_C(0x3e)
	#define RX_PKT_CMPL_AGG_BUFS_SFT 1
	/* unused1 is 2 b */
	#define RX_PKT_CMPL_UNUSED1_MASK UINT32_C(0xc0)
	#define RX_PKT_CMPL_UNUSED1_SFT  6
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * Note that 4-tuples values listed below are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported and
	 * enabled for TCP traffic only, then the values of tuple_extract_op
	 * corresponding to 4-tuples are only valid for TCP traffic.
	 */
	uint8_t	rss_hash_type;
	/*
	 * The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 */
	#define RX_PKT_CMPL_RSS_HASH_TYPE_ENUM_0 UINT32_C(0x0)
	/*
	 * The RSS hash was computed over source IP address and destination
	 * IP address of inner IP header. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 */
	#define RX_PKT_CMPL_RSS_HASH_TYPE_ENUM_1 UINT32_C(0x1)
	/*
	 * The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 */
	#define RX_PKT_CMPL_RSS_HASH_TYPE_ENUM_2 UINT32_C(0x2)
	/*
	 * The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 */
	#define RX_PKT_CMPL_RSS_HASH_TYPE_ENUM_3 UINT32_C(0x3)
	#define RX_PKT_CMPL_RSS_HASH_TYPE_LAST \
		RX_PKT_CMPL_RSS_HASH_TYPE_ENUM_3
	/*
	 * This value indicates the offset in bytes from the beginning of the
	 * packet where the inner payload starts. This value is valid for TCP,
	 * UDP, FCoE, and RoCE packets.
	 *
	 * A value of zero indicates that header is 256B into the packet.
	 */
	uint8_t	payload_offset;
	/* unused2 is 8 b */
	uint8_t	unused1;
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC.
	 */
	uint32_t	rss_hash;
} __rte_packed;

/* Last 16 bytes of rx_pkt_cmpl. */
/* rx_pkt_cmpl_hi (size:128b/16B) */
struct rx_pkt_cmpl_hi {
	uint32_t	flags2;
	/*
	 * This indicates that the ip checksum was calculated for the
	 * inner packet and that the ip_cs_error field indicates if there
	 * was an error.
	 */
	#define RX_PKT_CMPL_FLAGS2_IP_CS_CALC                 UINT32_C(0x1)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was
	 * calculated for the inner packet and that the l4_cs_error field
	 * indicates if there was an error.
	 */
	#define RX_PKT_CMPL_FLAGS2_L4_CS_CALC                 UINT32_C(0x2)
	/*
	 * This indicates that the ip checksum was calculated for the
	 * tunnel header and that the t_ip_cs_error field indicates if there
	 * was an error.
	 */
	#define RX_PKT_CMPL_FLAGS2_T_IP_CS_CALC               UINT32_C(0x4)
	/*
	 * This indicates that the UDP checksum was
	 * calculated for the tunnel packet and that the t_l4_cs_error field
	 * indicates if there was an error.
	 */
	#define RX_PKT_CMPL_FLAGS2_T_L4_CS_CALC               UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_PKT_CMPL_FLAGS2_META_FORMAT_MASK           UINT32_C(0xf0)
	#define RX_PKT_CMPL_FLAGS2_META_FORMAT_SFT            4
	/* No metadata information. Value is zero. */
	#define RX_PKT_CMPL_FLAGS2_META_FORMAT_NONE \
		(UINT32_C(0x0) << 4)
	/*
	 * The metadata field contains the VLAN tag and TPID value.
	 * - metadata[11:0] contains the vlan VID value.
	 * - metadata[12] contains the vlan DE value.
	 * - metadata[15:13] contains the vlan PRI value.
	 * - metadata[31:16] contains the vlan TPID value.
	 */
	#define RX_PKT_CMPL_FLAGS2_META_FORMAT_VLAN \
		(UINT32_C(0x1) << 4)
	/*
	 * If ext_meta_format is equal to 1, the metadata field
	 * contains the lower 16b of the tunnel ID value, justified
	 * to LSB
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier.
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K = 0
	 * - IPV4 = 0 (not populated)
	 * - IPV6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
	#define RX_PKT_CMPL_FLAGS2_META_FORMAT_TUNNEL_ID \
		(UINT32_C(0x2) << 4)
	/*
	 * if ext_meta_format is equal to 1, metadata field contains
	 * 16b metadata from the prepended header (chdr_data).
	 */
	#define RX_PKT_CMPL_FLAGS2_META_FORMAT_CHDR_DATA \
		(UINT32_C(0x3) << 4)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the outer_l3_offset, inner_l2_offset, inner_l3_offset and
	 * inner_l4_size.
	 * - metadata[8:0] contains the outer_l3_offset.
	 * - metadata[17:9] contains the inner_l2_offset.
	 * - metadata[26:18] contains the inner_l3_offset.
	 * - metadata[31:27] contains the inner_l4_size.
	 */
	#define RX_PKT_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET \
		(UINT32_C(0x4) << 4)
	#define RX_PKT_CMPL_FLAGS2_META_FORMAT_LAST \
		RX_PKT_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define RX_PKT_CMPL_FLAGS2_IP_TYPE                    UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define RX_PKT_CMPL_FLAGS2_COMPLETE_CHECKSUM_CALC     UINT32_C(0x200)
	/*
	 * The combination of this value and meta_format indicated what
	 * format the metadata field is.
	 */
	#define RX_PKT_CMPL_FLAGS2_EXT_META_FORMAT_MASK       UINT32_C(0xc00)
	#define RX_PKT_CMPL_FLAGS2_EXT_META_FORMAT_SFT        10
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set.
	 */
	#define RX_PKT_CMPL_FLAGS2_COMPLETE_CHECKSUM_MASK \
		UINT32_C(0xffff0000)
	#define RX_PKT_CMPL_FLAGS2_COMPLETE_CHECKSUM_SFT      16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint32_t	metadata;
	/* When meta_format=1, this value is the VLAN VID. */
	#define RX_PKT_CMPL_METADATA_VID_MASK UINT32_C(0xfff)
	#define RX_PKT_CMPL_METADATA_VID_SFT  0
	/* When meta_format=1, this value is the VLAN DE. */
	#define RX_PKT_CMPL_METADATA_DE       UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define RX_PKT_CMPL_METADATA_PRI_MASK UINT32_C(0xe000)
	#define RX_PKT_CMPL_METADATA_PRI_SFT  13
	/* When meta_format=1, this value is the VLAN TPID. */
	#define RX_PKT_CMPL_METADATA_TPID_MASK UINT32_C(0xffff0000)
	#define RX_PKT_CMPL_METADATA_TPID_SFT 16
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_CMPL_V2 \
		UINT32_C(0x1)
	#define RX_PKT_CMPL_ERRORS_MASK \
		UINT32_C(0xfffe)
	#define RX_PKT_CMPL_ERRORS_SFT                               1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_MASK \
		UINT32_C(0xe)
	#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_SFT                   1
	/* No buffer error */
	#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER \
		(UINT32_C(0x0) << 1)
	/*
	 * Did Not Fit:
	 * Packet did not fit into packet buffer provided.
	 * For regular placement, this means the packet did not fit
	 * in the buffer provided. For HDS and jumbo placement, this
	 * means that the packet could not be placed into 7 physical
	 * buffers or less.
	 */
	#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_DID_NOT_FIT \
		(UINT32_C(0x1) << 1)
	/*
	 * Not On Chip:
	 * All BDs needed for the packet were not on-chip when
	 * the packet arrived.
	 */
	#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_NOT_ON_CHIP \
		(UINT32_C(0x2) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
	#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT \
		(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
	#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_FLUSH \
		(UINT32_C(0x5) << 1)
	#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_LAST \
		RX_PKT_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	/*
	 * This indicates that there was an error in the IP header
	 * checksum.
	 */
	#define RX_PKT_CMPL_ERRORS_IP_CS_ERROR \
		UINT32_C(0x10)
	/*
	 * This indicates that there was an error in the TCP, UDP
	 * or ICMP checksum.
	 */
	#define RX_PKT_CMPL_ERRORS_L4_CS_ERROR \
		UINT32_C(0x20)
	/*
	 * This indicates that there was an error in the tunnel
	 * IP header checksum.
	 */
	#define RX_PKT_CMPL_ERRORS_T_IP_CS_ERROR \
		UINT32_C(0x40)
	/*
	 * This indicates that there was an error in the tunnel
	 * UDP checksum.
	 */
	#define RX_PKT_CMPL_ERRORS_T_L4_CS_ERROR \
		UINT32_C(0x80)
	/*
	 * This indicates that there was a CRC error on either an FCoE
	 * or RoCE packet. The itype indicates the packet type.
	 */
	#define RX_PKT_CMPL_ERRORS_CRC_ERROR \
		UINT32_C(0x100)
	/*
	 * This indicates that there was an error in the tunnel
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_MASK \
		UINT32_C(0xe00)
	#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_SFT                    9
	/*
	 * No additional error occurred on the tunnel portion
	 * or the packet of the packet does not have a tunnel.
	 */
	#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_NO_ERROR \
		(UINT32_C(0x0) << 9)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6
	 * in the tunnel header.
	 */
	#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION \
		(UINT32_C(0x1) << 9)
	/*
	 * Indicates that header length is out of range in the
	 * tunnel header. Valid for
	 * IPv4.
	 */
	#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN \
		(UINT32_C(0x2) << 9)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the PPPoE header length for a tunnel PPPoE
	 * packet.
	 */
	#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_TUNNEL_TOTAL_ERROR \
		(UINT32_C(0x3) << 9)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the tunnel l3 header length. Valid for IPv4, or IPv6
	 * tunnel packet packets.
	 */
	#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR \
		(UINT32_C(0x4) << 9)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the tunnel UDP header length for a tunnel
	 * UDP packet that is not fragmented.
	 */
	#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR \
		(UINT32_C(0x5) << 9)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0) in the tunnel header. Valid
	 * for IPv4, and IPv6.
	 */
	#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL \
		(UINT32_C(0x6) << 9)
	#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_LAST \
		RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL
	/*
	 * This indicates that there was an error in the inner
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define RX_PKT_CMPL_ERRORS_PKT_ERROR_MASK \
		UINT32_C(0xf000)
	#define RX_PKT_CMPL_ERRORS_PKT_ERROR_SFT                      12
	/*
	 * No additional error occurred on the tunnel portion
	 * or the packet of the packet does not have a tunnel.
	 */
	#define RX_PKT_CMPL_ERRORS_PKT_ERROR_NO_ERROR \
		(UINT32_C(0x0) << 12)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6 or that
	 * option other than VFT was parsed on
	 * FCoE packet.
	 */
	#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L3_BAD_VERSION \
		(UINT32_C(0x1) << 12)
	/*
	 * indicates that header length is out of range. Valid for
	 * IPv4 and RoCE
	 */
	#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN \
		(UINT32_C(0x2) << 12)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0). Valid for IPv4, and IPv6
	 */
	#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L3_BAD_TTL \
		(UINT32_C(0x3) << 12)
	/*
	 * Indicates that physical packet is shorter than that
	 * claimed by the l3 header length. Valid for IPv4,
	 * IPv6 packet or RoCE packets.
	 */
	#define RX_PKT_CMPL_ERRORS_PKT_ERROR_IP_TOTAL_ERROR \
		(UINT32_C(0x4) << 12)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the UDP header length for a UDP packet that is
	 * not fragmented.
	 */
	#define RX_PKT_CMPL_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR \
		(UINT32_C(0x5) << 12)
	/*
	 * Indicates that TCP header length > IP payload. Valid for
	 * TCP packets only.
	 */
	#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN \
		(UINT32_C(0x6) << 12)
	/* Indicates that TCP header length < 5. Valid for TCP. */
	#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL \
		(UINT32_C(0x7) << 12)
	/*
	 * Indicates that TCP option headers result in a TCP header
	 * size that does not match data offset in TCP header. Valid
	 * for TCP.
	 */
	#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN \
		(UINT32_C(0x8) << 12)
	#define RX_PKT_CMPL_ERRORS_PKT_ERROR_LAST \
		RX_PKT_CMPL_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN
	/*
	 * This field identifies the CFA action rule that was used for this
	 * packet.
	 */
	uint16_t	cfa_code;
	uint32_t	reorder;
	/*
	 * This value holds the reordering sequence number for the packet.
	 * If the reordering sequence is not valid, then this value is zero.
	 * The reordering domain for the packet is in the bottom 8 to 10b of
	 * the rss_hash value. The bottom 20b of this value contain the
	 * ordering domain value for the packet.
	 */
	#define RX_PKT_CMPL_REORDER_MASK UINT32_C(0xffffff)
	#define RX_PKT_CMPL_REORDER_SFT 0
} __rte_packed;

/* rx_pkt_v2_cmpl (size:128b/16B) */
struct rx_pkt_v2_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_PKT_V2_CMPL_TYPE_MASK                      UINT32_C(0x3f)
	#define RX_PKT_V2_CMPL_TYPE_SFT                       0
	/*
	 * RX L2 V2 completion:
	 * Completion of and L2 RX packet. Length = 32B
	 * This is the new version of the RX_L2 completion used in SR2
	 * and later chips.
	 */
	#define RX_PKT_V2_CMPL_TYPE_RX_L2_V2                    UINT32_C(0xf)
	#define RX_PKT_V2_CMPL_TYPE_LAST \
		RX_PKT_V2_CMPL_TYPE_RX_L2_V2
	#define RX_PKT_V2_CMPL_FLAGS_MASK                     UINT32_C(0xffc0)
	#define RX_PKT_V2_CMPL_FLAGS_SFT                      6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_ERROR                     UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_MASK            UINT32_C(0x380)
	#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_SFT             7
	/*
	 * Normal:
	 * Packet was placed using normal algorithm.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_NORMAL \
		(UINT32_C(0x0) << 7)
	/*
	 * Jumbo:
	 * Packet was placed using jumbo algorithm.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_JUMBO \
		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_HDS \
		(UINT32_C(0x2) << 7)
	/*
	 * Truncation:
	 * Packet was placed using truncation algorithm. The
	 * placed (truncated) length is indicated in the payload_offset
	 * field. The original length is indicated in the len field.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_TRUNCATION \
		(UINT32_C(0x3) << 7)
	#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_LAST \
		RX_PKT_V2_CMPL_FLAGS_PLACEMENT_TRUNCATION
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_PKT_V2_CMPL_FLAGS_RSS_VALID                 UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory. Metadata starts at the first 32B boundary
	 * after the end of the packet for regular and jumbo placement.
	 * It starts at the first 32B boundary after the end of the header
	 * for HDS placement. The length of the metadata is indicated in the
	 * metadata itself.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_PKT_METADATA_PRESENT      UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_ITYPE_MASK                UINT32_C(0xf000)
	#define RX_PKT_V2_CMPL_FLAGS_ITYPE_SFT                 12
	/*
	 * Not Known:
	 * Indicates that the packet type was not known.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_ITYPE_NOT_KNOWN \
		(UINT32_C(0x0) << 12)
	/*
	 * IP Packet:
	 * Indicates that the packet was an IP packet, but further
	 * classification was not possible.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_ITYPE_IP \
		(UINT32_C(0x1) << 12)
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 * This indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_ITYPE_TCP \
		(UINT32_C(0x2) << 12)
	/*
	 * UDP Packet:
	 * Indicates that the packet was IP and UDP.
	 * This indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_ITYPE_UDP \
		(UINT32_C(0x3) << 12)
	/*
	 * FCoE Packet:
	 * Indicates that the packet was recognized as a FCoE.
	 * This also indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_ITYPE_FCOE \
		(UINT32_C(0x4) << 12)
	/*
	 * RoCE Packet:
	 * Indicates that the packet was recognized as a RoCE.
	 * This also indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_ITYPE_ROCE \
		(UINT32_C(0x5) << 12)
	/*
	 * ICMP Packet:
	 * Indicates that the packet was recognized as ICMP.
	 * This indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_ITYPE_ICMP \
		(UINT32_C(0x7) << 12)
	/*
	 * PTP packet wo/timestamp:
	 * Indicates that the packet was recognized as a PTP
	 * packet.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_ITYPE_PTP_WO_TIMESTAMP \
		(UINT32_C(0x8) << 12)
	/*
	 * PTP packet w/timestamp:
	 * Indicates that the packet was recognized as a PTP
	 * packet and that a timestamp was taken for the packet.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP \
		(UINT32_C(0x9) << 12)
	#define RX_PKT_V2_CMPL_FLAGS_ITYPE_LAST \
		RX_PKT_V2_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP
	/*
	 * This is the length of the data for the packet stored in the
	 * buffer(s) identified by the opaque value. This includes
	 * the packet BD and any associated buffer BDs. This does not include
	 * the length of any data places in aggregation BDs.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	uint8_t	agg_bufs_v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_V2_CMPL_V1           UINT32_C(0x1)
	/*
	 * This value is the number of aggregation buffers that follow this
	 * entry in the completion ring that are a part of this packet.
	 * If the value is zero, then the packet is completely contained
	 * in the buffer space provided for the packet in the RX ring.
	 */
	#define RX_PKT_V2_CMPL_AGG_BUFS_MASK UINT32_C(0x3e)
	#define RX_PKT_V2_CMPL_AGG_BUFS_SFT 1
	/* unused1 is 2 b */
	#define RX_PKT_V2_CMPL_UNUSED1_MASK UINT32_C(0xc0)
	#define RX_PKT_V2_CMPL_UNUSED1_SFT  6
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * Note that 4-tuples values listed below are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported and
	 * enabled for TCP traffic only, then the values of tuple_extract_op
	 * corresponding to 4-tuples are only valid for TCP traffic.
	 */
	uint8_t	rss_hash_type;
	/*
	 * The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 */
	#define RX_PKT_V2_CMPL_RSS_HASH_TYPE_ENUM_0 UINT32_C(0x0)
	/*
	 * The RSS hash was computed over source IP address and destination
	 * IP address of inner IP header. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 */
	#define RX_PKT_V2_CMPL_RSS_HASH_TYPE_ENUM_1 UINT32_C(0x1)
	/*
	 * The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 */
	#define RX_PKT_V2_CMPL_RSS_HASH_TYPE_ENUM_2 UINT32_C(0x2)
	/*
	 * The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 */
	#define RX_PKT_V2_CMPL_RSS_HASH_TYPE_ENUM_3 UINT32_C(0x3)
	#define RX_PKT_V2_CMPL_RSS_HASH_TYPE_LAST \
		RX_PKT_V2_CMPL_RSS_HASH_TYPE_ENUM_3
	uint16_t	metadata1_payload_offset;
	/*
	 * This is data from the CFA as indicated by the meta_format field.
	 * If truncation placement is not used, this value indicates the offset
	 * in bytes from the beginning of the packet where the inner payload
	 * starts. This value is valid for TCP, UDP, FCoE, and RoCE packets. If
	 * truncation placement is used, this value represents the placed
	 * (truncated) length of the packet.
	 */
	#define RX_PKT_V2_CMPL_PAYLOAD_OFFSET_MASK        UINT32_C(0x1ff)
	#define RX_PKT_V2_CMPL_PAYLOAD_OFFSET_SFT         0
	/* This is data from the CFA as indicated by the meta_format field. */
	#define RX_PKT_V2_CMPL_METADATA1_MASK             UINT32_C(0xf000)
	#define RX_PKT_V2_CMPL_METADATA1_SFT              12
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_MASK     UINT32_C(0x7000)
	#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_SFT      12
	/* 0x88a8 */
	#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPID88A8 \
		(UINT32_C(0x0) << 12)
	/* 0x8100 */
	#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPID8100 \
		(UINT32_C(0x1) << 12)
	/* 0x9100 */
	#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPID9100 \
		(UINT32_C(0x2) << 12)
	/* 0x9200 */
	#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPID9200 \
		(UINT32_C(0x3) << 12)
	/* 0x9300 */
	#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPID9300 \
		(UINT32_C(0x4) << 12)
	/* Value programmed in CFA VLANTPID register. */
	#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPIDCFG \
		(UINT32_C(0x5) << 12)
	#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_LAST \
		RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define RX_PKT_V2_CMPL_METADATA1_VALID             UINT32_C(0x8000)
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC. When vee_cmpl_mode
	 * is set in VNIC context, this is the lower 32b of the host address
	 * from the first BD used to place the packet.
	 */
	uint32_t	rss_hash;
} __rte_packed;

/* Last 16 bytes of RX Packet V2 Completion Record */
/* rx_pkt_v2_cmpl_hi (size:128b/16B) */
struct rx_pkt_v2_cmpl_hi {
	uint32_t	flags2;
	/*
	 * When this bit is '0', the cs_ok field has the following definition:-
	 * ip_cs_ok[2:0] = The number of header groups with a valid IP checksum
	 * in the delivered packet, counted from the outer-most header group to
	 * the inner-most header group, stopping at the first error. -
	 * l4_cs_ok[5:3] = The number of header groups with a valid L4 checksum
	 * in the delivered packet, counted from the outer-most header group to
	 * the inner-most header group, stopping at the first error. When this
	 * bit is '1', the cs_ok field has the following definition: -
	 * hdr_cnt[2:0] = The number of header groups that were parsed by the
	 * chip and passed in the delivered packet. - ip_cs_all_ok[3] =This bit
	 * will be '1' if all the parsed header groups with an IP checksum are
	 * valid. - l4_cs_all_ok[4] = This bit will be '1' if all the parsed
	 * header groups with an L4 checksum are valid.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_CS_ALL_OK_MODE \
		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_MASK \
		UINT32_C(0xf0)
	#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_SFT            4
	/* There is no metadata information. Values are zero. */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_NONE \
		(UINT32_C(0x0) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information: - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],
	 * de, vid[11:0]} The metadata2 field contains the table scope
	 * and action record pointer. - metadata2[25:0] contains the
	 * action record pointer. - metadata2[31:26] contains the table
	 * scope.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_ACT_REC_PTR \
		(UINT32_C(0x1) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB.
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_TUNNEL_ID \
		(UINT32_C(0x2) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 * The metadata2 field contains the 32b metadata from the prepended
	 * header (chdr_data).
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_CHDR_DATA \
		(UINT32_C(0x3) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the outer_l3_offset,
	 * inner_l2_offset, inner_l3_offset, and inner_l4_size.
	 * - metadata2[8:0] contains the outer_l3_offset.
	 * - metadata2[17:9] contains the inner_l2_offset.
	 * - metadata2[26:18] contains the inner_l3_offset.
	 * - metadata2[31:27] contains the inner_l4_size.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_HDR_OFFSET \
		(UINT32_C(0x4) << 4)
	#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_LAST \
		RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_IP_TYPE \
		UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_COMPLETE_CHECKSUM_CALC \
		UINT32_C(0x200)
	/*
	 * This field indicates the status of IP and L4 CS calculations done
	 * by the chip. The format of this field is indicated by the
	 * cs_all_ok_mode bit.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_CS_OK_MASK \
		UINT32_C(0xfc00)
	#define RX_PKT_V2_CMPL_HI_FLAGS2_CS_OK_SFT                  10
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_COMPLETE_CHECKSUM_MASK \
		UINT32_C(0xffff0000)
	#define RX_PKT_V2_CMPL_HI_FLAGS2_COMPLETE_CHECKSUM_SFT      16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 * - meta_format 0 - none - metadata2 = 0 - not valid/not stripped
	 * - meta_format 1 - act_rec_ptr - metadata2 = {table_scope[5:0],
	 *   act_rec_ptr[25:0]}
	 * - meta_format 2 - tunnel_id - metadata2 = tunnel_id[31:0]
	 * - meta_format 3 - chdr_data - metadata2 = updated_chdr_data[31:0]
	 * - meta_format 4 - hdr_offsets - metadata2 = hdr_offsets[31:0]
	 * When vee_cmpl_mode is set in VNIC context, this is the upper 32b
	 * of the host address from the first BD used to place the packet.
	 */
	uint32_t	metadata2;
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_V2_CMPL_HI_V2 \
		UINT32_C(0x1)
	#define RX_PKT_V2_CMPL_HI_ERRORS_MASK \
		UINT32_C(0xfffe)
	#define RX_PKT_V2_CMPL_HI_ERRORS_SFT                               1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_MASK \
		UINT32_C(0xe)
	#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_SFT                   1
	/* No buffer error */
	#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_NO_BUFFER \
		(UINT32_C(0x0) << 1)
	/*
	 * Did Not Fit: Packet did not fit into packet buffer provided.
	 * For regular placement, this means the packet did not fit in
	 * the buffer provided. For HDS and jumbo placement, this means
	 * that the packet could not be placed into 8 physical buffers
	 * (if fixed-size buffers are used), or that the packet could
	 * not be placed in the number of physical buffers configured
	 * for the VNIC (if variable-size buffers are used)
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_DID_NOT_FIT \
		(UINT32_C(0x1) << 1)
	/*
	 * Not On Chip: All BDs needed for the packet were not on-chip
	 * when the packet arrived. For regular placement, this error is
	 * not valid. For HDS and jumbo placement, this means that not
	 * enough agg BDs were posted to place the packet.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_NOT_ON_CHIP \
		(UINT32_C(0x2) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_BAD_FORMAT \
		(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_FLUSH \
		(UINT32_C(0x5) << 1)
	#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_LAST \
		RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_FLUSH
	/*
	 * This indicates that there was an error in the outer tunnel
	 * portion of the packet when this field is non-zero.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_MASK \
		UINT32_C(0x70)
	#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_SFT                   4
	/*
	 * No additional error occurred on the outer tunnel portion
	 * of the packet or the packet does not have a outer tunnel.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_NO_ERROR \
		(UINT32_C(0x0) << 4)
	/*
	 * Indicates that IP header version does not match expectation
	 * from L2 Ethertype for IPv4 and IPv6 in the outer tunnel header.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_L3_BAD_VERSION \
		(UINT32_C(0x1) << 4)
	/*
	 * Indicates that header length is out of range in the outer
	 * tunnel header. Valid for IPv4.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_L3_BAD_HDR_LEN \
		(UINT32_C(0x2) << 4)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the outer tunnel l3 header length. Valid for IPv4, or
	 * IPv6 outer tunnel packets.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_IP_TOTAL_ERROR \
		(UINT32_C(0x3) << 4)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the outer tunnel UDP header length for a outer
	 * tunnel UDP packet that is not fragmented.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_UDP_TOTAL_ERROR \
		(UINT32_C(0x4) << 4)
	/*
	 * Indicates that the IPv4 TTL or IPv6 hop limit check have
	 * failed (e.g. TTL = 0) in the outer tunnel header. Valid for
	 * IPv4, and IPv6.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_L3_BAD_TTL \
		(UINT32_C(0x5) << 4)
	/*
	 * Indicates that the IP checksum failed its check in the outer
	 * tunnel header.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_IP_CS_ERROR \
		(UINT32_C(0x6) << 4)
	/*
	 * Indicates that the L4 checksum failed its check in the outer
	 * tunnel header.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_L4_CS_ERROR \
		(UINT32_C(0x7) << 4)
	#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_LAST \
		RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_L4_CS_ERROR
	/*
	 * This indicates that there was a CRC error on either an FCoE
	 * or RoCE packet. The itype indicates the packet type.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_CRC_ERROR \
		UINT32_C(0x100)
	/*
	 * This indicates that there was an error in the tunnel portion
	 * of the packet when this field is non-zero.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_MASK \
		UINT32_C(0xe00)
	#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_SFT                    9
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet or the packet does not have a tunnel.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_NO_ERROR \
		(UINT32_C(0x0) << 9)
	/*
	 * Indicates that IP header version does not match expectation
	 * from L2 Ethertype for IPv4 and IPv6 in the tunnel header.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION \
		(UINT32_C(0x1) << 9)
	/*
	 * Indicates that header length is out of range in the tunnel
	 * header. Valid for IPv4.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN \
		(UINT32_C(0x2) << 9)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the tunnel l3 header length. Valid for IPv4, or IPv6 tunnel
	 * packet packets.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR \
		(UINT32_C(0x3) << 9)
	/*
	 * Indicates that the physical packet is shorter than that claimed
	 * by the tunnel UDP header length for a tunnel UDP packet that is
	 * not fragmented.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR \
		(UINT32_C(0x4) << 9)
	/*
	 * Indicates that the IPv4 TTL or IPv6 hop limit check have failed
	 * (e.g. TTL = 0) in the tunnel header. Valid for IPv4, and IPv6.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL \
		(UINT32_C(0x5) << 9)
	/*
	 * Indicates that the IP checksum failed its check in the tunnel
	 * header.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_IP_CS_ERROR \
		(UINT32_C(0x6) << 9)
	/*
	 * Indicates that the L4 checksum failed its check in the tunnel
	 * header.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_L4_CS_ERROR \
		(UINT32_C(0x7) << 9)
	#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_LAST \
		RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_L4_CS_ERROR
	/*
	 * This indicates that there was an error in the inner
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_MASK \
		UINT32_C(0xf000)
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_SFT                      12
	/*
	 * No additional error occurred on the tunnel portion
	 * or the packet of the packet does not have a tunnel.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_NO_ERROR \
		(UINT32_C(0x0) << 12)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6 or that
	 * option other than VFT was parsed on
	 * FCoE packet.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L3_BAD_VERSION \
		(UINT32_C(0x1) << 12)
	/*
	 * indicates that header length is out of range. Valid for
	 * IPv4 and RoCE
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN \
		(UINT32_C(0x2) << 12)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0). Valid for IPv4, and IPv6
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L3_BAD_TTL \
		(UINT32_C(0x3) << 12)
	/*
	 * Indicates that physical packet is shorter than that
	 * claimed by the l3 header length. Valid for IPv4,
	 * IPv6 packet or RoCE packets.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_IP_TOTAL_ERROR \
		(UINT32_C(0x4) << 12)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the UDP header length for a UDP packet that is
	 * not fragmented.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR \
		(UINT32_C(0x5) << 12)
	/*
	 * Indicates that TCP header length > IP payload. Valid for
	 * TCP packets only.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN \
		(UINT32_C(0x6) << 12)
	/* Indicates that TCP header length < 5. Valid for TCP. */
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL \
		(UINT32_C(0x7) << 12)
	/*
	 * Indicates that TCP option headers result in a TCP header
	 * size that does not match data offset in TCP header. Valid
	 * for TCP.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN \
		(UINT32_C(0x8) << 12)
	/*
	 * Indicates that the IP checksum failed its check in the
	 * inner header.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_IP_CS_ERROR \
		(UINT32_C(0x9) << 12)
	/*
	 * Indicates that the L4 checksum failed its check in the
	 * inner header.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L4_CS_ERROR \
		(UINT32_C(0xa) << 12)
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_LAST \
		RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L4_CS_ERROR
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint16_t	metadata0;
	/* When meta_format=1, this value is the VLAN VID. */
	#define RX_PKT_V2_CMPL_HI_METADATA0_VID_MASK UINT32_C(0xfff)
	#define RX_PKT_V2_CMPL_HI_METADATA0_VID_SFT 0
	/* When meta_format=1, this value is the VLAN DE. */
	#define RX_PKT_V2_CMPL_HI_METADATA0_DE      UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define RX_PKT_V2_CMPL_HI_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define RX_PKT_V2_CMPL_HI_METADATA0_PRI_SFT 13
	/*
	 * The timestamp field contains the 32b timestamp for the packet from
	 * the MAC.
	 */
	uint32_t	timestamp;
} __rte_packed;

/* rx_pkt_v3_cmpl (size:128b/16B) */
struct rx_pkt_v3_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_PKT_V3_CMPL_TYPE_MASK                      UINT32_C(0x3f)
	#define RX_PKT_V3_CMPL_TYPE_SFT                       0
	/*
	 * RX L2 V3 completion:
	 * Completion of and L2 RX packet. Length = 32B
	 * This is the new version of the RX_L2 completion used in Thor2
	 * and later chips.
	 */
	#define RX_PKT_V3_CMPL_TYPE_RX_L2_V3                    UINT32_C(0x17)
	#define RX_PKT_V3_CMPL_TYPE_LAST \
		RX_PKT_V3_CMPL_TYPE_RX_L2_V3
	#define RX_PKT_V3_CMPL_FLAGS_MASK                     UINT32_C(0xffc0)
	#define RX_PKT_V3_CMPL_FLAGS_SFT                      6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_ERROR                     UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_PKT_V3_CMPL_FLAGS_PLACEMENT_MASK            UINT32_C(0x380)
	#define RX_PKT_V3_CMPL_FLAGS_PLACEMENT_SFT             7
	/*
	 * Normal:
	 * Packet was placed using normal algorithm.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_PLACEMENT_NORMAL \
		(UINT32_C(0x0) << 7)
	/*
	 * Jumbo:
	 * Packet was placed using jumbo algorithm.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_PLACEMENT_JUMBO \
		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_PLACEMENT_HDS \
		(UINT32_C(0x2) << 7)
	/*
	 * Truncation:
	 * Packet was placed using truncation algorithm. The
	 * placed (truncated) length is indicated in the payload_offset
	 * field. The original length is indicated in the len field.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_PLACEMENT_TRUNCATION \
		(UINT32_C(0x3) << 7)
	#define RX_PKT_V3_CMPL_FLAGS_PLACEMENT_LAST \
		RX_PKT_V3_CMPL_FLAGS_PLACEMENT_TRUNCATION
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_PKT_V3_CMPL_FLAGS_RSS_VALID                 UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory. Metadata starts at the first 32B boundary
	 * after the end of the packet for regular and jumbo placement.
	 * It starts at the first 32B boundary after the end of the header
	 * for HDS placement. The length of the metadata is indicated in the
	 * metadata itself.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_PKT_METADATA_PRESENT      UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_ITYPE_MASK                UINT32_C(0xf000)
	#define RX_PKT_V3_CMPL_FLAGS_ITYPE_SFT                 12
	/*
	 * Not Known:
	 * Indicates that the packet type was not known.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_ITYPE_NOT_KNOWN \
		(UINT32_C(0x0) << 12)
	/*
	 * IP Packet:
	 * Indicates that the packet was an IP packet, but further
	 * classification was not possible.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_ITYPE_IP \
		(UINT32_C(0x1) << 12)
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 * This indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_ITYPE_TCP \
		(UINT32_C(0x2) << 12)
	/*
	 * UDP Packet:
	 * Indicates that the packet was IP and UDP.
	 * This indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_ITYPE_UDP \
		(UINT32_C(0x3) << 12)
	/*
	 * FCoE Packet:
	 * Indicates that the packet was recognized as a FCoE.
	 * This also indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_ITYPE_FCOE \
		(UINT32_C(0x4) << 12)
	/*
	 * RoCE Packet:
	 * Indicates that the packet was recognized as a RoCE.
	 * This also indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_ITYPE_ROCE \
		(UINT32_C(0x5) << 12)
	/*
	 * ICMP Packet:
	 * Indicates that the packet was recognized as ICMP.
	 * This indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_ITYPE_ICMP \
		(UINT32_C(0x7) << 12)
	/*
	 * PTP packet wo/timestamp:
	 * Indicates that the packet was recognized as a PTP
	 * packet.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_ITYPE_PTP_WO_TIMESTAMP \
		(UINT32_C(0x8) << 12)
	/*
	 * PTP packet w/timestamp:
	 * Indicates that the packet was recognized as a PTP
	 * packet and that a timestamp was taken for the packet.
	 * The 4b sub-nanosecond portion of the timestamp is in
	 * the payload_offset field.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP \
		(UINT32_C(0x9) << 12)
	#define RX_PKT_V3_CMPL_FLAGS_ITYPE_LAST \
		RX_PKT_V3_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP
	/*
	 * This is the length of the data for the packet stored in the
	 * buffer(s) identified by the opaque value. This includes
	 * the packet BD and any associated buffer BDs. This does not include
	 * the length of any data places in aggregation BDs.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	uint16_t	rss_hash_type_agg_bufs_v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_V3_CMPL_V1                   UINT32_C(0x1)
	/*
	 * This value is the number of aggregation buffers that follow this
	 * entry in the completion ring that are a part of this packet.
	 * If the value is zero, then the packet is completely contained
	 * in the buffer space provided for the packet in the RX ring.
	 */
	#define RX_PKT_V3_CMPL_AGG_BUFS_MASK        UINT32_C(0x3e)
	#define RX_PKT_V3_CMPL_AGG_BUFS_SFT         1
	/* unused1 is 1 b */
	#define RX_PKT_V3_CMPL_UNUSED1              UINT32_C(0x40)
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * Note that 4-tuples values listed below are applicable
	 * for layer 4 protocols supported and enabled for RSS in the
	 * hardware, HWRM firmware, and drivers. For example, if RSS hash
	 * is supported and enabled for TCP traffic only, then the values of
	 * tuple_extract_op corresponding to 4-tuples are only valid for
	 * TCP traffic.
	 */
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_MASK   UINT32_C(0xff80)
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_SFT    7
	/*
	 * The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * inner IP and TCP or UDP headers.
	 */
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_0   (UINT32_C(0x0) << 7)
	/*
	 * The RSS hash was computed over source IP address and
	 * destination IP address of inner IP header.
	 */
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_1   (UINT32_C(0x1) << 7)
	/*
	 * The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 */
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_2   (UINT32_C(0x2) << 7)
	/*
	 * The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 */
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_3   (UINT32_C(0x3) << 7)
	/*
	 * The RSS hash was computed over source IP address of the inner
	 * IP header.
	 */
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_4   (UINT32_C(0x4) << 7)
	/*
	 * The RSS hash was computed over destination IP address of the
	 * inner IP header.
	 */
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_5   (UINT32_C(0x5) << 7)
	/*
	 * The RSS hash was computed over source IP address of the outer
	 * IP header.
	 * Note: For non-tunneled packets, this value is not applicable.
	 */
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_6   (UINT32_C(0x6) << 7)
	/*
	 * The RSS hash was computed over destination IP address of the
	 * outer IP header.
	 * Note: For non-tunneled packets, this value is not applicable.
	 */
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_7   (UINT32_C(0x7) << 7)
	/*
	 * The RSS hash was computed over source IP address, destination
	 * IP address, and flow label of the inner IP header.
	 * Note: For packets without an inner IPv6 header, this value is not
	 * this value is not applicable.
	 */
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_8   (UINT32_C(0x8) << 7)
	/*
	 * The RSS hash was computed over the flow label of the inner
	 * IP header.
	 * Note: For packets without an inner IPv6 header, this value
	 * is not applicable.
	 */
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_9   (UINT32_C(0x9) << 7)
	/*
	 * The RSS hash was computed over source IP address, destination
	 * IP address, and flow label of the outer IP header.
	 * Note: For packets without an outer IPv6 header, this value is not
	 * applicable.
	 */
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_10  (UINT32_C(0xa) << 7)
	/*
	 * The RSS hash was computed over the flow label of the outer
	 * IP header.
	 * Note: For packets without an outer IPv6 header, this value
	 * is not applicable.
	 */
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_11  (UINT32_C(0xb) << 7)
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_LAST \
		RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_11
	uint16_t	metadata1_payload_offset;
	/*
	 * If truncation placement is not used, this value indicates the offset
	 * in bytes from the beginning of the packet where the inner payload
	 * starts. This value is valid for TCP, UDP, FCoE, and RoCE packets.
	 * For PTP packets with timestamp (as indicated by the flags_itype
	 * field), this field contains the 4b sub-nanosecond portion of the
	 * timestamp.
	 *
	 * If truncation placement is used, this value represents the placed
	 * (truncated) length of the packet.
	 */
	#define RX_PKT_V3_CMPL_PAYLOAD_OFFSET_MASK        UINT32_C(0x1ff)
	#define RX_PKT_V3_CMPL_PAYLOAD_OFFSET_SFT         0
	/* This is data from the CFA as indicated by the meta_format field. */
	#define RX_PKT_V3_CMPL_METADATA1_MASK             UINT32_C(0xf000)
	#define RX_PKT_V3_CMPL_METADATA1_SFT              12
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_MASK     UINT32_C(0x7000)
	#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_SFT      12
	/* 0x88a8 */
	#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_TPID88A8 \
		(UINT32_C(0x0) << 12)
	/* 0x8100 */
	#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_TPID8100 \
		(UINT32_C(0x1) << 12)
	/* 0x9100 */
	#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_TPID9100 \
		(UINT32_C(0x2) << 12)
	/* 0x9200 */
	#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_TPID9200 \
		(UINT32_C(0x3) << 12)
	/* 0x9300 */
	#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_TPID9300 \
		(UINT32_C(0x4) << 12)
	/* Value programmed in CFA VLANTPID register. */
	#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_TPIDCFG \
		(UINT32_C(0x5) << 12)
	#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_LAST \
		RX_PKT_V3_CMPL_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define RX_PKT_V3_CMPL_METADATA1_VALID             UINT32_C(0x8000)
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC. When hairpin_en
	 * is set in VNIC context, this is the lower 32b of the host address
	 * from the first BD used to place the packet.
	 */
	uint32_t	rss_hash;
} __rte_packed;

/* Last 16 bytes of RX Packet V3 Completion Record */
/* rx_pkt_v3_cmpl_hi (size:128b/16B) */
struct rx_pkt_v3_cmpl_hi {
	uint32_t	flags2;
	/*
	 * This indicates that the ip checksum was calculated for the inner
	 * packet and that the ip_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_IP_CS_CALC \
		UINT32_C(0x1)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was calculated
	 * for the inner packet and that the l4_cs_error field indicates if
	 * there was an error.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_L4_CS_CALC \
		UINT32_C(0x2)
	/*
	 * This indicates that the ip checksum was calculated for the tunnel
	 * header and that the t_ip_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_T_IP_CS_CALC \
		UINT32_C(0x4)
	/*
	 * This indicates that the UDP checksum was calculated for the tunnel
	 * packet and that the t_l4_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_T_L4_CS_CALC \
		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_MASK \
		UINT32_C(0xf0)
	#define RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_SFT            4
	/* There is no metadata information. Values are zero. */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_NONE \
		(UINT32_C(0x0) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information: - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],
	 * de, vid[11:0]} The metadata2 field contains the table scope
	 * and action record pointer. - metadata2[25:0] contains the
	 * action record pointer. - metadata2[31:26] contains the table
	 * scope.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_ACT_REC_PTR \
		(UINT32_C(0x1) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB.
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_TUNNEL_ID \
		(UINT32_C(0x2) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 * The metadata2 field contains the 32b metadata from the prepended
	 * header (chdr_data).
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_CHDR_DATA \
		(UINT32_C(0x3) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the outer_l3_offset,
	 * inner_l2_offset, inner_l3_offset, and inner_l4_size.
	 * - metadata2[8:0] contains the outer_l3_offset.
	 * - metadata2[17:9] contains the inner_l2_offset.
	 * - metadata2[26:18] contains the inner_l3_offset.
	 * - metadata2[31:27] contains the inner_l4_size.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_HDR_OFFSET \
		(UINT32_C(0x4) << 4)
	#define RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_LAST \
		RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_IP_TYPE \
		UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_COMPLETE_CHECKSUM_CALC \
		UINT32_C(0x200)
	/*
	 * This field indicates the status of IP and L4 CS calculations done
	 * by the chip. The format of this field is indicated by the
	 * cs_all_ok_mode bit.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_T_IP_TYPE \
		UINT32_C(0x400)
	/* Indicates that the Tunnel IP type was IPv4 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_T_IP_TYPE_IPV4 \
		(UINT32_C(0x0) << 10)
	/* Indicates that the Tunnel IP type was IPv6 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_T_IP_TYPE_IPV6 \
		(UINT32_C(0x1) << 10)
	#define RX_PKT_V3_CMPL_HI_FLAGS2_T_IP_TYPE_LAST \
		RX_PKT_V3_CMPL_HI_FLAGS2_T_IP_TYPE_IPV6
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_COMPLETE_CHECKSUM_MASK \
		UINT32_C(0xffff0000)
	#define RX_PKT_V3_CMPL_HI_FLAGS2_COMPLETE_CHECKSUM_SFT      16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 * - meta_format 0 - none - metadata2 = 0 - not valid/not stripped
	 * - meta_format 1 - act_rec_ptr - metadata2 = {table_scope[5:0],
	 *   act_rec_ptr[25:0]}
	 * - meta_format 2 - tunnel_id - metadata2 = tunnel_id[31:0]
	 * - meta_format 3 - chdr_data - metadata2 = updated_chdr_data[31:0]
	 * - meta_format 4 - hdr_offsets - metadata2 = hdr_offsets[31:0]
	 */
	uint32_t	metadata2;
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_V3_CMPL_HI_V2 \
		UINT32_C(0x1)
	#define RX_PKT_V3_CMPL_HI_ERRORS_MASK \
		UINT32_C(0xfffe)
	#define RX_PKT_V3_CMPL_HI_ERRORS_SFT                               1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_MASK \
		UINT32_C(0xe)
	#define RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_SFT                   1
	/* No buffer error */
	#define RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_NO_BUFFER \
		(UINT32_C(0x0) << 1)
	/*
	 * Did Not Fit: Packet did not fit into packet buffer provided.
	 * For regular placement, this means the packet did not fit in
	 * the buffer provided. For HDS and jumbo placement, this means
	 * that the packet could not be placed into 8 physical buffers.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_DID_NOT_FIT \
		(UINT32_C(0x1) << 1)
	/*
	 * Not On Chip: All BDs needed for the packet were not on-chip
	 * when the packet arrived. For regular placement, this error is
	 * not valid. For HDS and jumbo placement, this means that not
	 * enough agg BDs were posted to place the packet.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_NOT_ON_CHIP \
		(UINT32_C(0x2) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_BAD_FORMAT \
		(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_FLUSH \
		(UINT32_C(0x5) << 1)
	#define RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_LAST \
		RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_FLUSH
	/* This indicates that there was an error in the IP header checksum. */
	#define RX_PKT_V3_CMPL_HI_ERRORS_IP_CS_ERROR \
		UINT32_C(0x10)
	/*
	 * This indicates that there was an error in the TCP, UDP or ICMP
	 * checksum.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_L4_CS_ERROR \
		UINT32_C(0x20)
	/*
	 * This indicates that there was an error in the tunnel IP header
	 * checksum.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_IP_CS_ERROR \
		UINT32_C(0x40)
	/* This indicates that there was an error in the tunnel UDP checksum. */
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_L4_CS_ERROR \
		UINT32_C(0x80)
	/*
	 * This indicates that there was a CRC error on either an FCoE
	 * or RoCE packet. The itype indicates the packet type.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_CRC_ERROR \
		UINT32_C(0x100)
	/*
	 * This indicates that there was an error in the tunnel portion
	 * of the packet when this field is non-zero.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_MASK \
		UINT32_C(0xe00)
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_SFT                    9
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet or the packet does not have a tunnel.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_NO_ERROR \
		(UINT32_C(0x0) << 9)
	/*
	 * Indicates that IP header version does not match expectation
	 * from L2 Ethertype for IPv4 and IPv6 in the tunnel header.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION \
		(UINT32_C(0x1) << 9)
	/*
	 * Indicates that header length is out of range in the tunnel
	 * header. Valid for IPv4.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN \
		(UINT32_C(0x2) << 9)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the tunnel l3 header length. Valid for IPv4, or IPv6 tunnel
	 * packet packets.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR \
		(UINT32_C(0x3) << 9)
	/*
	 * Indicates that the physical packet is shorter than that claimed
	 * by the tunnel UDP header length for a tunnel UDP packet that is
	 * not fragmented.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR \
		(UINT32_C(0x4) << 9)
	/*
	 * Indicates that the IPv4 TTL or IPv6 hop limit check have failed
	 * (e.g. TTL = 0) in the tunnel header. Valid for IPv4, and IPv6.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL \
		(UINT32_C(0x5) << 9)
	/*
	 * Indicates that the IP checksum failed its check in the tunnel
	 * header.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_T_IP_CS_ERROR \
		(UINT32_C(0x6) << 9)
	/*
	 * Indicates that the L4 checksum failed its check in the tunnel
	 * header.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_T_L4_CS_ERROR \
		(UINT32_C(0x7) << 9)
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_LAST \
		RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_T_L4_CS_ERROR
	/*
	 * This indicates that there was an error in the inner
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_MASK \
		UINT32_C(0xf000)
	#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_SFT                      12
	/*
	 * No additional error occurred on the tunnel portion
	 * or the packet of the packet does not have a tunnel.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_NO_ERROR \
		(UINT32_C(0x0) << 12)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6 or that
	 * option other than VFT was parsed on
	 * FCoE packet.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_L3_BAD_VERSION \
		(UINT32_C(0x1) << 12)
	/*
	 * indicates that header length is out of range. Valid for
	 * IPv4 and RoCE
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN \
		(UINT32_C(0x2) << 12)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0). Valid for IPv4, and IPv6
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_L3_BAD_TTL \
		(UINT32_C(0x3) << 12)
	/*
	 * Indicates that physical packet is shorter than that
	 * claimed by the l3 header length. Valid for IPv4,
	 * IPv6 packet or RoCE packets.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_IP_TOTAL_ERROR \
		(UINT32_C(0x4) << 12)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the UDP header length for a UDP packet that is
	 * not fragmented.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR \
		(UINT32_C(0x5) << 12)
	/*
	 * Indicates that TCP header length > IP payload. Valid for
	 * TCP packets only.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN \
		(UINT32_C(0x6) << 12)
	/* Indicates that TCP header length < 5. Valid for TCP. */
	#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL \
		(UINT32_C(0x7) << 12)
	/*
	 * Indicates that TCP option headers result in a TCP header
	 * size that does not match data offset in TCP header. Valid
	 * for TCP.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN \
		(UINT32_C(0x8) << 12)
	/*
	 * Indicates that the IP checksum failed its check in the
	 * inner header.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_IP_CS_ERROR \
		(UINT32_C(0x9) << 12)
	/*
	 * Indicates that the L4 checksum failed its check in the
	 * inner header.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_L4_CS_ERROR \
		(UINT32_C(0xa) << 12)
	#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_LAST \
		RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_L4_CS_ERROR
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint16_t	metadata0;
	/* When meta_format=1, this value is the VLAN VID. */
	#define RX_PKT_V3_CMPL_HI_METADATA0_VID_MASK UINT32_C(0xfff)
	#define RX_PKT_V3_CMPL_HI_METADATA0_VID_SFT 0
	/* When meta_format=1, this value is the VLAN DE. */
	#define RX_PKT_V3_CMPL_HI_METADATA0_DE      UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define RX_PKT_V3_CMPL_HI_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define RX_PKT_V3_CMPL_HI_METADATA0_PRI_SFT 13
	/*
	 * The timestamp field contains the 32b timestamp for the packet from
	 * the MAC.
	 *
	 * When hairpin_en is set in VNIC context, this is the upper 32b of the
	 * host address from the first BD used to place the packet.
	 */
	uint32_t	timestamp;
} __rte_packed;

/* rx_pkt_compress_cmpl (size:128b/16B) */
struct rx_pkt_compress_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_PKT_COMPRESS_CMPL_TYPE_MASK                   UINT32_C(0x3f)
	#define RX_PKT_COMPRESS_CMPL_TYPE_SFT                    0
	/*
	 * RX L2 completion:
	 * This is the compressed version of Rx Completion for performance
	 * applications. Length = 16B
	 * This version of the completion record is used in Thor2 and later
	 * chips.
	 */
	#define RX_PKT_COMPRESS_CMPL_TYPE_RX_L2_COMPRESS \
		UINT32_C(0x10)
	#define RX_PKT_COMPRESS_CMPL_TYPE_LAST \
		RX_PKT_COMPRESS_CMPL_TYPE_RX_L2_COMPRESS
	#define RX_PKT_COMPRESS_CMPL_FLAGS_MASK \
		UINT32_C(0xffc0)
	#define RX_PKT_COMPRESS_CMPL_FLAGS_SFT                   6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_ERROR \
		UINT32_C(0x40)
	/*
	 * This field indicates the status of IP and L4 CS calculations done
	 * by the chip. The format of this field is indicated by the
	 * cs_all_ok_mode bit.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_T_IP_TYPE \
		UINT32_C(0x100)
	/* Indicates that the Tunnel IP type was IPv4 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_T_IP_TYPE_IPV4 \
		(UINT32_C(0x0) << 8)
	/* Indicates that the Tunnel IP type was IPv6 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_T_IP_TYPE_IPV6 \
		(UINT32_C(0x1) << 8)
	#define RX_PKT_COMPRESS_CMPL_FLAGS_T_IP_TYPE_LAST \
		RX_PKT_COMPRESS_CMPL_FLAGS_T_IP_TYPE_IPV6
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_IP_TYPE \
		UINT32_C(0x200)
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_RSS_VALID \
		UINT32_C(0x400)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_MASK \
		UINT32_C(0xf000)
	#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_SFT              12
	/*
	 * Not Known:
	 * Indicates that the packet type was not known.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_NOT_KNOWN \
		(UINT32_C(0x0) << 12)
	/*
	 * IP Packet:
	 * Indicates that the packet was an IP packet, but further
	 * classification was not possible.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_IP \
		(UINT32_C(0x1) << 12)
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 * This indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_TCP \
		(UINT32_C(0x2) << 12)
	/*
	 * UDP Packet:
	 * Indicates that the packet was IP and UDP.
	 * This indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_UDP \
		(UINT32_C(0x3) << 12)
	/*
	 * FCoE Packet:
	 * Indicates that the packet was recognized as a FCoE.
	 * This also indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_FCOE \
		(UINT32_C(0x4) << 12)
	/*
	 * RoCE Packet:
	 * Indicates that the packet was recognized as a RoCE.
	 * This also indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_ROCE \
		(UINT32_C(0x5) << 12)
	/*
	 * ICMP Packet:
	 * Indicates that the packet was recognized as ICMP.
	 * This indicates that the payload_offset field is valid.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_ICMP \
		(UINT32_C(0x7) << 12)
	/*
	 * PTP packet wo/timestamp:
	 * Indicates that the packet was recognized as a PTP
	 * packet.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_PTP_WO_TIMESTAMP \
		(UINT32_C(0x8) << 12)
	/*
	 * PTP packet w/timestamp:
	 * Indicates that the packet was recognized as a PTP
	 * packet and that a timestamp was taken for the packet.
	 * The 4b sub-nanosecond portion of the timestamp is in
	 * the payload_offset field.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP \
		(UINT32_C(0x9) << 12)
	#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_LAST \
		RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP
	/*
	 * This is the length of the data for the packet stored in the
	 * buffer(s) identified by the opaque value. This includes
	 * the packet BD and any associated buffer BDs. This does not include
	 * the length of any data places in aggregation BDs.
	 */
	uint16_t	len;
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC. When hairpin_en
	 * is set in VNIC context, this is the lower 32b of the host address
	 * from the first BD used to place the packet.
	 */
	uint32_t	rss_hash;
	uint16_t	metadata1_cs_error_calc_v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_COMPRESS_CMPL_V1 \
		UINT32_C(0x1)
	/* unused is 3 b */
	#define RX_PKT_COMPRESS_CMPL_UNUSED_MASK \
		UINT32_C(0xe)
	#define RX_PKT_COMPRESS_CMPL_UNUSED_SFT                      1
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_MASK \
		UINT32_C(0xff0)
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_SFT               4
	/* This indicates that there was an error in the IP header checksum. */
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_IP_CS_ERROR \
		UINT32_C(0x10)
	/*
	 * This indicates that there was an error in the TCP, UDP or ICMP
	 * checksum.
	 */
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_L4_CS_ERROR \
		UINT32_C(0x20)
	/*
	 * This indicates that there was an error in the tunnel IP header
	 * checksum.
	 */
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_T_IP_CS_ERROR \
		UINT32_C(0x40)
	/* This indicates that there was an error in the tunnel UDP checksum. */
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_T_L4_CS_ERROR \
		UINT32_C(0x80)
	/*
	 * This indicates that the ip checksum was calculated for the inner
	 * packet and that the ip_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_IP_CS_CALC \
		UINT32_C(0x100)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was calculated
	 * for the inner packet and that the l4_cs_error field indicates if
	 * there was an error.
	 */
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_L4_CS_CALC \
		UINT32_C(0x200)
	/*
	 * This indicates that the ip checksum was calculated for the tunnel
	 * header and that the t_ip_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_T_IP_CS_CALC \
		UINT32_C(0x400)
	/*
	 * This indicates that the UDP checksum was calculated for the tunnel
	 * packet and that the t_l4_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_T_L4_CS_CALC \
		UINT32_C(0x800)
	/* This is data from the CFA as indicated by the meta_format field. */
	#define RX_PKT_COMPRESS_CMPL_METADATA1_MASK \
		UINT32_C(0xf000)
	#define RX_PKT_COMPRESS_CMPL_METADATA1_SFT                   12
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_MASK \
		UINT32_C(0x7000)
	#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_SFT           12
	/* 0x88a8 */
	#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_TPID88A8 \
		(UINT32_C(0x0) << 12)
	/* 0x8100 */
	#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_TPID8100 \
		(UINT32_C(0x1) << 12)
	/* 0x9100 */
	#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_TPID9100 \
		(UINT32_C(0x2) << 12)
	/* 0x9200 */
	#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_TPID9200 \
		(UINT32_C(0x3) << 12)
	/* 0x9300 */
	#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_TPID9300 \
		(UINT32_C(0x4) << 12)
	/* Value programmed in CFA VLANTPID register. */
	#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_TPIDCFG \
		(UINT32_C(0x5) << 12)
	#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_LAST \
		RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define RX_PKT_COMPRESS_CMPL_METADATA1_VALID \
		UINT32_C(0x8000)
	/* This is data from the CFA as indicated by the meta_format field. */
	uint16_t	vlanc_tcid;
	/* When meta_format!=0, this value is the VLAN VID. */
	#define RX_PKT_COMPRESS_CMPL_VLANC_TCID_VID_MASK UINT32_C(0xfff)
	#define RX_PKT_COMPRESS_CMPL_VLANC_TCID_VID_SFT 0
	/* When meta_format!=0, this value is the VLAN DE. */
	#define RX_PKT_COMPRESS_CMPL_VLANC_TCID_DE      UINT32_C(0x1000)
	/* When meta_format!=0, this value is the VLAN PRI. */
	#define RX_PKT_COMPRESS_CMPL_VLANC_TCID_PRI_MASK UINT32_C(0xe000)
	#define RX_PKT_COMPRESS_CMPL_VLANC_TCID_PRI_SFT 13
	uint32_t	errors_agg_bufs_opaque;
	/* Lower 16bits of the Opaque field provided in the Rx BD. */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_OPAQUE_MASK \
		UINT32_C(0xffff)
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_OPAQUE_SFT \
		0
	/*
	 * This value is the number of aggregation buffers that follow this
	 * entry in the completion ring that are a part of this packet.
	 * If the value is zero, then the packet is completely contained
	 * in the buffer space provided for the packet in the RX ring.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_AGG_BUFS_MASK \
		UINT32_C(0x1f0000)
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_AGG_BUFS_SFT \
		16
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_MASK \
		UINT32_C(0x1fe00000)
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_SFT \
		21
	/*
	 * This indicates that there was an error in the inner
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_MASK \
		UINT32_C(0x1e00000)
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_SFT \
		21
	/*
	 * No additional error occurred on the tunnel portion
	 * or the packet of the packet does not have a tunnel.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_NO_ERROR \
		(UINT32_C(0x0) << 21)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6 or that
	 * option other than VFT was parsed on
	 * FCoE packet.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_L3_BAD_VERSION \
		(UINT32_C(0x1) << 21)
	/*
	 * indicates that header length is out of range. Valid for
	 * IPv4 and RoCE
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN \
		(UINT32_C(0x2) << 21)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0). Valid for IPv4, and IPv6
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_L3_BAD_TTL \
		(UINT32_C(0x3) << 21)
	/*
	 * Indicates that physical packet is shorter than that
	 * claimed by the l3 header length. Valid for IPv4,
	 * IPv6 packet or RoCE packets.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_IP_TOTAL_ERROR \
		(UINT32_C(0x4) << 21)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the UDP header length for a UDP packet that is
	 * not fragmented.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR \
		(UINT32_C(0x5) << 21)
	/*
	 * Indicates that TCP header length > IP payload. Valid for
	 * TCP packets only.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN \
		(UINT32_C(0x6) << 21)
	/* Indicates that TCP header length < 5. Valid for TCP. */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL \
		(UINT32_C(0x7) << 21)
	/*
	 * Indicates that TCP option headers result in a TCP header
	 * size that does not match data offset in TCP header. Valid
	 * for TCP.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN \
		(UINT32_C(0x8) << 21)
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_LAST \
		RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN
	/*
	 * This indicates that there was an error in the tunnel portion
	 * of the packet when this field is non-zero.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_MASK \
		UINT32_C(0xe000000)
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_SFT \
		25
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet or the packet does not have a tunnel.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_NO_ERROR \
		(UINT32_C(0x0) << 25)
	/*
	 * Indicates that IP header version does not match expectation
	 * from L2 Ethertype for IPv4 and IPv6 in the tunnel header.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION \
		(UINT32_C(0x1) << 25)
	/*
	 * Indicates that header length is out of range in the tunnel
	 * header. Valid for IPv4.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN \
		(UINT32_C(0x2) << 25)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the tunnel l3 header length. Valid for IPv4, or IPv6 tunnel
	 * packet packets.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR \
		(UINT32_C(0x3) << 25)
	/*
	 * Indicates that the physical packet is shorter than that claimed
	 * by the tunnel UDP header length for a tunnel UDP packet that is
	 * not fragmented.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR \
		(UINT32_C(0x4) << 25)
	/*
	 * Indicates that the IPv4 TTL or IPv6 hop limit check have failed
	 * (e.g. TTL = 0) in the tunnel header. Valid for IPv4, and IPv6.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL \
		(UINT32_C(0x5) << 25)
	/*
	 * Indicates that the IP checksum failed its check in the tunnel
	 * header.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_T_IP_CS_ERROR \
		(UINT32_C(0x6) << 25)
	/*
	 * Indicates that the L4 checksum failed its check in the tunnel
	 * header.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_T_L4_CS_ERROR \
		(UINT32_C(0x7) << 25)
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_LAST \
		RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_T_L4_CS_ERROR
	/*
	 * This indicates that there was a CRC error on either an FCoE
	 * or RoCE packet. The itype indicates the packet type.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_CRC_ERROR \
		UINT32_C(0x10000000)
	/* unused1 is 3 b */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_UNUSED1_MASK \
		UINT32_C(0xe0000000)
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_UNUSED1_SFT \
		29
} __rte_packed;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_start_cmpl (size:128b/16B) */
struct rx_tpa_start_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_START_CMPL_TYPE_MASK                UINT32_C(0x3f)
	#define RX_TPA_START_CMPL_TYPE_SFT                 0
	/*
	 * RX L2 TPA Start Completion:
	 * Completion at the beginning of a TPA operation.
	 * Length = 32B
	 */
	#define RX_TPA_START_CMPL_TYPE_RX_TPA_START          UINT32_C(0x13)
	#define RX_TPA_START_CMPL_TYPE_LAST \
		RX_TPA_START_CMPL_TYPE_RX_TPA_START
	#define RX_TPA_START_CMPL_FLAGS_MASK               UINT32_C(0xffc0)
	#define RX_TPA_START_CMPL_FLAGS_SFT                6
	/* This bit will always be '0' for TPA start completions. */
	#define RX_TPA_START_CMPL_FLAGS_ERROR               UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_MASK      UINT32_C(0x380)
	#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_SFT       7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
	#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_JUMBO \
		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
	#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_HDS \
		(UINT32_C(0x2) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
	#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_GRO_JUMBO \
		(UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
	#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_GRO_HDS \
		(UINT32_C(0x6) << 7)
	#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_LAST \
		RX_TPA_START_CMPL_FLAGS_PLACEMENT_GRO_HDS
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_TPA_START_CMPL_FLAGS_RSS_VALID           UINT32_C(0x400)
	/* unused is 1 b */
	#define RX_TPA_START_CMPL_FLAGS_UNUSED              UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_TPA_START_CMPL_FLAGS_ITYPE_MASK          UINT32_C(0xf000)
	#define RX_TPA_START_CMPL_FLAGS_ITYPE_SFT           12
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 */
	#define RX_TPA_START_CMPL_FLAGS_ITYPE_TCP \
		(UINT32_C(0x2) << 12)
	#define RX_TPA_START_CMPL_FLAGS_ITYPE_LAST \
		RX_TPA_START_CMPL_FLAGS_ITYPE_TCP
	/*
	 * This value indicates the amount of packet data written to the
	 * buffer the opaque field in this completion corresponds to.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	uint8_t	v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_START_CMPL_V1 UINT32_C(0x1)
	#define RX_TPA_START_CMPL_LAST RX_TPA_START_CMPL_V1
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 *
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * * 0: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 1: The RSS hash was computed over source IP address and destination
	 * IP address of inner IP header. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 2: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 3: The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 *
	 * Note that 4-tuples values listed above are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported and
	 * enabled for TCP traffic only, then the values of tuple_extract_op
	 * corresponding to 4-tuples are only valid for TCP traffic.
	 */
	uint8_t	rss_hash_type;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	uint16_t	agg_id;
	/* unused2 is 9 b */
	#define RX_TPA_START_CMPL_UNUSED2_MASK UINT32_C(0x1ff)
	#define RX_TPA_START_CMPL_UNUSED2_SFT 0
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	#define RX_TPA_START_CMPL_AGG_ID_MASK UINT32_C(0xfe00)
	#define RX_TPA_START_CMPL_AGG_ID_SFT  9
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC.
	 */
	uint32_t	rss_hash;
} __rte_packed;

/*
 * Last 16 bytes of rx_tpa_start_cmpl.
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_start_cmpl_hi (size:128b/16B) */
struct rx_tpa_start_cmpl_hi {
	uint32_t	flags2;
	/*
	 * This indicates that the ip checksum was calculated for the
	 * inner packet and that the sum passed for all segments
	 * included in the aggregation.
	 */
	#define RX_TPA_START_CMPL_FLAGS2_IP_CS_CALC       UINT32_C(0x1)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was
	 * calculated for the inner packet and that the sum passed
	 * for all segments included in the aggregation.
	 */
	#define RX_TPA_START_CMPL_FLAGS2_L4_CS_CALC       UINT32_C(0x2)
	/*
	 * This indicates that the ip checksum was calculated for the
	 * tunnel header and that the sum passed for all segments
	 * included in the aggregation.
	 */
	#define RX_TPA_START_CMPL_FLAGS2_T_IP_CS_CALC     UINT32_C(0x4)
	/*
	 * This indicates that the UDP checksum was
	 * calculated for the tunnel packet and that the sum passed for
	 * all segments included in the aggregation.
	 */
	#define RX_TPA_START_CMPL_FLAGS2_T_L4_CS_CALC     UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_TPA_START_CMPL_FLAGS2_META_FORMAT_MASK UINT32_C(0xf0)
	#define RX_TPA_START_CMPL_FLAGS2_META_FORMAT_SFT  4
	/* No metadata information. Value is zero. */
	#define RX_TPA_START_CMPL_FLAGS2_META_FORMAT_NONE \
		(UINT32_C(0x0) << 4)
	/*
	 * The metadata field contains the VLAN tag and TPID value.
	 * - metadata[11:0] contains the vlan VID value.
	 * - metadata[12] contains the vlan DE value.
	 * - metadata[15:13] contains the vlan PRI value.
	 * - metadata[31:16] contains the vlan TPID value.
	 */
	#define RX_TPA_START_CMPL_FLAGS2_META_FORMAT_VLAN \
		(UINT32_C(0x1) << 4)
	#define RX_TPA_START_CMPL_FLAGS2_META_FORMAT_LAST \
		RX_TPA_START_CMPL_FLAGS2_META_FORMAT_VLAN
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 */
	#define RX_TPA_START_CMPL_FLAGS2_IP_TYPE          UINT32_C(0x100)
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint32_t	metadata;
	/* When meta_format=1, this value is the VLAN VID. */
	#define RX_TPA_START_CMPL_METADATA_VID_MASK UINT32_C(0xfff)
	#define RX_TPA_START_CMPL_METADATA_VID_SFT  0
	/* When meta_format=1, this value is the VLAN DE. */
	#define RX_TPA_START_CMPL_METADATA_DE       UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define RX_TPA_START_CMPL_METADATA_PRI_MASK UINT32_C(0xe000)
	#define RX_TPA_START_CMPL_METADATA_PRI_SFT  13
	/* When meta_format=1, this value is the VLAN TPID. */
	#define RX_TPA_START_CMPL_METADATA_TPID_MASK UINT32_C(0xffff0000)
	#define RX_TPA_START_CMPL_METADATA_TPID_SFT 16
	uint16_t	v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_START_CMPL_V2     UINT32_C(0x1)
	/*
	 * This field identifies the CFA action rule that was used for this
	 * packet.
	 */
	uint16_t	cfa_code;
	/*
	 * This is the size in bytes of the inner most L4 header.
	 * This can be subtracted from the payload_offset to determine
	 * the start of the inner most L4 header.
	 */
	uint32_t	inner_l4_size_inner_l3_offset_inner_l2_offset_outer_l3_offset;
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the outer L3 header. If there is no outer L3 header, then this
	 * value is zero.
	 */
	#define RX_TPA_START_CMPL_OUTER_L3_OFFSET_MASK UINT32_C(0x1ff)
	#define RX_TPA_START_CMPL_OUTER_L3_OFFSET_SFT 0
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the inner most L2 header.
	 */
	#define RX_TPA_START_CMPL_INNER_L2_OFFSET_MASK UINT32_C(0x3fe00)
	#define RX_TPA_START_CMPL_INNER_L2_OFFSET_SFT 9
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the inner most L3 header.
	 */
	#define RX_TPA_START_CMPL_INNER_L3_OFFSET_MASK UINT32_C(0x7fc0000)
	#define RX_TPA_START_CMPL_INNER_L3_OFFSET_SFT 18
	/*
	 * This is the size in bytes of the inner most L4 header.
	 * This can be subtracted from the payload_offset to determine
	 * the start of the inner most L4 header.
	 */
	#define RX_TPA_START_CMPL_INNER_L4_SIZE_MASK  UINT32_C(0xf8000000)
	#define RX_TPA_START_CMPL_INNER_L4_SIZE_SFT   27
} __rte_packed;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 * RX L2 TPA Start V2 Completion Record (32 bytes split to 2 16-byte
 * struct)
 */
/* rx_tpa_start_v2_cmpl (size:128b/16B) */
struct rx_tpa_start_v2_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_START_V2_CMPL_TYPE_MASK \
		UINT32_C(0x3f)
	#define RX_TPA_START_V2_CMPL_TYPE_SFT                       0
	/*
	 * RX L2 TPA Start V2 Completion:
	 * Completion at the beginning of a TPA operation.
	 * Length = 32B
	 * This is the new version of the RX_TPA_START completion used
	 * in SR2 and later chips.
	 */
	#define RX_TPA_START_V2_CMPL_TYPE_RX_TPA_START_V2 \
		UINT32_C(0xd)
	#define RX_TPA_START_V2_CMPL_TYPE_LAST \
		RX_TPA_START_V2_CMPL_TYPE_RX_TPA_START_V2
	#define RX_TPA_START_V2_CMPL_FLAGS_MASK \
		UINT32_C(0xffc0)
	#define RX_TPA_START_V2_CMPL_FLAGS_SFT                      6
	/*
	 * When this bit is '1', it indicates a packet that has an error
	 * of some type. Type of error is indicated in error_flags.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS_ERROR \
		UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_MASK \
		UINT32_C(0x380)
	#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_SFT             7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_JUMBO \
		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_HDS \
		(UINT32_C(0x2) << 7)
	/*
	 * IOC/Jumbo:
	 * Packet will be placed using In-Order Completion/Jumbo where
	 * the first packet of the aggregation is placed using Jumbo
	 * Placement. Subsequent packets will be placed such that each
	 * packet starts at the beginning of an aggregation buffer.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_IOC_JUMBO \
		(UINT32_C(0x4) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_GRO_JUMBO \
		(UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_GRO_HDS \
		(UINT32_C(0x6) << 7)
	/*
	 * IOC/Header-Data Separation:
	 * Packet will be placed using In-Order Completion/HDS where
	 * the header is in the first packet buffer. Payload of each
	 * packet will be placed such that each packet starts at the
	 * beginning of an aggregation buffer.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_IOC_HDS \
		(UINT32_C(0x7) << 7)
	#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_LAST \
		RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_IOC_HDS
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_TPA_START_V2_CMPL_FLAGS_RSS_VALID \
		UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory. Metadata starts at the first 32B boundary
	 * after the end of the packet for regular and jumbo placement. It
	 * starts at the first 32B boundary after the end of the header for
	 * HDS placement. The length of the metadata is indicated in the
	 * metadata itself.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS_PKT_METADATA_PRESENT \
		UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS_ITYPE_MASK \
		UINT32_C(0xf000)
	#define RX_TPA_START_V2_CMPL_FLAGS_ITYPE_SFT                 12
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS_ITYPE_TCP \
		(UINT32_C(0x2) << 12)
	#define RX_TPA_START_V2_CMPL_FLAGS_ITYPE_LAST \
		RX_TPA_START_V2_CMPL_FLAGS_ITYPE_TCP
	/*
	 * This value indicates the amount of packet data written to the
	 * buffer the opaque field in this completion corresponds to.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to. If the VNIC is configured to not use an Rx BD for
	 * the TPA Start completion, then this is a copy of the opaque field
	 * from the first BD used to place the TPA Start packet.
	 */
	uint32_t	opaque;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	uint8_t	v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_START_V2_CMPL_V1 UINT32_C(0x1)
	#define RX_TPA_START_V2_CMPL_LAST RX_TPA_START_V2_CMPL_V1
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 *
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * * 0: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 1: The RSS hash was computed over source IP address and destination
	 * IP address of inner IP header. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 2: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 3: The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 *
	 * Note that 4-tuples values listed above are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported and
	 * enabled for TCP traffic only, then the values of tuple_extract_op
	 * corresponding to 4-tuples are only valid for TCP traffic.
	 */
	uint8_t	rss_hash_type;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	uint16_t	agg_id;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	#define RX_TPA_START_V2_CMPL_AGG_ID_MASK                UINT32_C(0xfff)
	#define RX_TPA_START_V2_CMPL_AGG_ID_SFT                 0
	#define RX_TPA_START_V2_CMPL_METADATA1_MASK \
		UINT32_C(0xf000)
	#define RX_TPA_START_V2_CMPL_METADATA1_SFT              12
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_MASK \
		UINT32_C(0x7000)
	#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_SFT      12
	/* 0x88a8 */
	#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPID88A8 \
		(UINT32_C(0x0) << 12)
	/* 0x8100 */
	#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPID8100 \
		(UINT32_C(0x1) << 12)
	/* 0x9100 */
	#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPID9100 \
		(UINT32_C(0x2) << 12)
	/* 0x9200 */
	#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPID9200 \
		(UINT32_C(0x3) << 12)
	/* 0x9300 */
	#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPID9300 \
		(UINT32_C(0x4) << 12)
	/* Value programmed in CFA VLANTPID register. */
	#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPIDCFG \
		(UINT32_C(0x5) << 12)
	#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_LAST \
		RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define RX_TPA_START_V2_CMPL_METADATA1_VALID \
		UINT32_C(0x8000)
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC.
	 * When vee_cmpl_mode is set in VNIC context, this is the lower
	 * 32b of the host address from the first BD used to place the packet.
	 */
	uint32_t	rss_hash;
} __rte_packed;

/*
 * Last 16 bytes of RX L2 TPA Start V2 Completion Record
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_start_v2_cmpl_hi (size:128b/16B) */
struct rx_tpa_start_v2_cmpl_hi {
	uint32_t	flags2;
	/* This indicates that the aggregation was done using GRO rules. */
	#define RX_TPA_START_V2_CMPL_FLAGS2_AGG_GRO \
		UINT32_C(0x4)
	/*
	 * When this bit is '0', the cs_ok field has the following definition:-
	 * ip_cs_ok[2:0] = The number of header groups with a valid IP checksum
	 * in the delivered packet, counted from the outer-most header group to
	 * the inner-most header group, stopping at the first error. -
	 * l4_cs_ok[5:3] = The number of header groups with a valid L4 checksum
	 * in the delivered packet, counted from the outer-most header group to
	 * the inner-most header group, stopping at the first error. When this
	 * bit is '1', the cs_ok field has the following definition: -
	 * hdr_cnt[2:0] = The number of header groups that were parsed by the
	 * chip and passed in the delivered packet. - ip_cs_all_ok[3] =This bit
	 * will be '1' if all the parsed header groups with an IP checksum are
	 * valid. - l4_cs_all_ok[4] = This bit will be '1' if all the parsed
	 * header groups with an L4 checksum are valid.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_CS_ALL_OK_MODE \
		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_MASK \
		UINT32_C(0xf0)
	#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_SFT            4
	/* There is no metadata information. Values are zero. */
	#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_NONE \
		(UINT32_C(0x0) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information: - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],
	 * de, vid[11:0]} The metadata2 field contains the table scope
	 * and action record pointer. - metadata2[25:0] contains the
	 * action record pointer. - metadata2[31:26] contains the table
	 * scope.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_ACT_REC_PTR \
		(UINT32_C(0x1) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB.
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_TUNNEL_ID \
		(UINT32_C(0x2) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 * The metadata2 field contains the 32b metadata from the prepended
	 * header (chdr_data).
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_CHDR_DATA \
		(UINT32_C(0x3) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the outer_l3_offset,
	 * inner_l2_offset, inner_l3_offset, and inner_l4_size.
	 * - metadata2[8:0] contains the outer_l3_offset.
	 * - metadata2[17:9] contains the inner_l2_offset.
	 * - metadata2[26:18] contains the inner_l3_offset.
	 * - metadata2[31:27] contains the inner_l4_size.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET \
		(UINT32_C(0x4) << 4)
	#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_LAST \
		RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_IP_TYPE \
		UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet in the affregation.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_COMPLETE_CHECKSUM_CALC \
		UINT32_C(0x200)
	/*
	 * This field indicates the status of IP and L4 CS calculations done
	 * by the chip. The format of this field is indicated by the
	 * cs_all_ok_mode bit.
	 * CS status for TPA packets is always valid. This means that "all_ok"
	 * status will always be set. The ok count status will be set
	 * appropriately for the packet header, such that all existing CS
	 * values are ok.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_CS_OK_MASK \
		UINT32_C(0xfc00)
	#define RX_TPA_START_V2_CMPL_FLAGS2_CS_OK_SFT                  10
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set. For TPA Start completions,
	 * the complete checksum is calculated for the first packet in the
	 * aggregation only.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_COMPLETE_CHECKSUM_MASK \
		UINT32_C(0xffff0000)
	#define RX_TPA_START_V2_CMPL_FLAGS2_COMPLETE_CHECKSUM_SFT      16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 * - meta_format 0 - none - metadata2 = 0 - not valid/not stripped
	 * - meta_format 1 - act_rec_ptr - metadata2 = {table_scope[5:0],
	 *   act_rec_ptr[25:0]}
	 * - meta_format 2 - tunnel_id - metadata2 = tunnel_id[31:0]
	 * - meta_format 3 - chdr_data - metadata2 = updated_chdr_data[31:0]
	 * - meta_format 4 - hdr_offsets - metadata2 = hdr_offsets[31:0]
	 * When vee_cmpl_mode is set in VNIC context, this is the upper 32b
	 * of the host address from the first BD used to place the packet.
	 */
	uint32_t	metadata2;
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_START_V2_CMPL_V2 \
		UINT32_C(0x1)
	#define RX_TPA_START_V2_CMPL_ERRORS_MASK \
		UINT32_C(0xfffe)
	#define RX_TPA_START_V2_CMPL_ERRORS_SFT                     1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packetThe packet should be treated as
	 * invalid.
	 */
	#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_MASK \
		UINT32_C(0xe)
	#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_SFT         1
	/* No buffer error */
	#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER \
		(UINT32_C(0x0) << 1)
	/*
	 * Did Not Fit:
	 * Packet did not fit into packet buffer provided. This means
	 * that the TPA Start packet was too big to be placed into the
	 * per-packet maximum number of physical buffers configured for
	 * the VNIC, or that it was too big to be placed into the
	 * per-aggregation maximum number of physical buffers configured
	 * for the VNIC. This error only occurs when the VNIC is
	 * configured for variable size receive buffers.
	 */
	#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_DID_NOT_FIT \
		(UINT32_C(0x1) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
	#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT \
		(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
	#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_FLUSH \
		(UINT32_C(0x5) << 1)
	#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_LAST \
		RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint16_t	metadata0;
	/* When meta_format != 0, this value is the VLAN VID. */
	#define RX_TPA_START_V2_CMPL_METADATA0_VID_MASK UINT32_C(0xfff)
	#define RX_TPA_START_V2_CMPL_METADATA0_VID_SFT 0
	/* When meta_format != 0, this value is the VLAN DE. */
	#define RX_TPA_START_V2_CMPL_METADATA0_DE      UINT32_C(0x1000)
	/* When meta_format != 0, this value is the VLAN PRI. */
	#define RX_TPA_START_V2_CMPL_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define RX_TPA_START_V2_CMPL_METADATA0_PRI_SFT 13
	/*
	 * This field contains the outer_l3_offset, inner_l2_offset,
	 * inner_l3_offset, and inner_l4_size.
	 *
	 * hdr_offsets[8:0] contains the outer_l3_offset.
	 * hdr_offsets[17:9] contains the inner_l2_offset.
	 * hdr_offsets[26:18] contains the inner_l3_offset.
	 * hdr_offsets[31:27] contains the inner_l4_size.
	 */
	uint32_t	hdr_offsets;
} __rte_packed;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 * RX L2 TPA Start V3 Completion Record (32 bytes split to 2 16-byte
 * struct)
 */
/* rx_tpa_start_v3_cmpl (size:128b/16B) */
struct rx_tpa_start_v3_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_START_V3_CMPL_TYPE_MASK \
		UINT32_C(0x3f)
	#define RX_TPA_START_V3_CMPL_TYPE_SFT                       0
	/*
	 * RX L2 TPA Start V3 completion:
	 * Completion at the beginning of a TPA operation.
	 * Length = 32B
	 * This is the new version of the RX_TPA_START completion used
	 * in Thor2 and later chips.
	 */
	#define RX_TPA_START_V3_CMPL_TYPE_RX_TPA_START_V3 \
		UINT32_C(0x19)
	#define RX_TPA_START_V3_CMPL_TYPE_LAST \
		RX_TPA_START_V3_CMPL_TYPE_RX_TPA_START_V3
	#define RX_TPA_START_V3_CMPL_FLAGS_MASK \
		UINT32_C(0xffc0)
	#define RX_TPA_START_V3_CMPL_FLAGS_SFT                      6
	/*
	 * When this bit is '1', it indicates a packet that has an error
	 * of some type. Type of error is indicated in error_flags.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS_ERROR \
		UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_MASK \
		UINT32_C(0x380)
	#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_SFT             7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_JUMBO \
		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_HDS \
		(UINT32_C(0x2) << 7)
	/*
	 * IOC/Jumbo:
	 * Packet will be placed using In-Order Completion/Jumbo where
	 * the first packet of the aggregation is placed using Jumbo
	 * Placement. Subsequent packets will be placed such that each
	 * packet starts at the beginning of an aggregation buffer.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_IOC_JUMBO \
		(UINT32_C(0x4) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_GRO_JUMBO \
		(UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_GRO_HDS \
		(UINT32_C(0x6) << 7)
	/*
	 * IOC/Header-Data Separation:
	 * Packet will be placed using In-Order Completion/HDS where
	 * the header is in the first packet buffer. Payload of each
	 * packet will be placed such that each packet starts at the
	 * beginning of an aggregation buffer.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_IOC_HDS \
		(UINT32_C(0x7) << 7)
	#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_LAST \
		RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_IOC_HDS
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_TPA_START_V3_CMPL_FLAGS_RSS_VALID \
		UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory. Metadata starts at the first 32B boundary
	 * after the end of the packet for regular and jumbo placement. It
	 * starts at the first 32B boundary after the end of the header for
	 * HDS placement. The length of the metadata is indicated in the
	 * metadata itself.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS_PKT_METADATA_PRESENT \
		UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS_ITYPE_MASK \
		UINT32_C(0xf000)
	#define RX_TPA_START_V3_CMPL_FLAGS_ITYPE_SFT                 12
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS_ITYPE_TCP \
		(UINT32_C(0x2) << 12)
	#define RX_TPA_START_V3_CMPL_FLAGS_ITYPE_LAST \
		RX_TPA_START_V3_CMPL_FLAGS_ITYPE_TCP
	/*
	 * This value indicates the amount of packet data written to the
	 * buffer the opaque field in this completion corresponds to.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to. If the VNIC is configured to not use an Rx BD for
	 * the TPA Start completion, then this is a copy of the opaque field
	 * from the first BD used to place the TPA Start packet.
	 */
	uint32_t	opaque;
	uint16_t	rss_hash_type_v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_START_V3_CMPL_V1                UINT32_C(0x1)
	/* unused1 is 6 b. */
	#define RX_TPA_START_V3_CMPL_UNUSED1_MASK      UINT32_C(0x7e)
	#define RX_TPA_START_V3_CMPL_UNUSED1_SFT       1
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 *
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * * 0: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers.
	 * * 1: The RSS hash was computed over source IP address and
	 * destination IP address of inner IP header.
	 * * 2: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 3: The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 4: The RSS hash was computed over source IP address of the inner
	 * IP header.
	 * * 5: The RSS hash was computed over destination IP address of the
	 * inner IP header.
	 * * 6: The RSS hash was computed over source IP address of the outer
	 * IP header. Note: For non-tunneled packets, this value is not
	 * applicable
	 * * 7: The RSS hash was computed over destination IP address of the
	 * outer IP header.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 8: The RSS hash was computed over source IP address, destination
	 * IP address, and flow label of the inner IP header.
	 * Note: For packets without an inner IPv6 header, this value is not
	 * applicable.
	 * * 9: The RSS hash was computed over the flow label of the inner
	 * IP header.
	 * Note: For packets without an inner IPv6 header, this value
	 * is not applicable.
	 * * 10: The RSS hash was computed over source IP address, destination
	 * IP address, and flow label of the outer IP header.
	 * Note: For packets without an outer IPv6 header, this value is not
	 * applicable.
	 * * 11: The RSS hash was computed over the flow label of the outer
	 * IP header. Note: For packets without an outer IPv6 header, this
	 * value is not applicable.
	 *
	 * Note that 4-tuples values listed above are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported
	 * and enabled for TCP traffic only, then the values of
	 * tuple_extract_op corresponding to 4-tuples are only valid for TCP
	 * traffic
	 */
	#define RX_TPA_START_V3_CMPL_RSS_HASH_TYPE_MASK UINT32_C(0xff80)
	#define RX_TPA_START_V3_CMPL_RSS_HASH_TYPE_SFT 7
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	uint16_t	agg_id;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	#define RX_TPA_START_V3_CMPL_AGG_ID_MASK                UINT32_C(0xfff)
	#define RX_TPA_START_V3_CMPL_AGG_ID_SFT                 0
	#define RX_TPA_START_V3_CMPL_METADATA1_MASK \
		UINT32_C(0xf000)
	#define RX_TPA_START_V3_CMPL_METADATA1_SFT              12
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_MASK \
		UINT32_C(0x7000)
	#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_SFT      12
	/* 0x88a8 */
	#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_TPID88A8 \
		(UINT32_C(0x0) << 12)
	/* 0x8100 */
	#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_TPID8100 \
		(UINT32_C(0x1) << 12)
	/* 0x9100 */
	#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_TPID9100 \
		(UINT32_C(0x2) << 12)
	/* 0x9200 */
	#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_TPID9200 \
		(UINT32_C(0x3) << 12)
	/* 0x9300 */
	#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_TPID9300 \
		(UINT32_C(0x4) << 12)
	/* Value programmed in CFA VLANTPID register. */
	#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_TPIDCFG \
		(UINT32_C(0x5) << 12)
	#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_LAST \
		RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define RX_TPA_START_V3_CMPL_METADATA1_VALID \
		UINT32_C(0x8000)
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC.
	 * When vee_cmpl_mode is set in VNIC context, this is the lower
	 * 32b of the host address from the first BD used to place the packet.
	 */
	uint32_t	rss_hash;
} __rte_packed;

/*
 * Last 16 bytes of RX L2 TPA Start V3 Completion Record
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_start_v3_cmpl_hi (size:128b/16B) */
struct rx_tpa_start_v3_cmpl_hi {
	uint32_t	flags2;
	/*
	 * This indicates that the ip checksum was calculated for the inner
	 * packet and that the ip_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_IP_CS_CALC \
		UINT32_C(0x1)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was calculated
	 * for the inner packet and that the l4_cs_error field indicates if
	 * there was an error.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_L4_CS_CALC \
		UINT32_C(0x2)
	/*
	 * This indicates that the ip checksum was calculated for the tunnel
	 * header and that the t_ip_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_T_IP_CS_CALC \
		UINT32_C(0x4)
	/*
	 * This indicates that the UDP checksum was calculated for the tunnel
	 * packet and that the t_l4_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_T_L4_CS_CALC \
		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_MASK \
		UINT32_C(0xf0)
	#define RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_SFT            4
	/* There is no metadata information. Values are zero. */
	#define RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_NONE \
		(UINT32_C(0x0) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information: - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],
	 * de, vid[11:0]} The metadata2 field contains the table scope
	 * and action record pointer. - metadata2[25:0] contains the
	 * action record pointer. - metadata2[31:26] contains the table
	 * scope.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_ACT_REC_PTR \
		(UINT32_C(0x1) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB.
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_TUNNEL_ID \
		(UINT32_C(0x2) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 * The metadata2 field contains the 32b metadata from the prepended
	 * header (chdr_data).
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_CHDR_DATA \
		(UINT32_C(0x3) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the outer_l3_offset,
	 * inner_l2_offset, inner_l3_offset, and inner_l4_size.
	 * - metadata2[8:0] contains the outer_l3_offset.
	 * - metadata2[17:9] contains the inner_l2_offset.
	 * - metadata2[26:18] contains the inner_l3_offset.
	 * - metadata2[31:27] contains the inner_l4_size.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET \
		(UINT32_C(0x4) << 4)
	#define RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_LAST \
		RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_IP_TYPE \
		UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_COMPLETE_CHECKSUM_CALC \
		UINT32_C(0x200)
	/*
	 * This field indicates the status of IP and L4 CS calculations done
	 * by the chip. The format of this field is indicated by the
	 * cs_all_ok_mode bit.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_T_IP_TYPE \
		UINT32_C(0x400)
	/* Indicates that the Tunnel IP type was IPv4 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_T_IP_TYPE_IPV4 \
		(UINT32_C(0x0) << 10)
	/* Indicates that the Tunnel IP type was IPv6 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_T_IP_TYPE_IPV6 \
		(UINT32_C(0x1) << 10)
	#define RX_TPA_START_V3_CMPL_FLAGS2_T_IP_TYPE_LAST \
		RX_TPA_START_V3_CMPL_FLAGS2_T_IP_TYPE_IPV6
	/* This indicates that the aggregation was done using GRO rules. */
	#define RX_TPA_START_V3_CMPL_FLAGS2_AGG_GRO \
		UINT32_C(0x800)
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set. For TPA Start completions,
	 * the complete checksum is calculated for the first packet in the
	 * aggregation only.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_COMPLETE_CHECKSUM_MASK \
		UINT32_C(0xffff0000)
	#define RX_TPA_START_V3_CMPL_FLAGS2_COMPLETE_CHECKSUM_SFT      16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 * - meta_format 0 - none - metadata2 = 0 - not valid/not stripped
	 * - meta_format 1 - act_rec_ptr - metadata2 = {table_scope[5:0],
	 *   act_rec_ptr[25:0]}
	 * - meta_format 2 - tunnel_id - metadata2 = tunnel_id[31:0]
	 * - meta_format 3 - chdr_data - metadata2 = updated_chdr_data[31:0]
	 * - meta_format 4 - hdr_offsets - metadata2 = hdr_offsets[31:0]
	 * When vee_cmpl_mode is set in VNIC context, this is the upper 32b
	 * of the host address from the first BD used to place the packet.
	 */
	uint32_t	metadata2;
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_START_V3_CMPL_V2 \
		UINT32_C(0x1)
	#define RX_TPA_START_V3_CMPL_ERRORS_MASK \
		UINT32_C(0xfffe)
	#define RX_TPA_START_V3_CMPL_ERRORS_SFT                     1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packetThe packet should be treated as
	 * invalid.
	 */
	#define RX_TPA_START_V3_CMPL_ERRORS_BUFFER_ERROR_MASK \
		UINT32_C(0xe)
	#define RX_TPA_START_V3_CMPL_ERRORS_BUFFER_ERROR_SFT         1
	/* No buffer error */
	#define RX_TPA_START_V3_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER \
		(UINT32_C(0x0) << 1)
	/*
	 * Did Not Fit:
	 * Packet did not fit into packet buffer provided. This means
	 * that the TPA Start packet was too big to be placed into the
	 * per-packet maximum number of physical buffers configured for
	 * the VNIC, or that it was too big to be placed into the
	 * per-aggregation maximum number of physical buffers configured
	 * for the VNIC. This error only occurs when the VNIC is
	 * configured for variable size receive buffers.
	 */
	#define RX_TPA_START_V3_CMPL_ERRORS_BUFFER_ERROR_DID_NOT_FIT \
		(UINT32_C(0x1) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
	#define RX_TPA_START_V3_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT \
		(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
	#define RX_TPA_START_V3_CMPL_ERRORS_BUFFER_ERROR_FLUSH \
		(UINT32_C(0x5) << 1)
	#define RX_TPA_START_V3_CMPL_ERRORS_BUFFER_ERROR_LAST \
		RX_TPA_START_V3_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint16_t	metadata0;
	/* When meta_format != 0, this value is the VLAN VID. */
	#define RX_TPA_START_V3_CMPL_METADATA0_VID_MASK UINT32_C(0xfff)
	#define RX_TPA_START_V3_CMPL_METADATA0_VID_SFT 0
	/* When meta_format != 0, this value is the VLAN DE. */
	#define RX_TPA_START_V3_CMPL_METADATA0_DE      UINT32_C(0x1000)
	/* When meta_format != 0, this value is the VLAN PRI. */
	#define RX_TPA_START_V3_CMPL_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define RX_TPA_START_V3_CMPL_METADATA0_PRI_SFT 13
	/*
	 * This field contains the outer_l3_offset, inner_l2_offset,
	 * inner_l3_offset, and inner_l4_size.
	 *
	 * hdr_offsets[8:0] contains the outer_l3_offset.
	 * hdr_offsets[17:9] contains the inner_l2_offset.
	 * hdr_offsets[26:18] contains the inner_l3_offset.
	 * hdr_offsets[31:27] contains the inner_l4_size.
	 */
	uint32_t	hdr_offsets;
} __rte_packed;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_end_cmpl (size:128b/16B) */
struct rx_tpa_end_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_END_CMPL_TYPE_MASK                      UINT32_C(0x3f)
	#define RX_TPA_END_CMPL_TYPE_SFT                       0
	/*
	 * RX L2 TPA End Completion:
	 * Completion at the end of a TPA operation.
	 * Length = 32B
	 */
	#define RX_TPA_END_CMPL_TYPE_RX_TPA_END                  UINT32_C(0x15)
	#define RX_TPA_END_CMPL_TYPE_LAST \
		RX_TPA_END_CMPL_TYPE_RX_TPA_END
	#define RX_TPA_END_CMPL_FLAGS_MASK                     UINT32_C(0xffc0)
	#define RX_TPA_END_CMPL_FLAGS_SFT                      6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define RX_TPA_END_CMPL_FLAGS_ERROR                     UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_MASK            UINT32_C(0x380)
	#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_SFT             7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
	#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_JUMBO \
		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
	#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_HDS \
		(UINT32_C(0x2) << 7)
	/*
	 * IOC/Jumbo:
	 * Packet will be placed using In-Order Completion/Jumbo where
	 * the first packet of the aggregation is placed using Jumbo
	 * Placement. Subsequent packets will be placed such that each
	 * packet starts at the beginning of an aggregation buffer.
	 */
	#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_IOC_JUMBO \
		(UINT32_C(0x4) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
	#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_GRO_JUMBO \
		(UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
	#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_GRO_HDS \
		(UINT32_C(0x6) << 7)
	/*
	 * IOC/Header-Data Separation:
	 * Packet will be placed using In-Order Completion/HDS where
	 * the header is in the first packet buffer. Payload of each
	 * packet will be placed such that each packet starts at the
	 * beginning of an aggregation buffer.
	 */
	#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_IOC_HDS \
		(UINT32_C(0x7) << 7)
	#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_LAST \
		RX_TPA_END_CMPL_FLAGS_PLACEMENT_IOC_HDS
	/* When set, this bit indicates that the timestamp field is valid. */
	#define RX_TPA_END_CMPL_FLAGS_TIMESTAMP_VALID           UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory. Metadata starts at the first 32B boundary
	 * after the end of the packet for regular and jumbo placement.
	 * It starts at the first 32B boundary after the end of the header
	 * for HDS placement. The length of the metadata is indicated in the
	 * metadata itself.
	 */
	#define RX_TPA_END_CMPL_FLAGS_PKT_METADATA_PRESENT      UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 * - 2 TCP Packet
	 *     Indicates that the packet was IP and TCP. This indicates
	 *     that the ip_cs field is valid and that the tcp_udp_cs
	 *     field is valid and contains the TCP checksum.
	 *     This also indicates that the payload_offset field is valid.
	 */
	#define RX_TPA_END_CMPL_FLAGS_ITYPE_MASK \
		UINT32_C(0xf000)
	#define RX_TPA_END_CMPL_FLAGS_ITYPE_SFT                 12
	/*
	 * This value is zero for TPA End completions.
	 * There is no data in the buffer that corresponds to the opaque
	 * value in this completion.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	uint8_t	agg_bufs_v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_END_CMPL_V1           UINT32_C(0x1)
	/*
	 * This value is the number of aggregation buffers that follow this
	 * entry in the completion ring that are a part of this aggregation
	 * packet.
	 * If the value is zero, then the packet is completely contained
	 * in the buffer space provided in the aggregation start completion.
	 */
	#define RX_TPA_END_CMPL_AGG_BUFS_MASK UINT32_C(0x7e)
	#define RX_TPA_END_CMPL_AGG_BUFS_SFT 1
	/* This value is the number of segments in the TPA operation. */
	uint8_t	tpa_segs;
	/*
	 * This value indicates the offset in bytes from the beginning of the
	 * packet where the inner payload starts. This value is valid for TCP,
	 * UDP, FCoE, and RoCE packets.
	 *
	 * A value of zero indicates an offset of 256 bytes.
	 */
	uint8_t	payload_offset;
	uint8_t	agg_id;
	/* unused2 is 1 b */
	#define RX_TPA_END_CMPL_UNUSED2     UINT32_C(0x1)
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	#define RX_TPA_END_CMPL_AGG_ID_MASK UINT32_C(0xfe)
	#define RX_TPA_END_CMPL_AGG_ID_SFT  1
	/*
	 * For non-GRO packets, this value is the
	 * timestamp delta between earliest and latest timestamp values for
	 * TPA packet. If packets were not time stamped, then delta will be
	 * zero.
	 *
	 * For GRO packets, this field is zero except for the following
	 * sub-fields.
	 * - tsdelta[31]
	 *     Timestamp present indication. When '0', no Timestamp
	 *     option is in the packet. When '1', then a Timestamp
	 *     option is present in the packet.
	 */
	uint32_t	tsdelta;
} __rte_packed;

/*
 * Last 16 bytes of rx_tpa_end_cmpl.
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_end_cmpl_hi (size:128b/16B) */
struct rx_tpa_end_cmpl_hi {
	uint32_t	tpa_dup_acks;
	/*
	 * This value is the number of duplicate ACKs that have been
	 * received as part of the TPA operation.
	 */
	#define RX_TPA_END_CMPL_TPA_DUP_ACKS_MASK UINT32_C(0xf)
	#define RX_TPA_END_CMPL_TPA_DUP_ACKS_SFT 0
	/*
	 * This value is the valid when TPA completion is active. It
	 * indicates the length of the longest segment of the TPA operation
	 * for LRO mode and the length of the first segment in GRO mode.
	 *
	 * This value may be used by GRO software to re-construct the original
	 * packet stream from the TPA packet. This is the length of all
	 * but the last segment for GRO. In LRO mode this value may be used
	 * to indicate MSS size to the stack.
	 */
	uint16_t	tpa_seg_len;
	/*
	 * The lower 16b of the timestamp of the last packet added to the
	 * aggregation. Only valid when flags.timestamp_valid is set.
	 */
	uint16_t	timestamp_lower;
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_END_CMPL_V2                             UINT32_C(0x1)
	#define RX_TPA_END_CMPL_ERRORS_MASK                    UINT32_C(0xfffe)
	#define RX_TPA_END_CMPL_ERRORS_SFT                     1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_MASK        UINT32_C(0xe)
	#define RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_SFT         1
	/*
	 * This error occurs when there is a fatal HW problem in
	 * the chip only. It indicates that there were not
	 * BDs on chip but that there was adequate reservation.
	 * provided by the TPA block.
	 */
	#define RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_NOT_ON_CHIP \
		(UINT32_C(0x2) << 1)
	/*
	 * This error occurs when TPA block was not configured to
	 * reserve adequate BDs for TPA operations on this RX
	 * ring. All data for the TPA operation was not placed.
	 *
	 * This error can also be generated when the number of
	 * segments is not programmed correctly in TPA and the
	 * 33 total aggregation buffers allowed for the TPA
	 * operation has been exceeded.
	 */
	#define RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_RSV_ERROR \
		(UINT32_C(0x4) << 1)
	#define RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_LAST \
		RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_RSV_ERROR
	/*
	 * The upper 16b of the timestamp of the last packet added to the
	 * aggregation. Only valid when flags.timestamp_valid is set.
	 */
	uint16_t	timestamp_upper;
	/*
	 * This is the opaque value that was completed for the TPA start
	 * completion that corresponds to this TPA end completion.
	 */
	uint32_t	start_opaque;
} __rte_packed;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is greater than 0.
 */
/* rx_tpa_v2_start_cmpl (size:128b/16B) */
struct rx_tpa_v2_start_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_V2_START_CMPL_TYPE_MASK \
		UINT32_C(0x3f)
	#define RX_TPA_V2_START_CMPL_TYPE_SFT                       0
	/*
	 * RX L2 TPA Start Completion:
	 * Completion at the beginning of a TPA operation.
	 * Length = 32B
	 */
	#define RX_TPA_V2_START_CMPL_TYPE_RX_TPA_START \
		UINT32_C(0x13)
	#define RX_TPA_V2_START_CMPL_TYPE_LAST \
		RX_TPA_V2_START_CMPL_TYPE_RX_TPA_START
	#define RX_TPA_V2_START_CMPL_FLAGS_MASK \
		UINT32_C(0xffc0)
	#define RX_TPA_V2_START_CMPL_FLAGS_SFT                      6
	/* This bit will always be '0' for TPA start completions. */
	#define RX_TPA_V2_START_CMPL_FLAGS_ERROR \
		UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_MASK \
		UINT32_C(0x380)
	#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_SFT             7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_JUMBO \
		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_HDS \
		(UINT32_C(0x2) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_GRO_JUMBO \
		(UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_GRO_HDS \
		(UINT32_C(0x6) << 7)
	#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_LAST \
		RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_GRO_HDS
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_TPA_V2_START_CMPL_FLAGS_RSS_VALID \
		UINT32_C(0x400)
	/*
	 * For devices that support timestamps, when this bit is cleared the
	 * `inner_l4_size_inner_l3_offset_inner_l2_offset_outer_l3_offset`
	 * field contains the 32b timestamp for
	 * the packet from the MAC. When this bit is set, the
	 * `inner_l4_size_inner_l3_offset_inner_l2_offset_outer_l3_offset`
	 * field contains the outer_l3_offset, inner_l2_offset,
	 * inner_l3_offset, and inner_l4_size.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS_TIMESTAMP_FLD_FORMAT \
		UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS_ITYPE_MASK \
		UINT32_C(0xf000)
	#define RX_TPA_V2_START_CMPL_FLAGS_ITYPE_SFT                 12
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS_ITYPE_TCP \
		(UINT32_C(0x2) << 12)
	#define RX_TPA_V2_START_CMPL_FLAGS_ITYPE_LAST \
		RX_TPA_V2_START_CMPL_FLAGS_ITYPE_TCP
	/*
	 * This value indicates the amount of packet data written to the
	 * buffer the opaque field in this completion corresponds to.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	uint8_t	v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_V2_START_CMPL_V1 UINT32_C(0x1)
	#define RX_TPA_V2_START_CMPL_LAST RX_TPA_V2_START_CMPL_V1
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 *
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * * 0: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 1: The RSS hash was computed over source IP address and destination
	 * IP address of inner IP header. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 2: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 3: The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 *
	 * Note that 4-tuples values listed above are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported and
	 * enabled for TCP traffic only, then the values of tuple_extract_op
	 * corresponding to 4-tuples are only valid for TCP traffic.
	 */
	uint8_t	rss_hash_type;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	uint16_t	agg_id;
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC.
	 */
	uint32_t	rss_hash;
} __rte_packed;

/*
 * Last 16 bytes of rx_tpa_v2_start_cmpl.
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is greater than 0.
 */
/* rx_tpa_v2_start_cmpl_hi (size:128b/16B) */
struct rx_tpa_v2_start_cmpl_hi {
	uint32_t	flags2;
	/*
	 * This indicates that the ip checksum was calculated for the
	 * inner packet and that the sum passed for all segments
	 * included in the aggregation.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_IP_CS_CALC \
		UINT32_C(0x1)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was
	 * calculated for the inner packet and that the sum passed
	 * for all segments included in the aggregation.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_L4_CS_CALC \
		UINT32_C(0x2)
	/*
	 * This indicates that the ip checksum was calculated for the
	 * tunnel header and that the sum passed for all segments
	 * included in the aggregation.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_T_IP_CS_CALC \
		UINT32_C(0x4)
	/*
	 * This indicates that the UDP checksum was
	 * calculated for the tunnel packet and that the sum passed for
	 * all segments included in the aggregation.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_T_L4_CS_CALC \
		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_MASK \
		UINT32_C(0xf0)
	#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_SFT            4
	/* No metadata informtaion. Value is zero. */
	#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_NONE \
		(UINT32_C(0x0) << 4)
	/*
	 * The metadata field contains the VLAN tag and TPID value.
	 * - metadata[11:0] contains the vlan VID value.
	 * - metadata[12] contains the vlan DE value.
	 * - metadata[15:13] contains the vlan PRI value.
	 * - metadata[31:16] contains the vlan TPID value.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_VLAN \
		(UINT32_C(0x1) << 4)
	/*
	 * If ext_meta_format is equal to 1, the metadata field
	 * contains the lower 16b of the tunnel ID value, justified
	 * to LSB
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier.
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0 -> key fieled with bit mask. zero if K = 0
	 * - IPV4 = 0 (not populated)
	 * - IPV6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_TUNNEL_ID \
		(UINT32_C(0x2) << 4)
	/*
	 * if ext_meta_format is equal to 1, metadata field contains
	 * 16b metadata from the prepended header (chdr_data).
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_CHDR_DATA \
		(UINT32_C(0x3) << 4)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the outer_l3_offset, inner_l2_offset, inner_l3_offset and
	 * inner_l4_size.
	 * - metadata[8:0] contains the outer_l3_offset.
	 * - metadata[17:9] contains the inner_l2_offset.
	 * - metadata[26:18] contains the inner_l3_offset.
	 * - metadata[31:27] contains the inner_l4_size.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET \
		(UINT32_C(0x4) << 4)
	#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_LAST \
		RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_IP_TYPE \
		UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_COMPLETE_CHECKSUM_CALC \
		UINT32_C(0x200)
	/*
	 * The combination of this value and meta_format indicated what
	 * format the metadata field is.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_EXT_META_FORMAT_MASK \
		UINT32_C(0xc00)
	#define RX_TPA_V2_START_CMPL_FLAGS2_EXT_META_FORMAT_SFT        10
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set. For TPA Start completions,
	 * the complete checksum is calculated for the first packet in the
	 * aggregation only.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_COMPLETE_CHECKSUM_MASK \
		UINT32_C(0xffff0000)
	#define RX_TPA_V2_START_CMPL_FLAGS2_COMPLETE_CHECKSUM_SFT      16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint32_t	metadata;
	/* When {ext_meta_format,meta_format}=1, this value is the VLAN VID. */
	#define RX_TPA_V2_START_CMPL_METADATA_VID_MASK UINT32_C(0xfff)
	#define RX_TPA_V2_START_CMPL_METADATA_VID_SFT  0
	/* When {ext_meta_format,meta_format}=1, this value is the VLAN DE. */
	#define RX_TPA_V2_START_CMPL_METADATA_DE       UINT32_C(0x1000)
	/* When {ext_meta_format,meta_format}=1, this value is the VLAN PRI. */
	#define RX_TPA_V2_START_CMPL_METADATA_PRI_MASK UINT32_C(0xe000)
	#define RX_TPA_V2_START_CMPL_METADATA_PRI_SFT  13
	/* When {ext_meta_format,meta_format}=1, this value is the VLAN TPID. */
	#define RX_TPA_V2_START_CMPL_METADATA_TPID_MASK UINT32_C(0xffff0000)
	#define RX_TPA_V2_START_CMPL_METADATA_TPID_SFT 16
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_V2_START_CMPL_V2 \
		UINT32_C(0x1)
	#define RX_TPA_V2_START_CMPL_ERRORS_MASK \
		UINT32_C(0xfffe)
	#define RX_TPA_V2_START_CMPL_ERRORS_SFT                    1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_MASK \
		UINT32_C(0xe)
	#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_SFT        1
	/* No buffer error */
	#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER \
		(UINT32_C(0x0) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
	#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT \
		(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
	#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_FLUSH \
		(UINT32_C(0x5) << 1)
	#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_LAST \
		RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	/*
	 * This field identifies the CFA action rule that was used for this
	 * packet.
	 */
	uint16_t	cfa_code;
	/*
	 * For devices that support timestamps this field is overridden
	 * with the timestamp value. When `flags.timestamp_fld_format` is
	 * cleared, this field contains the 32b timestamp for the packet from the
	 * MAC.
	 *
	 * When `flags.timestamp_fld_format` is set, this field contains the
	 * outer_l3_offset, inner_l2_offset, inner_l3_offset, and inner_l4_size
	 * as defined below.
	 */
	uint32_t	inner_l4_size_inner_l3_offset_inner_l2_offset_outer_l3_offset;
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the outer L3 header. If there is no outer L3 header, then this
	 * value is zero.
	 */
	#define RX_TPA_V2_START_CMPL_OUTER_L3_OFFSET_MASK UINT32_C(0x1ff)
	#define RX_TPA_V2_START_CMPL_OUTER_L3_OFFSET_SFT 0
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the inner most L2 header.
	 */
	#define RX_TPA_V2_START_CMPL_INNER_L2_OFFSET_MASK UINT32_C(0x3fe00)
	#define RX_TPA_V2_START_CMPL_INNER_L2_OFFSET_SFT 9
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the inner most L3 header.
	 */
	#define RX_TPA_V2_START_CMPL_INNER_L3_OFFSET_MASK UINT32_C(0x7fc0000)
	#define RX_TPA_V2_START_CMPL_INNER_L3_OFFSET_SFT 18
	/*
	 * This is the size in bytes of the inner most L4 header.
	 * This can be subtracted from the payload_offset to determine
	 * the start of the inner most L4 header.
	 */
	#define RX_TPA_V2_START_CMPL_INNER_L4_SIZE_MASK  UINT32_C(0xf8000000)
	#define RX_TPA_V2_START_CMPL_INNER_L4_SIZE_SFT   27
} __rte_packed;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is greater than 0.
 */
/* rx_tpa_v2_end_cmpl (size:128b/16B) */
struct rx_tpa_v2_end_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_V2_END_CMPL_TYPE_MASK \
		UINT32_C(0x3f)
	#define RX_TPA_V2_END_CMPL_TYPE_SFT                       0
	/*
	 * RX L2 TPA End Completion:
	 * Completion at the end of a TPA operation.
	 * Length = 32B
	 */
	#define RX_TPA_V2_END_CMPL_TYPE_RX_TPA_END \
		UINT32_C(0x15)
	#define RX_TPA_V2_END_CMPL_TYPE_LAST \
		RX_TPA_V2_END_CMPL_TYPE_RX_TPA_END
	#define RX_TPA_V2_END_CMPL_FLAGS_MASK \
		UINT32_C(0xffc0)
	#define RX_TPA_V2_END_CMPL_FLAGS_SFT                      6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define RX_TPA_V2_END_CMPL_FLAGS_ERROR \
		UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_MASK \
		UINT32_C(0x380)
	#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_SFT             7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
	#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_JUMBO \
		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
	#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_HDS \
		(UINT32_C(0x2) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
	#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_GRO_JUMBO \
		(UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
	#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_GRO_HDS \
		(UINT32_C(0x6) << 7)
	/*
	 * IOC/Header-Data Separation:
	 * Packet will be placed using In-Order Completion/HDS where
	 * the header is in the first packet buffer. Payload of each
	 * packet will be placed such that each packet starts at the
	 * beginning of an aggregation buffer.
	 */
	#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_IOC_HDS \
		(UINT32_C(0x7) << 7)
	#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_LAST \
		RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_IOC_HDS
	/* unused is 1 b */
	#define RX_TPA_V2_END_CMPL_FLAGS_UNUSED \
		UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory. Metadata starts at the first 32B boundary
	 * after the end of the packet for regular and jumbo placement.
	 * It starts at the first 32B boundary after the end of the header
	 * for HDS placement. The length of the metadata is indicated in the
	 * metadata itself.
	 */
	#define RX_TPA_V2_END_CMPL_FLAGS_PKT_METADATA_PRESENT \
		UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 * - 2 TCP Packet
	 *     Indicates that the packet was IP and TCP. This indicates
	 *     that the ip_cs field is valid and that the tcp_udp_cs
	 *     field is valid and contains the TCP checksum.
	 *     This also indicates that the payload_offset field is valid.
	 */
	#define RX_TPA_V2_END_CMPL_FLAGS_ITYPE_MASK \
		UINT32_C(0xf000)
	#define RX_TPA_V2_END_CMPL_FLAGS_ITYPE_SFT                 12
	/*
	 * This value is zero for TPA End completions.
	 * There is no data in the buffer that corresponds to the opaque
	 * value in this completion.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	uint8_t	v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_V2_END_CMPL_V1     UINT32_C(0x1)
	/* This value is the number of segments in the TPA operation. */
	uint8_t	tpa_segs;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	uint16_t	agg_id;
	/*
	 * For non-GRO packets, this value is the
	 * timestamp delta between earliest and latest timestamp values for
	 * TPA packet. If packets were not time stamped, then delta will be
	 * zero.
	 *
	 * For GRO packets, this field is zero except for the following
	 * sub-fields.
	 * - tsdelta[31]
	 *     Timestamp present indication. When '0', no Timestamp
	 *     option is in the packet. When '1', then a Timestamp
	 *     option is present in the packet.
	 */
	uint32_t	tsdelta;
} __rte_packed;

/*
 * Last 16 bytes of rx_tpa_v2_end_cmpl.
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is greater than 0.
 */
/* rx_tpa_v2_end_cmpl_hi (size:128b/16B) */
struct rx_tpa_v2_end_cmpl_hi {
	/*
	 * This value is the number of duplicate ACKs that have been
	 * received as part of the TPA operation.
	 */
	uint16_t	tpa_dup_acks;
	/*
	 * This value is the number of duplicate ACKs that have been
	 * received as part of the TPA operation.
	 */
	#define RX_TPA_V2_END_CMPL_TPA_DUP_ACKS_MASK UINT32_C(0xf)
	#define RX_TPA_V2_END_CMPL_TPA_DUP_ACKS_SFT 0
	/*
	 * This value indicated the offset in bytes from the beginning of
	 * the packet where the inner payload starts. This value is valid
	 * for TCP, UDP, FCoE and RoCE packets
	 */
	uint8_t	payload_offset;
	/*
	 * The value is the total number of aggregation buffers that were
	 * used in the TPA operation. All TPA aggregation buffer completions
	 * precede the TPA End completion. If the value is zero, then the
	 * aggregation is completely contained in the buffer space provided
	 * in the aggregation start completion.
	 * Note that the field is simply provided as a cross check.
	 */
	uint8_t	tpa_agg_bufs;
	/*
	 * This value is the valid when TPA completion is active. It
	 * indicates the length of the longest segment of the TPA operation
	 * for LRO mode and the length of the first segment in GRO mode.
	 *
	 * This value may be used by GRO software to re-construct the original
	 * packet stream from the TPA packet. This is the length of all
	 * but the last segment for GRO. In LRO mode this value may be used
	 * to indicate MSS size to the stack.
	 */
	uint16_t	tpa_seg_len;
	uint16_t	unused_1;
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_V2_END_CMPL_V2                             UINT32_C(0x1)
	#define RX_TPA_V2_END_CMPL_ERRORS_MASK \
		UINT32_C(0xfffe)
	#define RX_TPA_V2_END_CMPL_ERRORS_SFT                     1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_MASK \
		UINT32_C(0xe)
	#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_SFT         1
	/* No buffer error */
	#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER \
		(UINT32_C(0x0) << 1)
	/*
	 * This error occurs when there is a fatal HW problem in
	 * the chip only. It indicates that there were not
	 * BDs on chip but that there was adequate reservation.
	 * provided by the TPA block.
	 */
	#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_NOT_ON_CHIP \
		(UINT32_C(0x2) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
	#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT \
		(UINT32_C(0x3) << 1)
	/*
	 * This error occurs when TPA block was not configured to
	 * reserve adequate BDs for TPA operations on this RX
	 * ring. All data for the TPA operation was not placed.
	 *
	 * This error can also be generated when the number of
	 * segments is not programmed correctly in TPA and the
	 * 33 total aggregation buffers allowed for the TPA
	 * operation has been exceeded.
	 */
	#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_RSV_ERROR \
		(UINT32_C(0x4) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
	#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_FLUSH \
		(UINT32_C(0x5) << 1)
	#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_LAST \
		RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	uint16_t	unused_2;
	/*
	 * This is the opaque value that was completed for the TPA start
	 * completion that corresponds to this TPA end completion.
	 */
	uint32_t	start_opaque;
} __rte_packed;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is greater than 0.
 */
/* rx_tpa_v2_abuf_cmpl (size:128b/16B) */
struct rx_tpa_v2_abuf_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_V2_ABUF_CMPL_TYPE_MASK      UINT32_C(0x3f)
	#define RX_TPA_V2_ABUF_CMPL_TYPE_SFT       0
	/*
	 * RX TPA Aggregation Buffer completion:
	 * Completion of an L2 aggregation buffer in support of
	 * TPA packet completion. Length = 16B
	 */
	#define RX_TPA_V2_ABUF_CMPL_TYPE_RX_TPA_AGG  UINT32_C(0x16)
	#define RX_TPA_V2_ABUF_CMPL_TYPE_LAST \
		RX_TPA_V2_ABUF_CMPL_TYPE_RX_TPA_AGG
	/*
	 * This is the length of the data for the packet stored in this
	 * aggregation buffer identified by the opaque value. This does not
	 * include the length of any
	 * data placed in other aggregation BDs or in the packet or buffer
	 * BDs. This length does not include any space added due to
	 * hdr_offset register during HDS placement mode.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this aggregation
	 * buffer corresponds to.
	 */
	uint32_t	opaque;
	uint16_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_V2_ABUF_CMPL_V     UINT32_C(0x1)
	/*
	 * This is the aggregation ID that the completion is associated with. Use
	 * this number to correlate the TPA agg completion with the TPA start
	 * completion and the TPA end completion.
	 */
	uint16_t	agg_id;
	uint32_t	unused_1;
} __rte_packed;

/* rx_abuf_cmpl (size:128b/16B) */
struct rx_abuf_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_ABUF_CMPL_TYPE_MASK  UINT32_C(0x3f)
	#define RX_ABUF_CMPL_TYPE_SFT   0
	/*
	 * RX Aggregation Buffer completion:
	 * Completion of an L2 aggregation buffer in support of
	 * TPA, HDS, or Jumbo packet completion. Length = 16B
	 */
	#define RX_ABUF_CMPL_TYPE_RX_AGG  UINT32_C(0x12)
	#define RX_ABUF_CMPL_TYPE_LAST   RX_ABUF_CMPL_TYPE_RX_AGG
	/*
	 * This is the length of the data for the packet stored in this
	 * aggregation buffer identified by the opaque value. This does not
	 * include the length of any
	 * data placed in other aggregation BDs or in the packet or buffer
	 * BDs. This length does not include any space added due to
	 * hdr_offset register during HDS placement mode.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this aggregation
	 * buffer corresponds to.
	 */
	uint32_t	opaque;
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_ABUF_CMPL_V     UINT32_C(0x1)
	/* unused3 is 32 b */
	uint32_t	unused_2;
} __rte_packed;

/* VEE FLUSH Completion Record (16 bytes) */
/* vee_flush (size:128b/16B) */
struct vee_flush {
	uint32_t	downstream_path_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define VEE_FLUSH_TYPE_MASK           UINT32_C(0x3f)
	#define VEE_FLUSH_TYPE_SFT            0
	/*
	 * VEE Flush Completion:
	 * This completion is inserted manually by the Primate and processed
	 * by the VEE hardware to ensure that all completions on a VEE
	 * function have been processed by the VEE hardware before FLR
	 * process is completed.
	 */
	#define VEE_FLUSH_TYPE_VEE_FLUSH        UINT32_C(0x1c)
	#define VEE_FLUSH_TYPE_LAST            VEE_FLUSH_TYPE_VEE_FLUSH
	/* downstream_path is 1 b */
	#define VEE_FLUSH_DOWNSTREAM_PATH     UINT32_C(0x40)
	/* This completion is associated with VEE Transmit */
	#define VEE_FLUSH_DOWNSTREAM_PATH_TX    (UINT32_C(0x0) << 6)
	/* This completion is associated with VEE Receive */
	#define VEE_FLUSH_DOWNSTREAM_PATH_RX    (UINT32_C(0x1) << 6)
	#define VEE_FLUSH_DOWNSTREAM_PATH_LAST VEE_FLUSH_DOWNSTREAM_PATH_RX
	/*
	 * This is an opaque value that is passed through the completion
	 * to the VEE handler SW and is used to indicate what VEE VQ or
	 * function has completed FLR processing.
	 */
	uint32_t	opaque;
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes will
	 * write 1. The odd passes will write 0.
	 */
	#define VEE_FLUSH_V     UINT32_C(0x1)
	/* unused3 is 32 b */
	uint32_t	unused_3;
} __rte_packed;

/* eject_cmpl (size:128b/16B) */
struct eject_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define EJECT_CMPL_TYPE_MASK       UINT32_C(0x3f)
	#define EJECT_CMPL_TYPE_SFT        0
	/*
	 * Statistics Ejection Completion:
	 * Completion of statistics data ejection buffer.
	 * Length = 16B
	 */
	#define EJECT_CMPL_TYPE_STAT_EJECT   UINT32_C(0x1a)
	#define EJECT_CMPL_TYPE_LAST        EJECT_CMPL_TYPE_STAT_EJECT
	#define EJECT_CMPL_FLAGS_MASK      UINT32_C(0xffc0)
	#define EJECT_CMPL_FLAGS_SFT       6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define EJECT_CMPL_FLAGS_ERROR      UINT32_C(0x40)
	/*
	 * This is the length of the statistics data stored in this
	 * buffer.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this ejection
	 * buffer corresponds to.
	 */
	uint32_t	opaque;
	uint16_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define EJECT_CMPL_V                              UINT32_C(0x1)
	#define EJECT_CMPL_ERRORS_MASK                    UINT32_C(0xfffe)
	#define EJECT_CMPL_ERRORS_SFT                     1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for statistics ejection. The statistics ejection should
	 * be treated as invalid
	 */
	#define EJECT_CMPL_ERRORS_BUFFER_ERROR_MASK        UINT32_C(0xe)
	#define EJECT_CMPL_ERRORS_BUFFER_ERROR_SFT         1
	/* No buffer error */
	#define EJECT_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER \
		(UINT32_C(0x0) << 1)
	/*
	 * Did Not Fit:
	 * Statistics did not fit into aggregation buffer provided.
	 */
	#define EJECT_CMPL_ERRORS_BUFFER_ERROR_DID_NOT_FIT \
		(UINT32_C(0x1) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
	#define EJECT_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT \
		(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
	#define EJECT_CMPL_ERRORS_BUFFER_ERROR_FLUSH \
		(UINT32_C(0x5) << 1)
	#define EJECT_CMPL_ERRORS_BUFFER_ERROR_LAST \
		EJECT_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	/* reserved16 is 16 b */
	uint16_t	reserved16;
	/* unused3 is 32 b */
	uint32_t	unused_2;
} __rte_packed;

/* hwrm_cmpl (size:128b/16B) */
struct hwrm_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_CMPL_TYPE_MASK     UINT32_C(0x3f)
	#define HWRM_CMPL_TYPE_SFT      0
	/*
	 * HWRM Command Completion:
	 * Completion of an HWRM command.
	 */
	#define HWRM_CMPL_TYPE_HWRM_DONE  UINT32_C(0x20)
	#define HWRM_CMPL_TYPE_LAST      HWRM_CMPL_TYPE_HWRM_DONE
	/* This is the sequence_id of the HWRM command that has completed. */
	uint16_t	sequence_id;
	/* unused2 is 32 b */
	uint32_t	unused_1;
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_CMPL_V     UINT32_C(0x1)
	/* unused4 is 32 b */
	uint32_t	unused_3;
} __rte_packed;

/* hwrm_fwd_req_cmpl (size:128b/16B) */
struct hwrm_fwd_req_cmpl {
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	uint16_t	req_len_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_FWD_REQ_CMPL_TYPE_MASK        UINT32_C(0x3f)
	#define HWRM_FWD_REQ_CMPL_TYPE_SFT         0
	/* Forwarded HWRM Request */
	#define HWRM_FWD_REQ_CMPL_TYPE_HWRM_FWD_REQ  UINT32_C(0x22)
	#define HWRM_FWD_REQ_CMPL_TYPE_LAST \
		HWRM_FWD_REQ_CMPL_TYPE_HWRM_FWD_REQ
	/* Length of forwarded request in bytes. */
	#define HWRM_FWD_REQ_CMPL_REQ_LEN_MASK     UINT32_C(0xffc0)
	#define HWRM_FWD_REQ_CMPL_REQ_LEN_SFT      6
	/*
	 * Source ID of this request.
	 * Typically used in forwarding requests and responses.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	source_id;
	/* unused1 is 32 b */
	uint32_t	unused0;
	/* Address of forwarded request. */
	uint32_t	req_buf_addr_v[2];
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_FWD_REQ_CMPL_V                UINT32_C(0x1)
	/* Address of forwarded request. */
	#define HWRM_FWD_REQ_CMPL_REQ_BUF_ADDR_MASK UINT32_C(0xfffffffe)
	#define HWRM_FWD_REQ_CMPL_REQ_BUF_ADDR_SFT 1
} __rte_packed;

/* hwrm_fwd_resp_cmpl (size:128b/16B) */
struct hwrm_fwd_resp_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_FWD_RESP_CMPL_TYPE_MASK         UINT32_C(0x3f)
	#define HWRM_FWD_RESP_CMPL_TYPE_SFT          0
	/* Forwarded HWRM Response */
	#define HWRM_FWD_RESP_CMPL_TYPE_HWRM_FWD_RESP  UINT32_C(0x24)
	#define HWRM_FWD_RESP_CMPL_TYPE_LAST \
		HWRM_FWD_RESP_CMPL_TYPE_HWRM_FWD_RESP
	/*
	 * Source ID of this response.
	 * Typically used in forwarding requests and responses.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	source_id;
	/* Length of forwarded response in bytes. */
	uint16_t	resp_len;
	/* unused2 is 16 b */
	uint16_t	unused_1;
	/* Address of forwarded request. */
	uint32_t	resp_buf_addr_v[2];
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_FWD_RESP_CMPL_V                 UINT32_C(0x1)
	/* Address of forwarded request. */
	#define HWRM_FWD_RESP_CMPL_RESP_BUF_ADDR_MASK UINT32_C(0xfffffffe)
	#define HWRM_FWD_RESP_CMPL_RESP_BUF_ADDR_SFT 1
} __rte_packed;

/* hwrm_async_event_cmpl (size:128b/16B) */
struct hwrm_async_event_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_TYPE_MASK            UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link status changed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_STATUS_CHANGE \
		UINT32_C(0x0)
	/* Link MTU changed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_MTU_CHANGE \
		UINT32_C(0x1)
	/* Link speed changed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CHANGE \
		UINT32_C(0x2)
	/* DCB Configuration changed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DCB_CONFIG_CHANGE \
		UINT32_C(0x3)
	/* Port connection not allowed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PORT_CONN_NOT_ALLOWED \
		UINT32_C(0x4)
	/* Link speed configuration was not allowed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CFG_NOT_ALLOWED \
		UINT32_C(0x5)
	/* Link speed configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CFG_CHANGE \
		UINT32_C(0x6)
	/* Port PHY configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PORT_PHY_CFG_CHANGE \
		UINT32_C(0x7)
	/* Reset notification to clients */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_RESET_NOTIFY \
		UINT32_C(0x8)
	/* Master function selection event */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_ERROR_RECOVERY \
		UINT32_C(0x9)
	/*
	 * An event signifying that a ring has been disabled by
	 * hw due to error.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_RING_MONITOR_MSG \
		UINT32_C(0xa)
	/* Function driver unloaded */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_FUNC_DRVR_UNLOAD \
		UINT32_C(0x10)
	/* Function driver loaded */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_FUNC_DRVR_LOAD \
		UINT32_C(0x11)
	/* Function FLR related processing has completed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_FUNC_FLR_PROC_CMPLT \
		UINT32_C(0x12)
	/* PF driver unloaded */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PF_DRVR_UNLOAD \
		UINT32_C(0x20)
	/* PF driver loaded */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PF_DRVR_LOAD \
		UINT32_C(0x21)
	/* VF Function Level Reset (FLR) */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_VF_FLR \
		UINT32_C(0x30)
	/* VF MAC Address Change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_VF_MAC_ADDR_CHANGE \
		UINT32_C(0x31)
	/* PF-VF communication channel status change. */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PF_VF_COMM_STATUS_CHANGE \
		UINT32_C(0x32)
	/* VF Configuration Change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_VF_CFG_CHANGE \
		UINT32_C(0x33)
	/* LLFC/PFC Configuration Change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LLFC_PFC_CHANGE \
		UINT32_C(0x34)
	/* Default VNIC Configuration Change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DEFAULT_VNIC_CHANGE \
		UINT32_C(0x35)
	/* HW flow aged */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_HW_FLOW_AGED \
		UINT32_C(0x36)
	/*
	 * A debug notification being posted to the driver. These
	 * notifications are purely for diagnostic purpose and should not be
	 * used for functional purpose. The driver is not supposed to act
	 * on these messages except to log/record it.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DEBUG_NOTIFICATION \
		UINT32_C(0x37)
	/*
	 * An EEM flow cached memory flush for all flows request event being
	 * posted to the PF driver.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_EEM_CACHE_FLUSH_REQ \
		UINT32_C(0x38)
	/*
	 * An EEM flow cache memory flush completion event being posted to the
	 * firmware by the PF driver. This is indication that host EEM flush
	 * has completed by the PF.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_EEM_CACHE_FLUSH_DONE \
		UINT32_C(0x39)
	/*
	 * A tcp flag action change event being posted to the PF or trusted VF
	 * driver by the firmware. The PF or trusted VF driver should query
	 * the firmware for the new TCP flag action update after receiving
	 * this async event.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_TCP_FLAG_ACTION_CHANGE \
		UINT32_C(0x3a)
	/*
	 * An EEM flow active event being posted to the PF or trusted VF driver
	 * by the firmware. The PF or trusted VF driver should update the
	 * flow's aging timer after receiving this async event.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_EEM_FLOW_ACTIVE \
		UINT32_C(0x3b)
	/*
	 * A eem cfg change event being posted to the trusted VF driver by the
	 * firmware if the parent PF EEM configuration changed.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_EEM_CFG_CHANGE \
		UINT32_C(0x3c)
	/*
	 * Deprecated.
	 * TFLIB unique default VNIC Configuration Change
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_TFLIB_DEFAULT_VNIC_CHANGE \
		UINT32_C(0x3d)
	/*
	 * Deprecated.
	 * TFLIB unique link status changed
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_TFLIB_LINK_STATUS_CHANGE \
		UINT32_C(0x3e)
	/*
	 * An event signifying completion for HWRM_FW_STATE_QUIESCE
	 * (completion, timeout, or error)
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_QUIESCE_DONE \
		UINT32_C(0x3f)
	/*
	 * An event signifying a HWRM command is in progress and its
	 * response will be deferred. This event is used on crypto controllers
	 * only.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DEFERRED_RESPONSE \
		UINT32_C(0x40)
	/*
	 * An event signifying that a PFC WatchDog configuration
	 * has changed on any port / cos.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PFC_WATCHDOG_CFG_CHANGE \
		UINT32_C(0x41)
	/*
	 * An echo request from the firmware. An echo response is expected by
	 * the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_ECHO_REQUEST \
		UINT32_C(0x42)
	/*
	 * An event from firmware indicating who has been selected as the
	 * PHC Master or secondary. Also indicates the last time a failover
	 * happens. Event will also be sent when PHC rolls over.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PHC_UPDATE \
		UINT32_C(0x43)
	/*
	 * An event from firmware showing the last PPS timestamp that has been
	 * latched.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PPS_TIMESTAMP \
		UINT32_C(0x44)
	/*
	 * An event from firmware indicating that an error has occurred.
	 * The driver should log the event so that an administrator can be
	 * aware that a problem has occurred that may need attention.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_ERROR_REPORT \
		UINT32_C(0x45)
	/*
	 * An event from firmware indicating that the programmed pacing
	 * threshold for the doorbell global FIFO has been crossed. The driver
	 * needs to take appropriate action to pace the doorbells when this
	 * event is received from the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DOORBELL_PACING_THRESHOLD \
		UINT32_C(0x46)
	/*
	 * An event from firmware indicating that the RSS capabilities have
	 * changed.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_RSS_CHANGE \
		UINT32_C(0x47)
	/*
	 * An event from firmware indicating that list of nq ids used for
	 * doorbell pacing DBQ event notification has been updated. The driver
	 * needs to take appropriate action and retrieve the new list when this
	 * event is received from the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DOORBELL_PACING_NQ_UPDATE \
		UINT32_C(0x48)
	/*
	 * An event from firmware indicating that hardware ran into an error
	 * while trying to read the host based doorbell copy region. The driver
	 * needs to take the appropriate action and maintain the corresponding
	 * doorbell copy region.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_HW_DOORBELL_RECOVERY_READ_ERROR \
		UINT32_C(0x49)
	/* Maximum Registrable event id. */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_MAX_RGTR_EVENT_ID \
		UINT32_C(0x4a)
	/*
	 * A trace log message. This contains firmware trace logs string
	 * embedded in the asynchronous message. This is an experimental
	 * event, not meant for production use at this time.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_FW_TRACE_MSG \
		UINT32_C(0xfe)
	/* HWRM Error */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_HWRM_ERROR \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_EVENT_ID_HWRM_ERROR
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} __rte_packed;

/* hwrm_async_event_cmpl_link_status_change (size:128b/16B) */
struct hwrm_async_event_cmpl_link_status_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link status changed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_ID_LINK_STATUS_CHANGE \
		UINT32_C(0x0)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_ID_LINK_STATUS_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates link status change */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE \
		UINT32_C(0x1)
	/*
	 * If this bit set to 0, then it indicates that the link
	 * was up and it went down.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE_DOWN \
		UINT32_C(0x0)
	/*
	 * If this bit is set to 1, then it indicates that the link
	 * was down and it went up.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE_UP \
		UINT32_C(0x1)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE_LAST \
		HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE_UP
	/* Indicates the physical port this link status change occur */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PORT_MASK \
		UINT32_C(0xe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PORT_SFT \
		1
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PORT_ID_MASK \
		UINT32_C(0xffff0)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PORT_ID_SFT \
		4
	/* Indicates the physical function this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PF_ID_MASK \
		UINT32_C(0xff00000)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PF_ID_SFT \
		20
} __rte_packed;

/* hwrm_async_event_cmpl_link_mtu_change (size:128b/16B) */
struct hwrm_async_event_cmpl_link_mtu_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link MTU changed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_ID_LINK_MTU_CHANGE \
		UINT32_C(0x1)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_ID_LINK_MTU_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* The new MTU of the link in bytes. */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_DATA1_NEW_MTU_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_DATA1_NEW_MTU_SFT 0
} __rte_packed;

/* hwrm_async_event_cmpl_link_speed_change (size:128b/16B) */
struct hwrm_async_event_cmpl_link_speed_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link speed changed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_ID_LINK_SPEED_CHANGE \
		UINT32_C(0x2)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_ID_LINK_SPEED_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/*
	 * When this bit is '1', the link was forced to the
	 * force_link_speed value.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_FORCE \
		UINT32_C(0x1)
	/* The new link speed in 100 Mbps units. */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_MASK \
		UINT32_C(0xfffe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_SFT \
		1
	/* 100Mb link speed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_100MB \
		(UINT32_C(0x1) << 1)
	/* 1Gb link speed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_1GB \
		(UINT32_C(0xa) << 1)
	/* 2Gb link speed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_2GB \
		(UINT32_C(0x14) << 1)
	/* 25Gb link speed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_2_5GB \
		(UINT32_C(0x19) << 1)
	/* 10Gb link speed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_10GB \
		(UINT32_C(0x64) << 1)
	/* 20Mb link speed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_20GB \
		(UINT32_C(0xc8) << 1)
	/* 25Gb link speed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_25GB \
		(UINT32_C(0xfa) << 1)
	/* 40Gb link speed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_40GB \
		(UINT32_C(0x190) << 1)
	/* 50Gb link speed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_50GB \
		(UINT32_C(0x1f4) << 1)
	/* 100Gb link speed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_100GB \
		(UINT32_C(0x3e8) << 1)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_LAST \
		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_100GB
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_PORT_ID_MASK \
		UINT32_C(0xffff0000)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_PORT_ID_SFT \
		16
} __rte_packed;

/* hwrm_async_event_cmpl_dcb_config_change (size:128b/16B) */
struct hwrm_async_event_cmpl_dcb_config_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* DCB Configuration changed */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_ID_DCB_CONFIG_CHANGE \
		UINT32_C(0x3)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_ID_DCB_CONFIG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	/* ETS configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA2_ETS \
		UINT32_C(0x1)
	/* PFC configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA2_PFC \
		UINT32_C(0x2)
	/* APP configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA2_APP \
		UINT32_C(0x4)
	/* DSCP configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA2_DSCP \
		UINT32_C(0x8)
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_PORT_ID_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_PORT_ID_SFT \
		0
	/* Priority recommended for RoCE traffic */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_MASK \
		UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_SFT \
		16
	/* none is 255 */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_NONE \
		(UINT32_C(0xff) << 16)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_LAST \
		HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_NONE
	/* Priority recommended for L2 traffic */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_MASK \
		UINT32_C(0xff000000)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_SFT \
		24
	/* none is 255 */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_NONE \
		(UINT32_C(0xff) << 24)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_LAST \
		HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_NONE
} __rte_packed;

/* hwrm_async_event_cmpl_port_conn_not_allowed (size:128b/16B) */
struct hwrm_async_event_cmpl_port_conn_not_allowed {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Port connection not allowed */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_ID_PORT_CONN_NOT_ALLOWED \
		UINT32_C(0x4)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_ID_PORT_CONN_NOT_ALLOWED
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_PORT_ID_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_PORT_ID_SFT \
		0
	/*
	 * This value indicates the current port level enforcement policy
	 * for the optics module when there is an optical module mismatch
	 * and port is not connected.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_MASK \
		UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_SFT \
		16
	/* No enforcement */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_NONE \
		(UINT32_C(0x0) << 16)
	/* Disable Transmit side Laser. */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_DISABLETX \
		(UINT32_C(0x1) << 16)
	/* Raise a warning message. */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_WARNINGMSG \
		(UINT32_C(0x2) << 16)
	/* Power down the module. */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_PWRDOWN \
		(UINT32_C(0x3) << 16)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_LAST \
		HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_PWRDOWN
} __rte_packed;

/* hwrm_async_event_cmpl_link_speed_cfg_not_allowed (size:128b/16B) */
struct hwrm_async_event_cmpl_link_speed_cfg_not_allowed {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link speed configuration was not allowed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_ID_LINK_SPEED_CFG_NOT_ALLOWED \
		UINT32_C(0x5)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_ID_LINK_SPEED_CFG_NOT_ALLOWED
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_DATA1_PORT_ID_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_DATA1_PORT_ID_SFT \
		0
} __rte_packed;

/* hwrm_async_event_cmpl_link_speed_cfg_change (size:128b/16B) */
struct hwrm_async_event_cmpl_link_speed_cfg_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link speed configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_ID_LINK_SPEED_CFG_CHANGE \
		UINT32_C(0x6)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_ID_LINK_SPEED_CFG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_DATA1_PORT_ID_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_DATA1_PORT_ID_SFT \
		0
	/*
	 * If set to 1, it indicates that the supported link speeds
	 * configuration on the port has changed.
	 * If set to 0, then there is no change in supported link speeds
	 * configuration.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_DATA1_SUPPORTED_LINK_SPEEDS_CHANGE \
		UINT32_C(0x10000)
	/*
	 * If set to 1, it indicates that the link speed configuration
	 * on the port has become illegal or invalid.
	 * If set to 0, then the link speed configuration on the port is
	 * legal or valid.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_DATA1_ILLEGAL_LINK_SPEED_CFG \
		UINT32_C(0x20000)
} __rte_packed;

/* hwrm_async_event_cmpl_port_phy_cfg_change (size:128b/16B) */
struct hwrm_async_event_cmpl_port_phy_cfg_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Port PHY configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_ID_PORT_PHY_CFG_CHANGE \
		UINT32_C(0x7)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_ID_PORT_PHY_CFG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_PORT_ID_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_PORT_ID_SFT \
		0
	/*
	 * If set to 1, it indicates that the FEC
	 * configuration on the port has changed.
	 * If set to 0, then there is no change in FEC configuration.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_FEC_CFG_CHANGE \
		UINT32_C(0x10000)
	/*
	 * If set to 1, it indicates that the EEE configuration
	 * on the port has changed.
	 * If set to 0, then there is no change in EEE configuration
	 * on the port.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_EEE_CFG_CHANGE \
		UINT32_C(0x20000)
	/*
	 * If set to 1, it indicates that the pause configuration
	 * on the PHY has changed.
	 * If set to 0, then there is no change in the pause
	 * configuration on the PHY.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_PAUSE_CFG_CHANGE \
		UINT32_C(0x40000)
} __rte_packed;

/* hwrm_async_event_cmpl_reset_notify (size:128b/16B) */
struct hwrm_async_event_cmpl_reset_notify {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notify clients of imminent reset. */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_ID_RESET_NOTIFY \
		UINT32_C(0x8)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_ID_RESET_NOTIFY
	/* Event specific data. The data is for internal debug use only. */
	uint32_t	event_data2;
	/*
	 * These bits indicate the status as being reported by the firmware.
	 * This value is exactly the same as status code in fw_status register.
	 * If the status code is equal to 0x8000, then the reset is initiated
	 * by the Host using the FW_RESET command when the FW is in a healthy
	 * state. If the status code is not equal to 0x8000, then the reset is
	 * initiated by the FW to recover from the error or FATAL state.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA2_FW_STATUS_CODE_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA2_FW_STATUS_CODE_SFT \
		0
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_OPAQUE_SFT 1
	/*
	 * 8-lsb timestamp (100-msec resolution)
	 * The Minimum time required for the Firmware readiness after sending
	 * this notification to the driver instances.
	 */
	uint8_t	timestamp_lo;
	/*
	 * 16-lsb timestamp (100-msec resolution)
	 * The Maximum Firmware Reset bail out value in the order of 100
	 * milliseconds. The driver instances will use this value to reinitiate
	 * the registration process again if the core firmware didnt set the
	 * state bit.
	 */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates driver action requested */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_SFT \
		0
	/*
	 * If set to 1, it indicates that the l2 client should
	 * stop sending in band traffic to Nitro.
	 * if set to 0, there is no change in L2 client behavior.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_DRIVER_STOP_TX_QUEUE \
		UINT32_C(0x1)
	/*
	 * If set to 1, it indicates that the L2 client should
	 * bring down the interface.
	 * If set to 0, then there is no change in L2 client behavior.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_DRIVER_IFDOWN \
		UINT32_C(0x2)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_LAST \
		HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_DRIVER_IFDOWN
	/* Indicates reason for reset. */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_MASK \
		UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_SFT \
		8
	/* A management client has requested reset. */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_MANAGEMENT_RESET_REQUEST \
		(UINT32_C(0x1) << 8)
	/* A fatal firmware exception has occurred. */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_FW_EXCEPTION_FATAL \
		(UINT32_C(0x2) << 8)
	/* A non-fatal firmware exception has occurred. */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_FW_EXCEPTION_NON_FATAL \
		(UINT32_C(0x3) << 8)
	/* Fast reset */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_FAST_RESET \
		(UINT32_C(0x4) << 8)
	/*
	 * Reset was a result of a firmware activation. That is, the
	 * fw_activation flag was set in a FW_RESET operation.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_FW_ACTIVATION \
		(UINT32_C(0x5) << 8)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_LAST \
		HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_FW_ACTIVATION
	/*
	 * Minimum time before driver should attempt access - units 100ms
	 * ticks.
	 * Range 0-65535
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DELAY_IN_100MS_TICKS_MASK \
		UINT32_C(0xffff0000)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DELAY_IN_100MS_TICKS_SFT \
		16
} __rte_packed;

/* hwrm_async_event_cmpl_error_recovery (size:128b/16B) */
struct hwrm_async_event_cmpl_error_recovery {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message can be used for selecting or
	 * deselecting master function for error recovery,
	 * and to communicate to all the functions whether error recovery
	 * was enabled/disabled.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_ID_ERROR_RECOVERY \
		UINT32_C(0x9)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_ID_ERROR_RECOVERY
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates driver action requested */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_DATA1_FLAGS_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_DATA1_FLAGS_SFT \
		0
	/*
	 * If set to 1, this function is selected as Master function.
	 * This function has responsibility to do 'chip reset' when it
	 * detects a fatal error. If set to 0, master function functionality
	 * is disabled on this function.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_DATA1_FLAGS_MASTER_FUNC \
		UINT32_C(0x1)
	/*
	 * If set to 1, error recovery is enabled.
	 * If set to 0, error recovery is disabled.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_DATA1_FLAGS_RECOVERY_ENABLED \
		UINT32_C(0x2)
} __rte_packed;

/* hwrm_async_event_cmpl_ring_monitor_msg (size:128b/16B) */
struct hwrm_async_event_cmpl_ring_monitor_msg {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Ring Monitor Message. */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_ID_RING_MONITOR_MSG \
		UINT32_C(0xa)
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_ID_RING_MONITOR_MSG
	/* Event specific data */
	uint32_t	event_data2;
	/* Type of Ring disabled. */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_SFT \
		0
	/* tx ring disabled. */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_TX \
		UINT32_C(0x0)
	/* rx ring disabled. */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_RX \
		UINT32_C(0x1)
	/* cmpl ring disabled. */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_CMPL \
		UINT32_C(0x2)
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_CMPL
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/*
	 * Event specific data. If ring_type_disabled indicates a tx, rx or cmpl
	 * then this field will indicate the ring id.
	 */
	uint32_t	event_data1;
} __rte_packed;

/* hwrm_async_event_cmpl_func_drvr_unload (size:128b/16B) */
struct hwrm_async_event_cmpl_func_drvr_unload {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Function driver unloaded */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_ID_FUNC_DRVR_UNLOAD \
		UINT32_C(0x10)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_ID_FUNC_DRVR_UNLOAD
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Function ID */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_DATA1_FUNC_ID_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_DATA1_FUNC_ID_SFT \
		0
} __rte_packed;

/* hwrm_async_event_cmpl_func_drvr_load (size:128b/16B) */
struct hwrm_async_event_cmpl_func_drvr_load {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Function driver loaded */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_ID_FUNC_DRVR_LOAD \
		UINT32_C(0x11)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_ID_FUNC_DRVR_LOAD
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Function ID */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_DATA1_FUNC_ID_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_DATA1_FUNC_ID_SFT 0
} __rte_packed;

/* hwrm_async_event_cmpl_func_flr_proc_cmplt (size:128b/16B) */
struct hwrm_async_event_cmpl_func_flr_proc_cmplt {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Function FLR related processing has completed */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_ID_FUNC_FLR_PROC_CMPLT \
		UINT32_C(0x12)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_ID_FUNC_FLR_PROC_CMPLT
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Function ID */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_DATA1_FUNC_ID_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_DATA1_FUNC_ID_SFT \
		0
} __rte_packed;

/* hwrm_async_event_cmpl_pf_drvr_unload (size:128b/16B) */
struct hwrm_async_event_cmpl_pf_drvr_unload {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* PF driver unloaded */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_ID_PF_DRVR_UNLOAD \
		UINT32_C(0x20)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_ID_PF_DRVR_UNLOAD
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PF ID */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_DATA1_FUNC_ID_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_DATA1_FUNC_ID_SFT 0
	/* Indicates the physical port this pf belongs to */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_DATA1_PORT_MASK \
		UINT32_C(0x70000)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_DATA1_PORT_SFT    16
} __rte_packed;

/* hwrm_async_event_cmpl_pf_drvr_load (size:128b/16B) */
struct hwrm_async_event_cmpl_pf_drvr_load {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* PF driver loaded */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_ID_PF_DRVR_LOAD \
		UINT32_C(0x21)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_ID_PF_DRVR_LOAD
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PF ID */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_DATA1_FUNC_ID_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_DATA1_FUNC_ID_SFT 0
	/* Indicates the physical port this pf belongs to */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_DATA1_PORT_MASK \
		UINT32_C(0x70000)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_DATA1_PORT_SFT    16
} __rte_packed;

/* hwrm_async_event_cmpl_vf_flr (size:128b/16B) */
struct hwrm_async_event_cmpl_vf_flr {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* VF Function Level Reset (FLR) */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_ID_VF_FLR UINT32_C(0x30)
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_ID_VF_FLR
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* VF ID */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_DATA1_VF_ID_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_DATA1_VF_ID_SFT 0
	/* Indicates the physical function this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_DATA1_PF_ID_MASK \
		UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_DATA1_PF_ID_SFT 16
} __rte_packed;

/* hwrm_async_event_cmpl_vf_mac_addr_change (size:128b/16B) */
struct hwrm_async_event_cmpl_vf_mac_addr_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* VF MAC Address Change */
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_ID_VF_MAC_ADDR_CHANGE \
		UINT32_C(0x31)
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_ID_VF_MAC_ADDR_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* VF ID */
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_DATA1_VF_ID_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_DATA1_VF_ID_SFT \
		0
} __rte_packed;

/* hwrm_async_event_cmpl_pf_vf_comm_status_change (size:128b/16B) */
struct hwrm_async_event_cmpl_pf_vf_comm_status_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* PF-VF communication channel status change. */
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_EVENT_ID_PF_VF_COMM_STATUS_CHANGE \
		UINT32_C(0x32)
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_EVENT_ID_PF_VF_COMM_STATUS_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/*
	 * If this bit is set to 1, then it indicates that the PF-VF
	 * communication was lost and it is established.
	 * If this bit set to 0, then it indicates that the PF-VF
	 * communication was established and it is lost.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_EVENT_DATA1_COMM_ESTABLISHED \
		UINT32_C(0x1)
} __rte_packed;

/* hwrm_async_event_cmpl_vf_cfg_change (size:128b/16B) */
struct hwrm_async_event_cmpl_vf_cfg_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* VF Configuration Change */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_ID_VF_CFG_CHANGE \
		UINT32_C(0x33)
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_ID_VF_CFG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	/*
	 * This value indicates the VF ID of the VF whose configuration
	 * is changing if this async. event is sent to the parent PF.
	 * The firmware supports sending this to the parent PF if the
	 * `hwrm_func_qcaps.vf_cfg_async_for_pf_supported` value is 1.
	 * This value is undefined when the async. event is sent to the
	 * VF.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA2_VF_ID_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA2_VF_ID_SFT 0
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/*
	 * Each flag provided in this field indicates a specific VF
	 * configuration change. At least one of these flags shall be set to 1
	 * when an asynchronous event completion of this type is provided
	 * by the HWRM.
	 */
	uint32_t	event_data1;
	/*
	 * If this bit is set to 1, then the value of MTU
	 * was changed on this VF.
	 * If set to 0, then this bit should be ignored.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_MTU_CHANGE \
		UINT32_C(0x1)
	/*
	 * If this bit is set to 1, then the value of MRU
	 * was changed on this VF.
	 * If set to 0, then this bit should be ignored.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_MRU_CHANGE \
		UINT32_C(0x2)
	/*
	 * If this bit is set to 1, then the value of default MAC
	 * address was changed on this VF.
	 * If set to 0, then this bit should be ignored.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_DFLT_MAC_ADDR_CHANGE \
		UINT32_C(0x4)
	/*
	 * If this bit is set to 1, then the value of default VLAN
	 * was changed on this VF.
	 * If set to 0, then this bit should be ignored.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_DFLT_VLAN_CHANGE \
		UINT32_C(0x8)
	/*
	 * If this bit is set to 1, then the value of trusted VF enable
	 * was changed on this VF.
	 * If set to 0, then this bit should be ignored.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_TRUSTED_VF_CFG_CHANGE \
		UINT32_C(0x10)
} __rte_packed;

/* hwrm_async_event_cmpl_llfc_pfc_change (size:128b/16B) */
struct hwrm_async_event_cmpl_llfc_pfc_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* unused1 is 10 b */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_UNUSED1_MASK \
		UINT32_C(0xffc0)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_UNUSED1_SFT          6
	/* Identifiers of events. */
	uint16_t	event_id;
	/* LLFC/PFC Configuration Change */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_ID_LLFC_PFC_CHANGE \
		UINT32_C(0x34)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_ID_LLFC_PFC_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates llfc pfc status change */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_MASK \
		UINT32_C(0x3)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_SFT \
		0
	/*
	 * If this field set to 1, then it indicates that llfc is
	 * enabled.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_LLFC \
		UINT32_C(0x1)
	/*
	 * If this field is set to 2, then it indicates that pfc
	 * is enabled.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_PFC \
		UINT32_C(0x2)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_LAST \
		HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_PFC
	/* Indicates the physical port this llfc pfc change occur */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_PORT_MASK \
		UINT32_C(0x1c)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_PORT_SFT \
		2
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_PORT_ID_MASK \
		UINT32_C(0x1fffe0)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_PORT_ID_SFT \
		5
} __rte_packed;

/* hwrm_async_event_cmpl_default_vnic_change (size:128b/16B) */
struct hwrm_async_event_cmpl_default_vnic_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* unused1 is 10 b */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_UNUSED1_MASK \
		UINT32_C(0xffc0)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_UNUSED1_SFT \
		6
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of a default vnic allocation or free */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_ID_ALLOC_FREE_NOTIFICATION \
		UINT32_C(0x35)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_ID_ALLOC_FREE_NOTIFICATION
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates default vnic configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_MASK \
		UINT32_C(0x3)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_SFT \
		0
	/*
	 * If this field is set to 1, then it indicates that
	 * a default VNIC has been allocate.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_DEF_VNIC_ALLOC \
		UINT32_C(0x1)
	/*
	 * If this field is set to 2, then it indicates that
	 * a default VNIC has been freed.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_DEF_VNIC_FREE \
		UINT32_C(0x2)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_LAST \
		HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_DEF_VNIC_FREE
	/* Indicates the physical function this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_PF_ID_MASK \
		UINT32_C(0x3fc)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_PF_ID_SFT \
		2
	/* Indicates the virtual function this event occurred on */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_VF_ID_MASK \
		UINT32_C(0x3fffc00)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_VF_ID_SFT \
		10
} __rte_packed;

/* hwrm_async_event_cmpl_hw_flow_aged (size:128b/16B) */
struct hwrm_async_event_cmpl_hw_flow_aged {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of a hw flow aged */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_ID_HW_FLOW_AGED \
		UINT32_C(0x36)
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_ID_HW_FLOW_AGED
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates flow ID this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_ID_MASK \
		UINT32_C(0x7fffffff)
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_ID_SFT \
		0
	/* Indicates flow direction this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_DIRECTION \
		UINT32_C(0x80000000)
	/*
	 * If this bit set to 0, then it indicates that the aged
	 * event was rx flow.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_DIRECTION_RX \
		(UINT32_C(0x0) << 31)
	/*
	 * If this bit is set to 1, then it indicates that the aged
	 * event was tx flow.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_DIRECTION_TX \
		(UINT32_C(0x1) << 31)
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_DIRECTION_LAST \
		HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_DIRECTION_TX
} __rte_packed;

/* hwrm_async_event_cmpl_eem_cache_flush_req (size:128b/16B) */
struct hwrm_async_event_cmpl_eem_cache_flush_req {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of a eem_cache_flush request */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_EVENT_ID_EEM_CACHE_FLUSH_REQ \
		UINT32_C(0x38)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_EVENT_ID_EEM_CACHE_FLUSH_REQ
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} __rte_packed;

/* hwrm_async_event_cmpl_eem_cache_flush_done (size:128b/16B) */
struct hwrm_async_event_cmpl_eem_cache_flush_done {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * Notification of a host eem_cache_flush has completed. This event
	 * is generated by the host driver.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_EVENT_ID_EEM_CACHE_FLUSH_DONE \
		UINT32_C(0x39)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_EVENT_ID_EEM_CACHE_FLUSH_DONE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates function ID that this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_EVENT_DATA1_FID_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_EVENT_DATA1_FID_SFT \
		0
} __rte_packed;

/* hwrm_async_event_cmpl_tcp_flag_action_change (size:128b/16B) */
struct hwrm_async_event_cmpl_tcp_flag_action_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of tcp flag action change */
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_EVENT_ID_TCP_FLAG_ACTION_CHANGE \
		UINT32_C(0x3a)
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_EVENT_ID_TCP_FLAG_ACTION_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} __rte_packed;

/* hwrm_async_event_cmpl_eem_flow_active (size:128b/16B) */
struct hwrm_async_event_cmpl_eem_flow_active {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of an active eem flow */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_ID_EEM_FLOW_ACTIVE \
		UINT32_C(0x3b)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_ID_EEM_FLOW_ACTIVE
	/* Event specific data */
	uint32_t	event_data2;
	/* Indicates the 2nd global id this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_GLOBAL_ID_2_MASK \
		UINT32_C(0x3fffffff)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_GLOBAL_ID_2_SFT \
		0
	/*
	 * Indicates flow direction of the flow identified by
	 * the global_id_2.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_FLOW_DIRECTION \
		UINT32_C(0x40000000)
	/* If this bit is set to 0, then it indicates that this rx flow. */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_FLOW_DIRECTION_RX \
		(UINT32_C(0x0) << 30)
	/* If this bit is set to 1, then it indicates that this tx flow. */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_FLOW_DIRECTION_TX \
		(UINT32_C(0x1) << 30)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_FLOW_DIRECTION_LAST \
		HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_FLOW_DIRECTION_TX
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates the 1st global id this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_GLOBAL_ID_1_MASK \
		UINT32_C(0x3fffffff)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_GLOBAL_ID_1_SFT \
		0
	/*
	 * Indicates flow direction of the flow identified by the
	 * global_id_1.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_FLOW_DIRECTION \
		UINT32_C(0x40000000)
	/* If this bit is set to 0, then it indicates that this is rx flow. */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_FLOW_DIRECTION_RX \
		(UINT32_C(0x0) << 30)
	/* If this bit is set to 1, then it indicates that this is tx flow. */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_FLOW_DIRECTION_TX \
		(UINT32_C(0x1) << 30)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_FLOW_DIRECTION_LAST \
		HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_FLOW_DIRECTION_TX
	/*
	 * Indicates EEM flow aging mode this event occurred on. If
	 * this bit is set to 0, the event_data1 is the EEM global
	 * ID. If this bit is set to 1, the event_data1 is the number
	 * of global ID in the context memory.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_MODE \
		UINT32_C(0x80000000)
	/* EEM flow aging mode 0. */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_MODE_0 \
		(UINT32_C(0x0) << 31)
	/* EEM flow aging mode 1. */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_MODE_1 \
		(UINT32_C(0x1) << 31)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_MODE_LAST \
		HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_MODE_1
} __rte_packed;

/* hwrm_async_event_cmpl_eem_cfg_change (size:128b/16B) */
struct hwrm_async_event_cmpl_eem_cfg_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of EEM configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_EVENT_ID_EEM_CFG_CHANGE \
		UINT32_C(0x3c)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_EVENT_ID_EEM_CFG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/*
	 * Value of 1 to indicate EEM TX configuration is enabled. Value of
	 * 0 to indicate the EEM TX configuration is disabled.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_EVENT_DATA1_EEM_TX_ENABLE \
		UINT32_C(0x1)
	/*
	 * Value of 1 to indicate EEM RX configuration is enabled. Value of 0
	 * to indicate the EEM RX configuration is disabled.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_EVENT_DATA1_EEM_RX_ENABLE \
		UINT32_C(0x2)
} __rte_packed;

/* hwrm_async_event_cmpl_quiesce_done (size:128b/16B) */
struct hwrm_async_event_cmpl_quiesce_done {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* An event signifying completion of HWRM_FW_STATE_QUIESCE */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_ID_QUIESCE_DONE \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_ID_QUIESCE_DONE
	/* Event specific data */
	uint32_t	event_data2;
	/* Status of HWRM_FW_STATE_QUIESCE completion */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_SFT \
		0
	/*
	 * The quiesce operation started by HWRM_FW_STATE_QUIESCE
	 * completed successfully.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_SUCCESS \
		UINT32_C(0x0)
	/*
	 * The quiesce operation started by HWRM_FW_STATE_QUIESCE timed
	 * out.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_TIMEOUT \
		UINT32_C(0x1)
	/*
	 * The quiesce operation started by HWRM_FW_STATE_QUIESCE
	 * encountered an error.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_ERROR \
		UINT32_C(0x2)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_LAST \
		HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_ERROR
	/* opaque is 8 b */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_OPAQUE_MASK \
		UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_OPAQUE_SFT \
		8
	/*
	 * Additional information about internal hardware state related to
	 * idle/quiesce state.  QUIESCE may succeed per quiesce_status
	 * regardless of idle_state_flags.  If QUIESCE fails, the host may
	 * inspect idle_state_flags to determine whether a retry is warranted.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_MASK \
		UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_SFT \
		16
	/*
	 * Failure to quiesce is caused by host not updating the NQ consumer
	 * index.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_INCOMPLETE_NQ \
		UINT32_C(0x10000)
	/* Flag 1 indicating partial non-idle state. */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_IDLE_STATUS_1 \
		UINT32_C(0x20000)
	/* Flag 2 indicating partial non-idle state. */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_IDLE_STATUS_2 \
		UINT32_C(0x40000)
	/* Flag 3 indicating partial non-idle state. */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_IDLE_STATUS_3 \
		UINT32_C(0x80000)
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Time stamp for error event */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA1_TIMESTAMP \
		UINT32_C(0x1)
} __rte_packed;

/* hwrm_async_event_cmpl_deferred_response (size:128b/16B) */
struct hwrm_async_event_cmpl_deferred_response {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * An event signifying a HWRM command is in progress and its
	 * response will be deferred
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_EVENT_ID_DEFERRED_RESPONSE \
		UINT32_C(0x40)
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_EVENT_ID_DEFERRED_RESPONSE
	/* Event specific data */
	uint32_t	event_data2;
	/*
	 * The PF's mailbox is clear to issue another command.
	 * A command with this seq_id is still in progress
	 * and will return a regular HWRM completion when done.
	 * 'event_data1' field, if non-zero, contains the estimated
	 * execution time for the command.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_EVENT_DATA2_SEQ_ID_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_EVENT_DATA2_SEQ_ID_SFT \
		0
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Estimated remaining time of command execution in ms (if not zero) */
	uint32_t	event_data1;
} __rte_packed;

/* hwrm_async_event_cmpl_pfc_watchdog_cfg_change (size:128b/16B) */
struct hwrm_async_event_cmpl_pfc_watchdog_cfg_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* PFC watchdog configuration change for given port/cos */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_ID_PFC_WATCHDOG_CFG_CHANGE \
		UINT32_C(0x41)
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_ID_PFC_WATCHDOG_CFG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/*
	 * 1 in bit position X indicates PFC watchdog should
	 * be on for COSX
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_SFT \
		0
	/* 1 means PFC WD for COS0 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS0 \
		UINT32_C(0x1)
	/* 1 means PFC WD for COS1 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS1 \
		UINT32_C(0x2)
	/* 1 means PFC WD for COS2 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS2 \
		UINT32_C(0x4)
	/* 1 means PFC WD for COS3 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS3 \
		UINT32_C(0x8)
	/* 1 means PFC WD for COS4 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS4 \
		UINT32_C(0x10)
	/* 1 means PFC WD for COS5 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS5 \
		UINT32_C(0x20)
	/* 1 means PFC WD for COS6 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS6 \
		UINT32_C(0x40)
	/* 1 means PFC WD for COS7 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS7 \
		UINT32_C(0x80)
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PORT_ID_MASK \
		UINT32_C(0xffff00)
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PORT_ID_SFT \
		8
} __rte_packed;

/* hwrm_async_event_cmpl_echo_request (size:128b/16B) */
struct hwrm_async_event_cmpl_echo_request {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * An echo request from the firmware. An echo response is expected by
	 * the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_EVENT_ID_ECHO_REQUEST \
		UINT32_C(0x42)
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_EVENT_ID_ECHO_REQUEST
	/* Event specific data that should be provided in the echo response */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data that should be provided in the echo response */
	uint32_t	event_data1;
} __rte_packed;

/* hwrm_async_event_cmpl_phc_update (size:128b/16B) */
struct hwrm_async_event_cmpl_phc_update {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async event is used to notify driver of changes
	 * in PHC master. Only one master function can configure
	 * PHC.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_ID_PHC_UPDATE \
		UINT32_C(0x43)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_ID_PHC_UPDATE
	/* Event specific data */
	uint32_t	event_data2;
	/* This field provides the current master function. */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA2_PHC_MASTER_FID_MASK \
		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA2_PHC_MASTER_FID_SFT \
		0
	/* This field provides the current secondary function. */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA2_PHC_SEC_FID_MASK \
		UINT32_C(0xffff0000)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA2_PHC_SEC_FID_SFT \
		16
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates to the driver the type of PHC event. */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_MASK \
		UINT32_C(0xf)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_SFT \
		0
	/*
	 * Indicates PHC Master selection event. The master fid is
	 * specified in event_data2.phc_master_fid.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_PHC_MASTER \
		UINT32_C(0x1)
	/*
	 * Indicates PHC Secondary selection event. The secondary fid is
	 * specified in event_data2.phc_sec_fid.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_PHC_SECONDARY \
		UINT32_C(0x2)
	/*
	 * Indicates PHC failover event. Failover happens from
	 * event_data2.phc_master_fid to event_data2.phc_sec_fid.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_PHC_FAILOVER \
		UINT32_C(0x3)
	/*
	 * Indicates that the 64bit Real time clock upper 16bits
	 * have been updated due to PHC rollover. The updated
	 * upper 16bits is in event_data1.phc_time_msb
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_PHC_RTC_UPDATE \
		UINT32_C(0x4)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_LAST \
		HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_PHC_RTC_UPDATE
	/*
	 * This field provides the upper 16bits of the 64bit real
	 * time clock.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_PHC_TIME_MSB_MASK \
		UINT32_C(0xffff0)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_PHC_TIME_MSB_SFT \
		4
} __rte_packed;

/* hwrm_async_event_cmpl_pps_timestamp (size:128b/16B) */
struct hwrm_async_event_cmpl_pps_timestamp {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message can be used to inform
	 * driver of the latest PPS timestamp that has been latched.
	 * When driver enables PPS event, Firmware will generate
	 * PPS timestamps every second, Firmware informs driver
	 * of this timestamp through the async event.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_ID_PPS_TIMESTAMP \
		UINT32_C(0x44)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_ID_PPS_TIMESTAMP
	/* Event specific data */
	uint32_t	event_data2;
	/* Indicates the PPS event type */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE \
		UINT32_C(0x1)
	/* This is an internal event. */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE_INTERNAL \
		UINT32_C(0x0)
	/* This is an external event. */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE_EXTERNAL \
		UINT32_C(0x1)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE_EXTERNAL
	/*
	 * Indicates the pin number on which the event is
	 * received.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_PIN_NUMBER_MASK \
		UINT32_C(0xe)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_PIN_NUMBER_SFT \
		1
	/*
	 * Contains bits[47:32] of the upper PPS timestamp.
	 * Lower 32 bits are in event_data1. Together they
	 * provide the 48 bit PPS timestamp.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_PPS_TIMESTAMP_UPPER_MASK \
		UINT32_C(0xffff0)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_PPS_TIMESTAMP_UPPER_SFT \
		4
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Contains the lower 32 bits of the PPS timestamp. */
	uint32_t	event_data1;
	/* Contains the lower 32 bit PPS timestamp */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA1_PPS_TIMESTAMP_LOWER_MASK \
		UINT32_C(0xffffffff)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA1_PPS_TIMESTAMP_LOWER_SFT \
		0
} __rte_packed;

/* hwrm_async_event_cmpl_error_report (size:128b/16B) */
struct hwrm_async_event_cmpl_error_report {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform
	 * the driver that an error has occurred which may need
	 * the attention of the administrator.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_EVENT_ID_ERROR_REPORT \
		UINT32_C(0x45)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_EVENT_ID_ERROR_REPORT
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/*
	 * Indicates the type of error being reported. See section on Error
	 * Report event error_types for details on each error.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_EVENT_DATA1_ERROR_TYPE_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_EVENT_DATA1_ERROR_TYPE_SFT 0
} __rte_packed;

/* hwrm_async_event_cmpl_doorbell_pacing_threshold (size:128b/16B) */
struct hwrm_async_event_cmpl_doorbell_pacing_threshold {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform the driver
	 * that the programmable pacing threshold for the doorbell FIFO is
	 * reached. The driver will take appropriate action to pace the
	 * doorbells when this async event is received from the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_EVENT_ID_DOORBELL_PACING_THRESHOLD \
		UINT32_C(0x46)
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_EVENT_ID_DOORBELL_PACING_THRESHOLD
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} __rte_packed;

/* hwrm_async_event_cmpl_rss_change (size:128b/16B) */
struct hwrm_async_event_cmpl_rss_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform the driver
	 * that the RSS capabilities have changed. The driver will need
	 * to query hwrm_vnic_qcaps.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_EVENT_ID_RSS_CHANGE \
		UINT32_C(0x47)
	#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_EVENT_ID_RSS_CHANGE
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} __rte_packed;

/* hwrm_async_event_cmpl_doorbell_pacing_nq_update (size:128b/16B) */
struct hwrm_async_event_cmpl_doorbell_pacing_nq_update {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * An event from firmware indicating that list of nq ids used for
	 * doorbell pacing DBQ event notification has been updated. The driver
	 * needs to take appropriate action and retrieve the new list when this
	 * event is received from the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_EVENT_ID_DOORBELL_PACING_NQ_UPDATE \
		UINT32_C(0x48)
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_EVENT_ID_DOORBELL_PACING_NQ_UPDATE
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} __rte_packed;

/* hwrm_async_event_cmpl_hw_doorbell_recovery_read_error (size:128b/16B) */
struct hwrm_async_event_cmpl_hw_doorbell_recovery_read_error {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform the driver
	 * that hardware ran into an error while trying to read the host
	 * based doorbell copy region. The driver will take the appropriate
	 * action to maintain the corresponding functions doorbell copy
	 * region in the correct format.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_ID_HW_DOORBELL_RECOVERY_READ_ERROR \
		UINT32_C(0x49)
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_ID_HW_DOORBELL_RECOVERY_READ_ERROR
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_OPAQUE_SFT \
		1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/*
	 * Indicates that there is an error while reading the doorbell copy
	 * regions.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_DATA1_READ_ERROR_FLAGS_MASK \
		UINT32_C(0xf)
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_DATA1_READ_ERROR_FLAGS_SFT \
		0
	/*
	 * If set to 1, indicates that there is an error while reading the
	 * SQ doorbell copy region for this function.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_DATA1_READ_ERROR_FLAGS_SQ_ERR \
		UINT32_C(0x1)
	/*
	 * If set to 1, indicates that there is an error while reading the
	 * RQ doorbell copy region for this function.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_DATA1_READ_ERROR_FLAGS_RQ_ERR \
		UINT32_C(0x2)
	/*
	 * If set to 1, indicates that there is an error while reading the
	 * SRQ doorbell copy region for this function.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_DATA1_READ_ERROR_FLAGS_SRQ_ERR \
		UINT32_C(0x4)
	/*
	 * If set to 1, indicates that there is an error while reading the
	 * CQ doorbell copy region for this function.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_DATA1_READ_ERROR_FLAGS_CQ_ERR \
		UINT32_C(0x8)
} __rte_packed;

/* hwrm_async_event_cmpl_fw_trace_msg (size:128b/16B) */
struct hwrm_async_event_cmpl_fw_trace_msg {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Firmware trace log message */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_ID_FW_TRACE_MSG \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_ID_FW_TRACE_MSG
	/* Trace byte 0 to 3 */
	uint32_t	event_data2;
	/* Trace byte0 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE0_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE0_SFT 0
	/* Trace byte1 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE1_MASK \
		UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE1_SFT 8
	/* Trace byte2 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE2_MASK \
		UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE2_SFT 16
	/* Trace byte3 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE3_MASK \
		UINT32_C(0xff000000)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE3_SFT 24
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_OPAQUE_SFT 1
	/* Trace flags */
	uint8_t	timestamp_lo;
	/* Indicates if the string is partial or complete. */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_STRING \
		UINT32_C(0x1)
	/* Complete string */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_STRING_COMPLETE \
		UINT32_C(0x0)
	/* Partial string */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_STRING_PARTIAL \
		UINT32_C(0x1)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_STRING_LAST \
		HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_STRING_PARTIAL
	/* Indicates the firmware that sent the trace message. */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_FIRMWARE \
		UINT32_C(0x2)
	/* Primary firmware */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_FIRMWARE_PRIMARY \
		(UINT32_C(0x0) << 1)
	/* Secondary firmware */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_FIRMWARE_SECONDARY \
		(UINT32_C(0x1) << 1)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_FIRMWARE_LAST \
		HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_FIRMWARE_SECONDARY
	/* Trace byte 4 to 5 */
	uint16_t	timestamp_hi;
	/* Trace byte4 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_HI_BYTE4_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_HI_BYTE4_SFT 0
	/* Trace byte5 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_HI_BYTE5_MASK \
		UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_HI_BYTE5_SFT 8
	/* Trace byte 6 to 9 */
	uint32_t	event_data1;
	/* Trace byte6 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE6_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE6_SFT 0
	/* Trace byte7 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE7_MASK \
		UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE7_SFT 8
	/* Trace byte8 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE8_MASK \
		UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE8_SFT 16
	/* Trace byte9 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE9_MASK \
		UINT32_C(0xff000000)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE9_SFT 24
} __rte_packed;

/* hwrm_async_event_cmpl_hwrm_error (size:128b/16B) */
struct hwrm_async_event_cmpl_hwrm_error {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* HWRM Error */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_ID_HWRM_ERROR \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_ID_HWRM_ERROR
	/* Event specific data */
	uint32_t	event_data2;
	/* Severity of HWRM Error */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_SFT     0
	/* Warning */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_WARNING \
		UINT32_C(0x0)
	/* Non-fatal Error */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_NONFATAL \
		UINT32_C(0x1)
	/* Fatal Error */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_FATAL \
		UINT32_C(0x2)
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_LAST \
		HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_FATAL
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Time stamp for error event */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA1_TIMESTAMP \
		UINT32_C(0x1)
} __rte_packed;

/* hwrm_async_event_cmpl_error_report_base (size:128b/16B) */
struct hwrm_async_event_cmpl_error_report_base {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform
	 * the driver that an error has occurred which may need
	 * the attention of the administrator.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_ID_ERROR_REPORT \
		UINT32_C(0x45)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_ID_ERROR_REPORT
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates the type of error being reported. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_SFT \
		0
	/* Reserved */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_RESERVED \
		UINT32_C(0x0)
	/*
	 * The NIC was subjected to an extended pause storm which caused it
	 * to disable flow control in order to avoid stalling the Tx path.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_PAUSE_STORM \
		UINT32_C(0x1)
	/*
	 * The NIC received an interrupt storm on a TSIO pin being used as
	 * PPS_IN which caused it to disable the interrupt. The signal
	 * should be fixed to be a proper 1 PPS signal before re-enabling
	 * it. The pin number on which this signal was received is stored
	 * in event_data2 as pin_id.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_INVALID_SIGNAL \
		UINT32_C(0x2)
	/*
	 * There was a low level error with an NVM write or erase.
	 * See nvm_err_type for more details.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_NVM \
		UINT32_C(0x3)
	/*
	 * This indicates doorbell drop threshold was hit. When this
	 * threshold is crossed, it indicates one or more doorbells for
	 * the function were dropped by hardware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_DOORBELL_DROP_THRESHOLD \
		UINT32_C(0x4)
	/*
	 * Indicates the NIC's temperature has crossed one of the thermal
	 * thresholds.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_THERMAL_THRESHOLD \
		UINT32_C(0x5)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_THERMAL_THRESHOLD
} __rte_packed;

/* hwrm_async_event_cmpl_error_report_pause_storm (size:128b/16B) */
struct hwrm_async_event_cmpl_error_report_pause_storm {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform
	 * the driver that an error has occurred which may need
	 * the attention of the administrator.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_EVENT_ID_ERROR_REPORT \
		UINT32_C(0x45)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_EVENT_ID_ERROR_REPORT
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates the type of error being reported. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_EVENT_DATA1_ERROR_TYPE_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_EVENT_DATA1_ERROR_TYPE_SFT \
		0
	/*
	 * The NIC was subjected to an extended pause storm which caused it
	 * to disable flow control in order to avoid stalling the Tx path.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_EVENT_DATA1_ERROR_TYPE_PAUSE_STORM \
		UINT32_C(0x1)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_EVENT_DATA1_ERROR_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_EVENT_DATA1_ERROR_TYPE_PAUSE_STORM
} __rte_packed;

/* hwrm_async_event_cmpl_error_report_invalid_signal (size:128b/16B) */
struct hwrm_async_event_cmpl_error_report_invalid_signal {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform
	 * the driver that an error has occurred which may need
	 * the attention of the administrator.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_ID_ERROR_REPORT \
		UINT32_C(0x45)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_ID_ERROR_REPORT
	/* Event specific data. */
	uint32_t	event_data2;
	/* Indicates the TSIO pin on which invalid signal is detected. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_DATA2_PIN_ID_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_DATA2_PIN_ID_SFT \
		0
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates the type of error being reported. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_DATA1_ERROR_TYPE_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_DATA1_ERROR_TYPE_SFT \
		0
	/*
	 * The NIC received an interrupt storm on a TSIO pin being used as
	 * PPS_IN which caused it to disable the interrupt. The signal
	 * should be fixed to be a proper 1 PPS signal before re-enabling
	 * it. The pin number on which this signal was received is stored
	 * in event_data2 as pin_id.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_DATA1_ERROR_TYPE_INVALID_SIGNAL \
		UINT32_C(0x2)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_DATA1_ERROR_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_DATA1_ERROR_TYPE_INVALID_SIGNAL
} __rte_packed;

/* hwrm_async_event_cmpl_error_report_nvm (size:128b/16B) */
struct hwrm_async_event_cmpl_error_report_nvm {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_TYPE_SFT             0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform
	 * the driver that an error has occurred which may need
	 * the attention of the administrator.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_ID_ERROR_REPORT \
		UINT32_C(0x45)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_ID_ERROR_REPORT
	/* Event specific data. */
	uint32_t	event_data2;
	/* Indicates the address where error was detected */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA2_ERR_ADDR_MASK \
		UINT32_C(0xffffffff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA2_ERR_ADDR_SFT \
		0
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_V          UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates the type of error being reported. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_ERROR_TYPE_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_ERROR_TYPE_SFT \
		0
	/*
	 * There was a low level error with an NVM operation.
	 * See nvm_err_type for more details.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_ERROR_TYPE_NVM_ERROR \
		UINT32_C(0x3)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_ERROR_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_ERROR_TYPE_NVM_ERROR
	/* The specific type of NVM error */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_NVM_ERR_TYPE_MASK \
		UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_NVM_ERR_TYPE_SFT \
		8
	/*
	 * There was a low level error with an NVM write operation.
	 * Verification of written data did not match.
	 * event_data2 will be the failing address.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_NVM_ERR_TYPE_WRITE \
		(UINT32_C(0x1) << 8)
	/*
	 * There was a low level error with an NVM erase operation.
	 * All the bits were not erased.
	 * event_data2 will be the failing address.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_NVM_ERR_TYPE_ERASE \
		(UINT32_C(0x2) << 8)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_NVM_ERR_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_NVM_ERR_TYPE_ERASE
} __rte_packed;

/* hwrm_async_event_cmpl_error_report_doorbell_drop_threshold (size:128b/16B) */
struct hwrm_async_event_cmpl_error_report_doorbell_drop_threshold {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform
	 * the driver that an error has occurred which may need
	 * the attention of the administrator.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_ID_ERROR_REPORT \
		UINT32_C(0x45)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_ID_ERROR_REPORT
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_OPAQUE_SFT \
		1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates the type of error being reported. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_DATA1_ERROR_TYPE_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_DATA1_ERROR_TYPE_SFT \
		0
	/*
	 * This indicates doorbell drop threshold was hit. When this
	 * threshold is crossed, it indicates one or more doorbells for
	 * the function were dropped by hardware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_DATA1_ERROR_TYPE_DOORBELL_DROP_THRESHOLD \
		UINT32_C(0x4)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_DATA1_ERROR_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_DATA1_ERROR_TYPE_DOORBELL_DROP_THRESHOLD
	/*
	 * The epoch value to be sent from firmware to the driver to track
	 * a doorbell recovery cycle.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_DATA1_EPOCH_MASK \
		UINT32_C(0xffffff00)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_DATA1_EPOCH_SFT \
		8
} __rte_packed;

/* hwrm_async_event_cmpl_error_report_thermal (size:128b/16B) */
struct hwrm_async_event_cmpl_error_report_thermal {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_TYPE_MASK \
		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_TYPE_SFT \
		0
	/* HWRM Asynchronous Event Information */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_TYPE_HWRM_ASYNC_EVENT \
		UINT32_C(0x2e)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform
	 * the driver that an error has occurred which may need
	 * the attention of the administrator.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_ID_ERROR_REPORT \
		UINT32_C(0x45)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_ID_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_ID_ERROR_REPORT
	/* Event specific data. */
	uint32_t	event_data2;
	/* Current temperature.  In Celsius */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA2_CURRENT_TEMP_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA2_CURRENT_TEMP_SFT \
		0
	/*
	 * The temperature setting of the threshold that was just crossed.
	 * In Celsius
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA2_THRESHOLD_TEMP_MASK \
		UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA2_THRESHOLD_TEMP_SFT \
		8
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_V \
		UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_OPAQUE_MASK \
		UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates the type of error being reported. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_ERROR_TYPE_MASK \
		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_ERROR_TYPE_SFT \
		0
	/*
	 * There was thermal event. The type will be specified in the
	 * field threshold_type. event_data2 will contain the current
	 * temperature and the configured value for the threshold that
	 * was just crossed. The threshold values are lower thresholds,
	 * so the event will trigger with an active flag when the
	 * temperature is on an increasing trajectory.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_ERROR_TYPE_THERMAL_EVENT \
		UINT32_C(0x5)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_ERROR_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_ERROR_TYPE_THERMAL_EVENT
	/* The specific type of thermal threshold error */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_THRESHOLD_TYPE_MASK \
		UINT32_C(0x700)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_THRESHOLD_TYPE_SFT \
		8
	/* Warning thermal threshold was crossed */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_THRESHOLD_TYPE_WARN \
		(UINT32_C(0x0) << 8)
	/* Critical thermal threshold was crossed */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_THRESHOLD_TYPE_CRITICAL \
		(UINT32_C(0x1) << 8)
	/* Fatal thermal threshold was crossed */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_THRESHOLD_TYPE_FATAL \
		(UINT32_C(0x2) << 8)
	/*
	 * Thermal shutdown threshold was crossed and a shutdown is
	 * imminent. This event will not occur if self shutdown
	 * is disabled.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_THRESHOLD_TYPE_SHUTDOWN \
		(UINT32_C(0x3) << 8)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_THRESHOLD_TYPE_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_THRESHOLD_TYPE_SHUTDOWN
	/*
	 * Indicates if the thermal crossing occurs while the temperature is
	 * increasing or decreasing.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_TRANSITION_DIR \
		UINT32_C(0x800)
	/* Threshold is crossed while the temperature is falling. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_TRANSITION_DIR_DECREASING \
		(UINT32_C(0x0) << 11)
	/* Threshold is crossed while the temperature is rising. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_TRANSITION_DIR_INCREASING \
		(UINT32_C(0x1) << 11)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_TRANSITION_DIR_LAST \
		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_TRANSITION_DIR_INCREASING
} __rte_packed;

/* metadata_base_msg (size:64b/8B) */
struct metadata_base_msg {
	uint16_t	md_type_link;
	/* This field classifies the data present in the meta-data. */
	#define METADATA_BASE_MSG_MD_TYPE_MASK      UINT32_C(0x1f)
	#define METADATA_BASE_MSG_MD_TYPE_SFT       0
	/* Meta data fields are not valid */
	#define METADATA_BASE_MSG_MD_TYPE_NONE        UINT32_C(0x0)
	/*
	 * This setting is used when packets are coming in-order. Depending on
	 * the state of the receive context, the meta-data will carry
	 * different information.
	 */
	#define METADATA_BASE_MSG_MD_TYPE_TLS_INSYNC  UINT32_C(0x1)
	/*
	 * With this setting HW passes the TCP sequence number of the TLS
	 * record that it is requesting a resync on in the meta data.
	 */
	#define METADATA_BASE_MSG_MD_TYPE_TLS_RESYNC  UINT32_C(0x2)
	/* This setting is used for QUIC packets. */
	#define METADATA_BASE_MSG_MD_TYPE_QUIC        UINT32_C(0x3)
	/*
	 * This setting is used for crypto packets with an unsupported
	 * protocol.
	 */
	#define METADATA_BASE_MSG_MD_TYPE_ILLEGAL     UINT32_C(0x1f)
	#define METADATA_BASE_MSG_MD_TYPE_LAST \
		METADATA_BASE_MSG_MD_TYPE_ILLEGAL
	/*
	 * This field indicates where the next metadata block starts, relative
	 * to the current metadata block. It is the offset to the next metadata
	 * header, counted in 16B units. A value of zero indicates that there is
	 * no additional metadata, and that the current metadata block is the
	 * last one.
	 */
	#define METADATA_BASE_MSG_LINK_MASK         UINT32_C(0x1e0)
	#define METADATA_BASE_MSG_LINK_SFT          5
	uint16_t	unused0;
	uint32_t	unused1;
} __rte_packed;

/* tls_metadata_base_msg (size:64b/8B) */
struct tls_metadata_base_msg {
	uint32_t	md_type_link_flags_kid_lo;
	/* This field classifies the data present in the meta-data. */
	#define TLS_METADATA_BASE_MSG_MD_TYPE_MASK \
		UINT32_C(0x1f)
	#define TLS_METADATA_BASE_MSG_MD_TYPE_SFT \
		0
	/*
	 * This setting is used when packets are coming in-order. Depending
	 * on the state of the receive context, the meta-data will carry
	 * different information.
	 */
	#define TLS_METADATA_BASE_MSG_MD_TYPE_TLS_INSYNC \
		UINT32_C(0x1)
	/*
	 * With this setting HW passes the TCP sequence number of the TLS
	 * record that it is requesting a resync on in the meta data.
	 */
	#define TLS_METADATA_BASE_MSG_MD_TYPE_TLS_RESYNC \
		UINT32_C(0x2)
	#define TLS_METADATA_BASE_MSG_MD_TYPE_LAST \
		TLS_METADATA_BASE_MSG_MD_TYPE_TLS_RESYNC
	/*
	 * This field indicates where the next metadata block starts. It is
	 * counted in 16B units. A value of zero indicates that there is no
	 * metadata.
	 */
	#define TLS_METADATA_BASE_MSG_LINK_MASK \
		UINT32_C(0x1e0)
	#define TLS_METADATA_BASE_MSG_LINK_SFT \
		5
	/* These are flags present in the metadata. */
	#define TLS_METADATA_BASE_MSG_FLAGS_MASK \
		UINT32_C(0x1fffe00)
	#define TLS_METADATA_BASE_MSG_FLAGS_SFT \
		9
	/*
	 * A value of 1 implies that the packet was decrypted by HW. Otherwise
	 * the packet is passed on as it came in on the wire.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_DECRYPTED \
		UINT32_C(0x200)
	/*
	 * This field indicates the state of the ghash field passed in the
	 * meta-data.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_MASK \
		UINT32_C(0xc00)
	#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_SFT \
		10
	/*
	 * This enumeration states that the ghash is not valid in the
	 * meta-data.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_NOT_VALID \
		(UINT32_C(0x0) << 10)
	/*
	 * This enumeration indicates that this pkt contains the record's
	 * tag and this pkt was received ooo, the partial_ghash field
	 * contains the ghash.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_CUR_REC \
		(UINT32_C(0x1) << 10)
	/*
	 * This enumeration indicates that the current record's tag wasn't
	 * seen and the chip is moving on to the next record, the
	 * partial_ghash field contains the ghash.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_PRIOR_REC \
		(UINT32_C(0x2) << 10)
	#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_LAST \
		TLS_METADATA_BASE_MSG_FLAGS_GHASH_PRIOR_REC
	/* This field indicates the status of tag authentication. */
	#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_MASK \
		UINT32_C(0x3000)
	#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_SFT \
		12
	/*
	 * This enumeration is set when HW was not able to authenticate a
	 * TAG.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_NOT_CHECKED \
		(UINT32_C(0x0) << 12)
	/*
	 * This enumeration states that there is at least one tag in the
	 * packet and every tag is valid.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_SUCCESS \
		(UINT32_C(0x1) << 12)
	/*
	 * This enumeration states that there is at least one tag in the
	 * packet and at least one of the tag is invalid. The entire packet
	 * is sent decrypted to the host.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_FAILURE \
		(UINT32_C(0x2) << 12)
	#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_LAST \
		TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_FAILURE
	/*
	 * A value of 1 indicates that this packet contains a record that
	 * starts in the packet and extends beyond the packet.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_HEADER_FLDS_VALID \
		UINT32_C(0x4000)
	/*
	 * A value of 1 indicates that the packet experienced a context load
	 * error. In this case, the packet is sent to the host without the
	 * header or payload decrypted and the context is not updated.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_CTX_LOAD_ERR \
		UINT32_C(0x8000)
	/* This field indicates the packet operation state. */
	#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_MASK \
		UINT32_C(0x70000)
	#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_SFT \
		16
	/* Packet is in order. */
	#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_IN_ORDER \
		(UINT32_C(0x0) << 16)
	/* Packet is out of order, no header loss. */
	#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_OUT_OF_ORDER \
		(UINT32_C(0x1) << 16)
	/* Packet is header search (out of order with header loss). */
	#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_HEADER_SEARCH \
		(UINT32_C(0x2) << 16)
	/* Packet is resync (resync record ongoing). */
	#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC \
		(UINT32_C(0x3) << 16)
	/*
	 * Packet is resync wait (resync record completes, waiting for
	 * result).
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_WAIT \
		(UINT32_C(0x4) << 16)
	/*
	 * Packet is resync wait for partial tag (waiting for resync record
	 * tag).
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_WAIT_PARTIAL \
		(UINT32_C(0x5) << 16)
	/* Packet is resync success (got resync record success). */
	#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS \
		(UINT32_C(0x6) << 16)
	/*
	 * Packet is resync success wait (got midpath ACK, waiting for
	 * resync record success).
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS_WAIT \
		(UINT32_C(0x7) << 16)
	#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_LAST \
		TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS_WAIT
	/*
	 * This value indicates the lower 7-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_BASE_MSG_KID_LO_MASK \
		UINT32_C(0xfe000000)
	#define TLS_METADATA_BASE_MSG_KID_LO_SFT \
		25
	uint16_t	kid_hi;
	/*
	 * This value indicates the upper 13-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_BASE_MSG_KID_HI_MASK UINT32_C(0x1fff)
	#define TLS_METADATA_BASE_MSG_KID_HI_SFT 0
	uint16_t	unused0;
} __rte_packed;

/* tls_metadata_insync_msg (size:192b/24B) */
struct tls_metadata_insync_msg {
	uint32_t	md_type_link_flags_kid_lo;
	/* This field classifies the data present in the meta-data. */
	#define TLS_METADATA_INSYNC_MSG_MD_TYPE_MASK \
		UINT32_C(0x1f)
	#define TLS_METADATA_INSYNC_MSG_MD_TYPE_SFT \
		0
	/*
	 * This setting is used when packets are coming in-order. Depending on
	 * the state of the receive context, the meta-data will carry
	 * different information.
	 */
	#define TLS_METADATA_INSYNC_MSG_MD_TYPE_TLS_INSYNC \
		UINT32_C(0x1)
	#define TLS_METADATA_INSYNC_MSG_MD_TYPE_LAST \
		TLS_METADATA_INSYNC_MSG_MD_TYPE_TLS_INSYNC
	/*
	 * This field indicates where the next metadata block starts. It is
	 * counted in 16B units. A value of zero indicates that there is no
	 * metadata.
	 */
	#define TLS_METADATA_INSYNC_MSG_LINK_MASK \
		UINT32_C(0x1e0)
	#define TLS_METADATA_INSYNC_MSG_LINK_SFT \
		5
	/* These are flags present in the metadata. */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_MASK \
		UINT32_C(0x1fffe00)
	#define TLS_METADATA_INSYNC_MSG_FLAGS_SFT \
		9
	/*
	 * A value of 1 implies that the packet was decrypted by HW. Otherwise
	 * the packet is passed on as it came in on the wire.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_DECRYPTED \
		UINT32_C(0x200)
	/*
	 * This field indicates the state of the ghash field passed in the
	 * meta-data.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_MASK \
		UINT32_C(0xc00)
	#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_SFT \
		10
	/*
	 * This enumeration states that the ghash is not valid in the
	 * meta-data.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_NOT_VALID \
		(UINT32_C(0x0) << 10)
	/*
	 * This enumeration indicates that this pkt contains the record's
	 * tag and this pkt was received ooo, the partial_ghash field
	 * contains the ghash.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_CUR_REC \
		(UINT32_C(0x1) << 10)
	/*
	 * This enumeration indicates that the current record's tag wasn't
	 * seen and the chip is moving on to the next record, the
	 * partial_ghash field contains the ghash.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_PRIOR_REC \
		(UINT32_C(0x2) << 10)
	#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_LAST \
		TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_PRIOR_REC
	/* This field indicates the status of tag authentication. */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_MASK \
		UINT32_C(0x3000)
	#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_SFT \
		12
	/*
	 * This enumeration is set when HW was not able to authenticate a
	 * TAG.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_NOT_CHECKED \
		(UINT32_C(0x0) << 12)
	/*
	 * This enumeration states that there is at least one tag in the
	 * packet and every tag is valid.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_SUCCESS \
		(UINT32_C(0x1) << 12)
	/*
	 * This enumeration states that there is at least one tag in the
	 * packet and at least one of the tag is invalid. The entire packet
	 * is sent decrypted to the host.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_FAILURE \
		(UINT32_C(0x2) << 12)
	#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_LAST \
		TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_FAILURE
	/*
	 * A value of 1 indicates that this packet contains a record that
	 * starts in the packet and extends beyond the packet.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_HEADER_FLDS_VALID \
		UINT32_C(0x4000)
	/*
	 * A value of 1 indicates that the packet experienced a context load
	 * error. In this case, the packet is sent to the host without the
	 * header or payload decrypted and the context is not updated.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_CTX_LOAD_ERR \
		UINT32_C(0x8000)
	/* This field indicates the packet operation state. */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_MASK \
		UINT32_C(0x70000)
	#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_SFT \
		16
	/* Packet is in order. */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_IN_ORDER \
		(UINT32_C(0x0) << 16)
	/* Packet is out of order, no header loss. */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_OUT_OF_ORDER \
		(UINT32_C(0x1) << 16)
	/* Packet is header search (out of order with header loss). */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_HEADER_SEARCH \
		(UINT32_C(0x2) << 16)
	/* Packet is resync (resync record ongoing). */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC \
		(UINT32_C(0x3) << 16)
	/*
	 * Packet is resync wait (resync record completes, waiting for
	 * result).
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_WAIT \
		(UINT32_C(0x4) << 16)
	/*
	 * Packet is resync wait for partial tag (waiting for resync record
	 * tag).
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_WAIT_PARTIAL \
		(UINT32_C(0x5) << 16)
	/* Packet is resync success (got resync record success). */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS \
		(UINT32_C(0x6) << 16)
	/*
	 * Packet is resync success wait (got midpath ACK, waiting for
	 * resync record success).
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS_WAIT \
		(UINT32_C(0x7) << 16)
	#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_LAST \
		TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS_WAIT
	/*
	 * This value indicates the lower 7-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_INSYNC_MSG_KID_LO_MASK \
		UINT32_C(0xfe000000)
	#define TLS_METADATA_INSYNC_MSG_KID_LO_SFT \
		25
	uint16_t	kid_hi;
	/*
	 * This value indicates the upper 13-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_INSYNC_MSG_KID_HI_MASK UINT32_C(0x1fff)
	#define TLS_METADATA_INSYNC_MSG_KID_HI_SFT 0
	/*
	 * This field is only valid when md_type is set to tls_insync. This
	 * field indicates the offset within the current TCP packet where the
	 * TLS header starts. If there are multiple TLS headers in the packet,
	 * this provides the offset of the last TLS header.
	 *
	 * The field is calculated by subtracting TCP sequence number of the
	 * first byte of the TCP payload of the packet from the TCP sequence
	 * number of the last TLS header in the packet.
	 */
	uint16_t	tls_header_offset;
	/*
	 * This is the sequence Number of the record that was processed by the HW.
	 * If there are multiple records in a packet, this would be the sequence
	 * number of the last record.
	 */
	uint64_t	record_seq_num;
	/*
	 * This field contains cumulative partial GHASH value of all the packets
	 * decrypted by the HW associated with a TLS record. This field is valid
	 * on when packets belonging to have arrived out-of-order and HW could
	 * not decrypt every packet and authenticate the record. Partial GHASH is
	 * only sent out with packet having the TAG field.
	 */
	uint8_t	partial_ghash[8];
} __rte_packed;

/* tls_metadata_resync_msg (size:256b/32B) */
struct tls_metadata_resync_msg {
	uint32_t	md_type_link_flags_kid_lo;
	/* This field classifies the data present in the meta-data. */
	#define TLS_METADATA_RESYNC_MSG_MD_TYPE_MASK \
		UINT32_C(0x1f)
	#define TLS_METADATA_RESYNC_MSG_MD_TYPE_SFT \
		0
	/*
	 * With this setting HW passes the TCP sequence number of the TLS
	 * record that it is requesting a resync on in the meta data.
	 */
	#define TLS_METADATA_RESYNC_MSG_MD_TYPE_TLS_RESYNC \
		UINT32_C(0x2)
	#define TLS_METADATA_RESYNC_MSG_MD_TYPE_LAST \
		TLS_METADATA_RESYNC_MSG_MD_TYPE_TLS_RESYNC
	/*
	 * This field indicates where the next metadata block starts. It is
	 * counted in 16B units. A value of zero indicates that there is no
	 * metadata.
	 */
	#define TLS_METADATA_RESYNC_MSG_LINK_MASK \
		UINT32_C(0x1e0)
	#define TLS_METADATA_RESYNC_MSG_LINK_SFT \
		5
	/* These are flags present in the metadata. */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_MASK \
		UINT32_C(0x1fffe00)
	#define TLS_METADATA_RESYNC_MSG_FLAGS_SFT \
		9
	/*
	 * A value of 1 implies that the packet was decrypted by HW. Otherwise
	 * the packet is passed on as it came in on the wire.
	 */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_DECRYPTED \
		UINT32_C(0x200)
	/*
	 * This field indicates the state of the ghash field passed in the
	 * meta-data.
	 */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_GHASH_MASK \
		UINT32_C(0xc00)
	#define TLS_METADATA_RESYNC_MSG_FLAGS_GHASH_SFT \
		10
	/*
	 * This enumeration states that the ghash is not valid in the
	 * meta-data.
	 */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_GHASH_NOT_VALID \
		(UINT32_C(0x0) << 10)
	#define TLS_METADATA_RESYNC_MSG_FLAGS_GHASH_LAST \
		TLS_METADATA_RESYNC_MSG_FLAGS_GHASH_NOT_VALID
	/* This field indicates the status of tag authentication. */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_TAG_AUTH_STATUS_MASK \
		UINT32_C(0x3000)
	#define TLS_METADATA_RESYNC_MSG_FLAGS_TAG_AUTH_STATUS_SFT \
		12
	/*
	 * This enumeration is set when HW was not able to authenticate a
	 * TAG.
	 */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_TAG_AUTH_STATUS_NOT_CHECKED \
		(UINT32_C(0x0) << 12)
	#define TLS_METADATA_RESYNC_MSG_FLAGS_TAG_AUTH_STATUS_LAST \
		TLS_METADATA_RESYNC_MSG_FLAGS_TAG_AUTH_STATUS_NOT_CHECKED
	/*
	 * A value of 1 indicates that this packet contains a record that
	 * starts in the packet and extends beyond the packet.
	 */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_HEADER_FLDS_VALID \
		UINT32_C(0x4000)
	/*
	 * A value of 1 indicates that the packet experienced a context load
	 * error. In this case, the packet is sent to the host without the
	 * header or payload decrypted and the context is not updated.
	 */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_CTX_LOAD_ERR \
		UINT32_C(0x8000)
	/* This field indicates the packet operation state. */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_MASK \
		UINT32_C(0x70000)
	#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_SFT \
		16
	/* Packet is in order. */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_IN_ORDER \
		(UINT32_C(0x0) << 16)
	/* Packet is out of order, no header loss. */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_OUT_OF_ORDER \
		(UINT32_C(0x1) << 16)
	/* Packet is header search (out of order with header loss). */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_HEADER_SEARCH \
		(UINT32_C(0x2) << 16)
	/* Packet is resync (resync record ongoing). */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC \
		(UINT32_C(0x3) << 16)
	/*
	 * Packet is resync wait (resync record completes, waiting for
	 * result).
	 */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_WAIT \
		(UINT32_C(0x4) << 16)
	/*
	 * Packet is resync wait for partial tag (waiting for resync record
	 * tag).
	 */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_WAIT_PARTIAL \
		(UINT32_C(0x5) << 16)
	/* Packet is resync success (got resync record success). */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS \
		(UINT32_C(0x6) << 16)
	/*
	 * Packet is resync success wait (got midpath ACK, waiting for
	 * resync record success).
	 */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS_WAIT \
		(UINT32_C(0x7) << 16)
	#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_LAST \
		TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS_WAIT
	/*
	 * This value indicates the lower 7-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_RESYNC_MSG_KID_LO_MASK \
		UINT32_C(0xfe000000)
	#define TLS_METADATA_RESYNC_MSG_KID_LO_SFT \
		25
	uint16_t	kid_hi;
	/*
	 * This value indicates the upper 13-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_RESYNC_MSG_KID_HI_MASK UINT32_C(0x1fff)
	#define TLS_METADATA_RESYNC_MSG_KID_HI_SFT 0
	/* This field is unused in this context. */
	uint16_t	metadata_0;
	/*
	 * This field indicates the TCP sequence number of the TLS record that HW
	 * is requesting a resync on from the Driver. HW will keep a count of the
	 * TLS records it found after this record (delta_records). Driver will
	 * provide the TLS Record Sequence Number associated with the record. HW
	 * will add the delta_records to the Record Sequence Number provided by
	 * the driver and get back on sync.
	 */
	uint32_t	resync_record_tcp_seq_num;
	uint32_t	unused0;
	/* This field is unused in this context. */
	uint64_t	metadata_2;
	/* This field is unused in this context. */
	uint64_t	metadata_3;
} __rte_packed;

/*******************
 * hwrm_func_reset *
 *******************/


/* hwrm_func_reset_input (size:192b/24B) */
struct hwrm_func_reset_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vf_id_valid field to be
	 * configured.
	 */
	#define HWRM_FUNC_RESET_INPUT_ENABLES_VF_ID_VALID     UINT32_C(0x1)
	/*
	 * The ID of the VF that this PF is trying to reset.
	 * Only the parent PF shall be allowed to reset a child VF.
	 *
	 * A parent PF driver shall use this field only when a specific child VF
	 * is requested to be reset.
	 */
	uint16_t	vf_id;
	/* This value indicates the level of a function reset. */
	uint8_t	func_reset_level;
	/*
	 * Reset the caller function and its children VFs (if any). If no
	 * children functions exist, then reset the caller function only.
	 */
	#define HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETALL \
		UINT32_C(0x0)
	/* Reset the caller function only */
	#define HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETME \
		UINT32_C(0x1)
	/*
	 * Reset all children VFs of the caller function driver if the
	 * caller is a PF driver.
	 * It is an error to specify this level by a VF driver.
	 * It is an error to specify this level by a PF driver with
	 * no children VFs.
	 */
	#define HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETCHILDREN \
		UINT32_C(0x2)
	/*
	 * Reset a specific VF of the caller function driver if the caller
	 * is the parent PF driver.
	 * It is an error to specify this level by a VF driver.
	 * It is an error to specify this level by a PF driver that is not
	 * the parent of the VF that is being requested to reset.
	 */
	#define HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETVF \
		UINT32_C(0x3)
	#define HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_LAST \
		HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETVF
	uint8_t	unused_0;
} __rte_packed;

/* hwrm_func_reset_output (size:128b/16B) */
struct hwrm_func_reset_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/********************
 * hwrm_func_getfid *
 ********************/


/* hwrm_func_getfid_input (size:192b/24B) */
struct hwrm_func_getfid_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the pci_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_GETFID_INPUT_ENABLES_PCI_ID     UINT32_C(0x1)
	/*
	 * This value is the PCI ID of the queried function.
	 * If ARI is enabled, then it is
	 * Bus Number (8b):Function Number(8b). Otherwise, it is
	 * Bus Number (8b):Device Number (5b):Function Number(3b).
	 */
	uint16_t	pci_id;
	uint8_t	unused_0[2];
} __rte_packed;

/* hwrm_func_getfid_output (size:128b/16B) */
struct hwrm_func_getfid_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * FID value.  This value is used to identify operations on the PCI
	 * bus as belonging to a particular PCI function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_func_vf_alloc *
 **********************/


/* hwrm_func_vf_alloc_input (size:192b/24B) */
struct hwrm_func_vf_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the first_vf_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_ALLOC_INPUT_ENABLES_FIRST_VF_ID     UINT32_C(0x1)
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	first_vf_id;
	/* The number of virtual functions requested. */
	uint16_t	num_vfs;
} __rte_packed;

/* hwrm_func_vf_alloc_output (size:128b/16B) */
struct hwrm_func_vf_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The ID of the first VF allocated. */
	uint16_t	first_vf_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_func_vf_free *
 *********************/


/* hwrm_func_vf_free_input (size:192b/24B) */
struct hwrm_func_vf_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the first_vf_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_FREE_INPUT_ENABLES_FIRST_VF_ID     UINT32_C(0x1)
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	first_vf_id;
	/*
	 * The number of virtual functions requested.
	 * 0xFFFF - Cleanup all children of this PF.
	 */
	uint16_t	num_vfs;
} __rte_packed;

/* hwrm_func_vf_free_output (size:128b/16B) */
struct hwrm_func_vf_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/********************
 * hwrm_func_vf_cfg *
 ********************/


/* hwrm_func_vf_cfg_input (size:512b/64B) */
struct hwrm_func_vf_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the mtu field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_MTU \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the guest_vlan field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_GUEST_VLAN \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the async_event_cr field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_ASYNC_EVENT_CR \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the dflt_mac_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_DFLT_MAC_ADDR \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the num_rsscos_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_RSSCOS_CTXS \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the num_cmpl_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_CMPL_RINGS \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the num_tx_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_TX_RINGS \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the num_rx_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_RX_RINGS \
		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the num_l2_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_L2_CTXS \
		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the num_vnics field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_VNICS \
		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the num_stat_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_STAT_CTXS \
		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the num_hw_ring_grps field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_HW_RING_GRPS \
		UINT32_C(0x800)
	/*
	 * This bit must be '1' for the num_tx_key_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_TX_KEY_CTXS \
		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the num_rx_key_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_RX_KEY_CTXS \
		UINT32_C(0x2000)
	/*
	 * The maximum transmission unit requested on the function.
	 * The HWRM should make sure that the mtu of
	 * the function does not exceed the mtu of the physical
	 * port that this function is associated with.
	 *
	 * In addition to requesting mtu per function, it is
	 * possible to configure mtu per transmit ring.
	 * By default, the mtu of each transmit ring associated
	 * with a function is equal to the mtu of the function.
	 * The HWRM should make sure that the mtu of each transmit
	 * ring that is assigned to a function has a valid mtu.
	 */
	uint16_t	mtu;
	/*
	 * The guest VLAN for the function being configured.
	 * This field's format is same as 802.1Q Tag's
	 * Tag Control Information (TCI) format that includes both
	 * Priority Code Point (PCP) and VLAN Identifier (VID).
	 */
	uint16_t	guest_vlan;
	/*
	 * ID of the target completion ring for receiving asynchronous
	 * event completions. If this field is not valid, then the
	 * HWRM shall use the default completion ring of the function
	 * that is being configured as the target completion ring for
	 * providing any asynchronous event completions for that
	 * function.
	 * If this field is valid, then the HWRM shall use the
	 * completion ring identified by this ID as the target
	 * completion ring for providing any asynchronous event
	 * completions for the function that is being configured.
	 */
	uint16_t	async_event_cr;
	/*
	 * This value is the current MAC address requested by the VF
	 * driver to be configured on this VF. A value of
	 * 00-00-00-00-00-00 indicates no MAC address configuration
	 * is requested by the VF driver.
	 * The parent PF driver may reject or overwrite this
	 * MAC address.
	 */
	uint8_t	dflt_mac_addr[6];
	uint32_t	flags;
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of TX rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_TX_ASSETS_TEST \
		UINT32_C(0x1)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of RX rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_RX_ASSETS_TEST \
		UINT32_C(0x2)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of CMPL rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_CMPL_ASSETS_TEST \
		UINT32_C(0x4)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of RSS ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_RSSCOS_CTX_ASSETS_TEST \
		UINT32_C(0x8)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of ring groups) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_RING_GRP_ASSETS_TEST \
		UINT32_C(0x10)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of stat ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_STAT_CTX_ASSETS_TEST \
		UINT32_C(0x20)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of VNICs) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_VNIC_ASSETS_TEST \
		UINT32_C(0x40)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of L2 ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_L2_CTX_ASSETS_TEST \
		UINT32_C(0x80)
	/*
	 * If this bit is set to 1, the VF driver is requesting FW to enable
	 * PPP TX PUSH feature on all the TX rings specified in the
	 * num_tx_rings field. By default, the PPP TX push feature is
	 * disabled for all the TX rings of the VF. This flag is ignored if
	 * the num_tx_rings field is not specified or the VF doesn't support
	 * PPP tx push feature.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_PPP_PUSH_MODE_ENABLE \
		UINT32_C(0x100)
	/*
	 * If this bit is set to 1, the VF driver is requesting FW to disable
	 * PPP TX PUSH feature on all the TX rings of the VF. This flag is
	 * ignored if the VF doesn't support PPP tx push feature.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_PPP_PUSH_MODE_DISABLE \
		UINT32_C(0x200)
	/* The number of RSS/COS contexts requested for the VF. */
	uint16_t	num_rsscos_ctxs;
	/* The number of completion rings requested for the VF. */
	uint16_t	num_cmpl_rings;
	/* The number of transmit rings requested for the VF. */
	uint16_t	num_tx_rings;
	/* The number of receive rings requested for the VF. */
	uint16_t	num_rx_rings;
	/* The number of L2 contexts requested for the VF. */
	uint16_t	num_l2_ctxs;
	/* The number of vnics requested for the VF. */
	uint16_t	num_vnics;
	/* The number of statistic contexts requested for the VF. */
	uint16_t	num_stat_ctxs;
	/* The number of HW ring groups requested for the VF. */
	uint16_t	num_hw_ring_grps;
	/* Number of Tx Key Contexts requested. */
	uint32_t	num_tx_key_ctxs;
	/* Number of Rx Key Contexts requested. */
	uint32_t	num_rx_key_ctxs;
	uint8_t	unused[4];
} __rte_packed;

/* hwrm_func_vf_cfg_output (size:128b/16B) */
struct hwrm_func_vf_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************
 * hwrm_func_qcaps *
 *******************/


/* hwrm_func_qcaps_input (size:192b/24B) */
struct hwrm_func_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 * 0xFFFE (REQUESTING_PARENT_FID) This is a special FID
	 * to be used by a trusted VF to query its parent PF.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_func_qcaps_output (size:896b/112B) */
struct hwrm_func_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * FID value.  This value is used to identify operations on the PCI
	 * bus as belonging to a particular PCI function.
	 */
	uint16_t	fid;
	/*
	 * Port ID of port that this function is associated with.
	 * Valid only for the PF.
	 * 0xFF... (All Fs) if this function is not associated with
	 * any port.
	 * 0xFF... (All Fs) if this function is called from a VF.
	 */
	uint16_t	port_id;
	uint32_t	flags;
	/* If 1, then Push mode is supported on this function. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_PUSH_MODE_SUPPORTED \
		UINT32_C(0x1)
	/*
	 * If 1, then the global MSI-X auto-masking is enabled for the
	 * device.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_GLOBAL_MSIX_AUTOMASKING \
		UINT32_C(0x2)
	/*
	 * If 1, then the Precision Time Protocol (PTP) processing
	 * is supported on this function.
	 * The HWRM should enable PTP on only a single Physical
	 * Function (PF) per port.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_PTP_SUPPORTED \
		UINT32_C(0x4)
	/*
	 * If 1, then RDMA over Converged Ethernet (RoCE) v1
	 * is supported on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ROCE_V1_SUPPORTED \
		UINT32_C(0x8)
	/*
	 * If 1, then RDMA over Converged Ethernet (RoCE) v2
	 * is supported on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ROCE_V2_SUPPORTED \
		UINT32_C(0x10)
	/*
	 * If 1, then control and configuration of WoL magic packet
	 * are supported on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_WOL_MAGICPKT_SUPPORTED \
		UINT32_C(0x20)
	/*
	 * If 1, then control and configuration of bitmap pattern
	 * packet are supported on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_WOL_BMP_SUPPORTED \
		UINT32_C(0x40)
	/*
	 * If set to 1, then the control and configuration of rate limit
	 * of an allocated TX ring on the queried function is supported.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_TX_RING_RL_SUPPORTED \
		UINT32_C(0x80)
	/*
	 * If 1, then control and configuration of minimum and
	 * maximum bandwidths are supported on the queried function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_TX_BW_CFG_SUPPORTED \
		UINT32_C(0x100)
	/*
	 * If the query is for a VF, then this flag shall be ignored.
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to set the rate limits
	 * on the TX rings of its children VFs.
	 * If this query is for a PF and this flag is set to 0, then
	 * the PF does not have the capability to set the rate limits
	 * on the TX rings of its children VFs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_VF_TX_RING_RL_SUPPORTED \
		UINT32_C(0x200)
	/*
	 * If the query is for a VF, then this flag shall be ignored.
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to set the minimum and/or
	 * maximum bandwidths for its children VFs.
	 * If this query is for a PF and this flag is set to 0, then
	 * the PF does not have the capability to set the minimum or
	 * maximum bandwidths for its children VFs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_VF_BW_CFG_SUPPORTED \
		UINT32_C(0x400)
	/*
	 * Standard TX Ring mode is used for the allocation of TX ring
	 * and underlying scheduling resources that allow bandwidth
	 * reservation and limit settings on the queried function.
	 * If set to 1, then standard TX ring mode is supported
	 * on the queried function.
	 * If set to 0, then standard TX ring mode is not available
	 * on the queried function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_STD_TX_RING_MODE_SUPPORTED \
		UINT32_C(0x800)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to detect GENEVE tunnel
	 * flags.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_GENEVE_TUN_FLAGS_SUPPORTED \
		UINT32_C(0x1000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to detect NVGRE tunnel
	 * flags.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_NVGRE_TUN_FLAGS_SUPPORTED \
		UINT32_C(0x2000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to detect GRE tunnel
	 * flags.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_GRE_TUN_FLAGS_SUPPORTED \
		UINT32_C(0x4000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to detect MPLS tunnel
	 * flags.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_MPLS_TUN_FLAGS_SUPPORTED \
		UINT32_C(0x8000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to support pcie stats.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_PCIE_STATS_SUPPORTED \
		UINT32_C(0x10000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to adopt the VF's belonging
	 * to another PF.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ADOPTED_PF_SUPPORTED \
		UINT32_C(0x20000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the administrative privilege to configure another PF
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ADMIN_PF_SUPPORTED \
		UINT32_C(0x40000)
	/*
	 * If the query is for a VF, then this flag shall be ignored.
	 * If this query is for a PF and this flag is set to 1, then
	 * the PF will know that the firmware has the capability to track
	 * the virtual link status.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_LINK_ADMIN_STATUS_SUPPORTED \
		UINT32_C(0x80000)
	/*
	 * If 1, then this function supports the push mode that uses
	 * write combine buffers and the long inline tx buffer descriptor.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_WCB_PUSH_MODE \
		UINT32_C(0x100000)
	/*
	 * If 1, then FW has capability to allocate TX rings dynamically
	 * in ring alloc even if PF reserved pool is zero.
	 * This bit will be used only for PFs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_DYNAMIC_TX_RING_ALLOC \
		UINT32_C(0x200000)
	/*
	 * When this bit is '1', it indicates that core firmware is
	 * capable of Hot Reset.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_HOT_RESET_CAPABLE \
		UINT32_C(0x400000)
	/*
	 * This flag will be set to 1 by the FW if FW supports adapter error
	 * recovery.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ERROR_RECOVERY_CAPABLE \
		UINT32_C(0x800000)
	/*
	 * If the query is for a VF, then this flag shall be ignored.
	 * If this query is for a PF and this flag is set to 1, then
	 * the PF has the capability to support extended stats.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_STATS_SUPPORTED \
		UINT32_C(0x1000000)
	/*
	 * If the query is for a VF, then this flag shall be ignored.
	 * If this query is for a PF and this flag is set to 1, then host
	 * must initiate reset or reload (or fastboot) the firmware image
	 * upon detection of device shutdown state.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ERR_RECOVER_RELOAD \
		UINT32_C(0x2000000)
	/*
	 * If the query is for a VF, then this flag (always set to 0) shall
	 * be ignored. If this query is for a PF and this flag is set to 1,
	 * host, when registered for the default vnic change async event,
	 * receives async notification whenever a default vnic state is
	 * changed for any of child or adopted VFs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_NOTIFY_VF_DEF_VNIC_CHNG_SUPPORTED \
		UINT32_C(0x4000000)
	/* If set to 1, then the vlan acceleration for TX is disabled. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_VLAN_ACCELERATION_TX_DISABLED \
		UINT32_C(0x8000000)
	/*
	 * When this bit is '1', it indicates that core firmware supports
	 * DBG_COREDUMP_XXX commands.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_COREDUMP_CMD_SUPPORTED \
		UINT32_C(0x10000000)
	/*
	 * When this bit is '1', it indicates that core firmware supports
	 * DBG_CRASHDUMP_XXX commands.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_CRASHDUMP_CMD_SUPPORTED \
		UINT32_C(0x20000000)
	/*
	 * If the query is for a VF, then this flag should be ignored.
	 * If the query is for a PF and this flag is set to 1, then
	 * the PF has the capability to support retrieval of
	 * rx_port_stats_ext_pfc_wd statistics (supported by the PFC
	 * WatchDog feature) via the hwrm_port_qstats_ext_pfc_wd command.
	 * If this flag is set to 1, only that (supported) command should
	 * be used for retrieval of PFC related statistics (rather than
	 * hwrm_port_qstats_ext command, which could previously be used).
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_PFC_WD_STATS_SUPPORTED \
		UINT32_C(0x40000000)
	/*
	 * When this bit is '1', it indicates that core firmware supports
	 * DBG_QCAPS command
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_DBG_QCAPS_CMD_SUPPORTED \
		UINT32_C(0x80000000)
	/*
	 * This value is current MAC address configured for this
	 * function. A value of 00-00-00-00-00-00 indicates no
	 * MAC address is currently configured.
	 */
	uint8_t	mac_address[6];
	/*
	 * The maximum number of RSS/COS contexts that can be
	 * allocated to the function.
	 */
	uint16_t	max_rsscos_ctx;
	/*
	 * The maximum number of completion rings that can be
	 * allocated to the function.
	 */
	uint16_t	max_cmpl_rings;
	/*
	 * The maximum number of transmit rings that can be
	 * allocated to the function.
	 */
	uint16_t	max_tx_rings;
	/*
	 * The maximum number of receive rings that can be
	 * allocated to the function.
	 */
	uint16_t	max_rx_rings;
	/*
	 * The maximum number of L2 contexts that can be
	 * allocated to the function.
	 */
	uint16_t	max_l2_ctxs;
	/*
	 * The maximum number of VNICs that can be
	 * allocated to the function.
	 */
	uint16_t	max_vnics;
	/*
	 * The identifier for the first VF enabled on a PF. This
	 * is valid only on the PF with SR-IOV enabled.
	 * 0xFF... (All Fs) if this command is called on a PF with
	 * SR-IOV disabled or on a VF.
	 */
	uint16_t	first_vf_id;
	/*
	 * The maximum number of VFs that can be
	 * allocated to the function. This is valid only on the
	 * PF with SR-IOV enabled. 0xFF... (All Fs) if this
	 * command is called on a PF with SR-IOV disabled or
	 * on a VF.
	 */
	uint16_t	max_vfs;
	/*
	 * The maximum number of statistic contexts that can be
	 * allocated to the function.
	 */
	uint16_t	max_stat_ctx;
	/*
	 * The maximum number of Encapsulation records that can be
	 * offloaded by this function.
	 */
	uint32_t	max_encap_records;
	/*
	 * The maximum number of decapsulation records that can
	 * be offloaded by this function.
	 */
	uint32_t	max_decap_records;
	/*
	 * The maximum number of Exact Match (EM) flows that can be
	 * offloaded by this function on the TX side.
	 */
	uint32_t	max_tx_em_flows;
	/*
	 * The maximum number of Wildcard Match (WM) flows that can
	 * be offloaded by this function on the TX side.
	 */
	uint32_t	max_tx_wm_flows;
	/*
	 * The maximum number of Exact Match (EM) flows that can be
	 * offloaded by this function on the RX side.
	 */
	uint32_t	max_rx_em_flows;
	/*
	 * The maximum number of Wildcard Match (WM) flows that can
	 * be offloaded by this function on the RX side.
	 */
	uint32_t	max_rx_wm_flows;
	/*
	 * The maximum number of multicast filters that can
	 * be supported by this function on the RX side.
	 */
	uint32_t	max_mcast_filters;
	/*
	 * The maximum value of flow_id that can be supported
	 * in completion records.
	 */
	uint32_t	max_flow_id;
	/*
	 * The maximum number of HW ring groups that can be
	 * supported on this function.
	 */
	uint32_t	max_hw_ring_grps;
	/*
	 * The maximum number of strict priority transmit rings
	 * that can be allocated to the function.
	 * This number indicates the maximum number of TX rings
	 * that can be assigned strict priorities out of the
	 * maximum number of TX rings that can be allocated
	 * (max_tx_rings) to the function.
	 */
	uint16_t	max_sp_tx_rings;
	/*
	 * The maximum number of MSI-X vectors that may be allocated across
	 * all VFs for the function. This is valid only on the PF with SR-IOV
	 * enabled. Returns zero if this command is called on a PF with
	 * SR-IOV disabled or on a VF.
	 */
	uint16_t	max_msix_vfs;
	uint32_t	flags_ext;
	/*
	 * If 1, the device can be configured to set the ECN bits in the
	 * IP header of received packets if the receive queue length
	 * exceeds a given threshold.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_ECN_MARK_SUPPORTED \
		UINT32_C(0x1)
	/*
	 * If 1, the device can report the number of received packets
	 * that it marked as having experienced congestion.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_ECN_STATS_SUPPORTED \
		UINT32_C(0x2)
	/*
	 * If 1, the device can report extended hw statistics (including
	 * additional tpa statistics).
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_EXT_HW_STATS_SUPPORTED \
		UINT32_C(0x4)
	/*
	 * If set to 1, then the core firmware has support to enable/
	 * disable hot reset support for interface dynamically through
	 * HWRM_FUNC_CFG.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_HOT_RESET_IF_SUPPORT \
		UINT32_C(0x8)
	/* If 1, the proxy mode is supported on this function */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PROXY_MODE_SUPPORT \
		UINT32_C(0x10)
	/*
	 * If 1, the tx rings source interface override feature is supported
	 * on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_TX_PROXY_SRC_INTF_OVERRIDE_SUPPORT \
		UINT32_C(0x20)
	/*
	 * If 1, the device supports scheduler queues. SCHQs can be managed
	 * using RING_SCHQ_ALLOC/CFG/FREE commands.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_SCHQ_SUPPORTED \
		UINT32_C(0x40)
	/*
	 * If set to 1, then this function supports the TX push mode that
	 * uses ping-pong buffers from the push pages.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PPP_PUSH_MODE_SUPPORTED \
		UINT32_C(0x80)
	/*
	 * If set to 1, then this function doesn't have the privilege to
	 * configure the EVB mode of the port it uses.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_EVB_MODE_CFG_NOT_SUPPORTED \
		UINT32_C(0x100)
	/*
	 * If set to 1, then the HW and FW support the SoC packet DMA
	 * datapath between SoC and NIC. This function can act as the
	 * HWRM communication transport agent on behalf of the SoC SPD
	 * software module. This capability is only advertised to the
	 * SoC PFs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_SOC_SPD_SUPPORTED \
		UINT32_C(0x200)
	/*
	 * If set to 1, then this function supports FW_LIVEPATCH for
	 * firmware livepatch commands.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_FW_LIVEPATCH_SUPPORTED \
		UINT32_C(0x400)
	/*
	 * When this bit is '1', it indicates that core firmware is
	 * capable of fast Reset.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_FAST_RESET_CAPABLE \
		UINT32_C(0x800)
	/*
	 * When this bit is '1', it indicates that firmware and hardware
	 * are capable of updating tx_metadata via hwrm_ring_cfg command.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_TX_METADATA_CFG_CAPABLE \
		UINT32_C(0x1000)
	/*
	 * If set to 1, then the device can report the action
	 * needed to activate set nvm options.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_NVM_OPTION_ACTION_SUPPORTED \
		UINT32_C(0x2000)
	/*
	 * When this bit is '1', it indicates that the BD metadata feature
	 * is supported for this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_BD_METADATA_SUPPORTED \
		UINT32_C(0x4000)
	/*
	 * When this bit is '1', it indicates that the echo request feature
	 * is supported for this function. If the driver registers for the
	 * echo request asynchronous event, then the firmware can send an
	 * unsolicited echo request to the driver and expect an echo
	 * response.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_ECHO_REQUEST_SUPPORTED \
		UINT32_C(0x8000)
	/*
	 * When this bit is '1', it indicates that core firmware supports
	 * NPAR 1.2 on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_NPAR_1_2_SUPPORTED \
		UINT32_C(0x10000)
	/* When this bit is '1', it indicates that PTM feature is supported. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PTP_PTM_SUPPORTED \
		UINT32_C(0x20000)
	/* When this bit is '1', it indicates that PPS feature is supported. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PTP_PPS_SUPPORTED \
		UINT32_C(0x40000)
	/*
	 * When this bit is '1', it indicates that VF config. change
	 * async event is supported on the parent PF if the async.
	 * event is registered by the PF.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_VF_CFG_ASYNC_FOR_PF_SUPPORTED \
		UINT32_C(0x80000)
	/*
	 * When this bit is '1', the NIC supports configuration of
	 * partition_min_bw and partition_max_bw. Configuration of a
	 * minimum guaranteed bandwidth is only supported if the
	 * min_bw_supported flag is also set.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PARTITION_BW_SUPPORTED \
		UINT32_C(0x100000)
	/*
	 * When this bit is '1', the FW supports configuration of
	 * PCP and TPID values of the default VLAN.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_DFLT_VLAN_TPID_PCP_SUPPORTED \
		UINT32_C(0x200000)
	/* When this bit is '1', it indicates that HW and FW support KTLS. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_KTLS_SUPPORTED \
		UINT32_C(0x400000)
	/*
	 * When this bit is '1', the firmware supports HWRM_PORT_EP_TX_CFG
	 * and HWRM_PORT_EP_TX_QCFG for endpoint rate control, and additions
	 * to HWRM_QUEUE_GLOBAL_CFG and HWRM_QUEUE_GLOBAL_QCFG for receive
	 * rate control. Configuration of a minimum guaranteed bandwidth
	 * is only supported if the min_bw_supported flag is also set.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_EP_RATE_CONTROL \
		UINT32_C(0x800000)
	/*
	 * When this bit is '1', the firmware supports enforcement of
	 * minimum guaranteed bandwidth. A minimum guaranteed bandwidth
	 * could be configured for a partition or for an endpoint. Firmware
	 * only sets this flag if one or both of the ep_rate_control and
	 * partition_bw_supported flags are set.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_MIN_BW_SUPPORTED \
		UINT32_C(0x1000000)
	/*
	 * When this bit is '1', HW supports TX coalesced completion
	 * records.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_TX_COAL_CMPL_CAP \
		UINT32_C(0x2000000)
	/*
	 * When this bit is '1', it indicates the FW has full support
	 * for all backing store types with the BACKING_STORE_CFG/QCFG
	 * V2 APIs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_BS_V2_SUPPORTED \
		UINT32_C(0x4000000)
	/*
	 * When this bit is '1', it indicates the FW forces to use the
	 * BACKING_STORE_CFG/QCFG V2 APIs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_BS_V2_REQUIRED \
		UINT32_C(0x8000000)
	/*
	 * When this bit is '1', it indicates that FW will support a single
	 * 64bit real time clock for PTP.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PTP_64BIT_RTC_SUPPORTED \
		UINT32_C(0x10000000)
	/*
	 * When this bit is '1', it indicates the FW is capable of
	 * supporting Doorbell Pacing.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_DBR_PACING_SUPPORTED \
		UINT32_C(0x20000000)
	/*
	 * When this bit is '1', it indicates the FW is capable of
	 * supporting HW based doorbell drop recovery.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_HW_DBR_DROP_RECOV_SUPPORTED \
		UINT32_C(0x40000000)
	/*
	 * When this bit is '1', it indicates the driver can disable the CQ
	 * overflow detection and can also skip the index updates for CQ.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_DISABLE_CQ_OVERFLOW_DETECTION_SUPPORTED \
		UINT32_C(0x80000000)
	/* The maximum number of SCHQs supported by this device. */
	uint8_t	max_schqs;
	uint8_t	mpc_chnls_cap;
	/*
	 * When this bit is '1', it indicates that HW and firmware
	 * supports the use of a MPC channel with destination set
	 * to the TX crypto engine block.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_MPC_CHNLS_CAP_TCE         UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates that HW and firmware
	 * supports the use of a MPC channel with destination set
	 * to the RX crypto engine block.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_MPC_CHNLS_CAP_RCE         UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates that HW and firmware
	 * supports the use of a MPC channel with destination set
	 * to the TX configurable flow processing block.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_MPC_CHNLS_CAP_TE_CFA      UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates that HW and firmware
	 * supports the use of a MPC channel with destination set
	 * to the RX configurable flow processing block.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_MPC_CHNLS_CAP_RE_CFA      UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates that HW and firmware
	 * supports the use of a MPC channel with destination set
	 * to the primate processor block.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_MPC_CHNLS_CAP_PRIMATE     UINT32_C(0x10)
	/*
	 * Maximum number of Key Contexts supported per HWRM
	 * function call for allocating Key Contexts.
	 */
	uint16_t	max_key_ctxs_alloc;
	uint32_t	flags_ext2;
	/*
	 * When this bit is '1', it indicates that FW will support
	 * timestamping on all RX packets, not just PTP type packets.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_RX_ALL_PKTS_TIMESTAMPS_SUPPORTED \
		UINT32_C(0x1)
	/* When this bit is '1', it indicates that HW and FW support QUIC. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_QUIC_SUPPORTED \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates that KDNet mode is
	 * supported on the port for this function.  This bit is
	 * never set for a VF.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_KDNET_SUPPORTED \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates the FW is capable of
	 * supporting Enhanced Doorbell Pacing.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_DBR_PACING_EXT_SUPPORTED \
		UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates that FW is capable of
	 * supporting software based doorbell drop recovery.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_SW_DBR_DROP_RECOVERY_SUPPORTED \
		UINT32_C(0x10)
	/*
	 * When this bit is '1', it indicates the FW supports collection
	 * and query of the generic statistics.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_GENERIC_STATS_SUPPORTED \
		UINT32_C(0x20)
	/*
	 * When this bit is '1', it indicates that the HW is capable of
	 * supporting UDP GSO on the function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_UDP_GSO_SUPPORTED \
		UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that SyncE feature is
	 * supported.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_SYNCE_SUPPORTED \
		UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates the FW is capable of
	 * supporting doorbell pacing version 0. As doorbell pacing
	 * notification from hardware for Thor2 is completely different
	 * from Thor1, this flag is used to differentiate the doorbell
	 * pacing notification between Thor1 and Thor2. Thor1 uses
	 * dbr_pacing_supported and dbr_pacing_ext_supported flags for
	 * doorbell pacing whereas Thor2 uses dbr_pacing_v0_supported flag.
	 * These flags will never be set at the same time for Thor2.
	 * Based on this flag, host drivers assume doorbell pacing is needed
	 * for Thor2.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_DBR_PACING_V0_SUPPORTED \
		UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates that the HW supports
	 * two-completion TX packet timestamp feature, a second completion
	 * carrying packet TX timestamp in addition to the standard
	 * completion returned for packets. Host driver should not use
	 * HWRM port timestamp query (HWRM_PORT_TS_QUERY) command for
	 * TX timestamp read when two-completion timestamp feature is
	 * supported.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_TX_PKT_TS_CMPL_SUPPORTED \
		UINT32_C(0x200)
	/*
	 * When this bit is '1', it indicates that the hardware based
	 * link aggregation group (L2 and RoCE) feature is supported.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_HW_LAG_SUPPORTED \
		UINT32_C(0x400)
	uint16_t	tunnel_disable_flag;
	/*
	 * When this bit is '1', it indicates that the VXLAN parsing
	 * is disabled in hardware
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_TUNNEL_DISABLE_FLAG_DISABLE_VXLAN \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates that the NGE parsing
	 * is disabled in hardware
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_TUNNEL_DISABLE_FLAG_DISABLE_NGE \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates that the NVGRE parsing
	 * is disabled in hardware
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_TUNNEL_DISABLE_FLAG_DISABLE_NVGRE \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates that the L2GRE parsing
	 * is disabled in hardware
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_TUNNEL_DISABLE_FLAG_DISABLE_L2GRE \
		UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates that the GRE parsing
	 * is disabled in hardware
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_TUNNEL_DISABLE_FLAG_DISABLE_GRE \
		UINT32_C(0x10)
	/*
	 * When this bit is '1', it indicates that the IPINIP parsing
	 * is disabled in hardware
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_TUNNEL_DISABLE_FLAG_DISABLE_IPINIP \
		UINT32_C(0x20)
	/*
	 * When this bit is '1', it indicates that the MPLS parsing
	 * is disabled in hardware
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_TUNNEL_DISABLE_FLAG_DISABLE_MPLS \
		UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that the PPPOE parsing
	 * is disabled in hardware
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_TUNNEL_DISABLE_FLAG_DISABLE_PPPOE \
		UINT32_C(0x80)
	uint8_t	unused_1[2];
	/*
	 * This value uniquely identifies the hardware NIC used by the
	 * function. The value returned will be the same for all functions.
	 * A value of 00-00-00-00-00-00-00-00 indicates no device serial number
	 * is currently configured. This is the same value that is returned by
	 * PCIe Capability Device Serial Number.
	 */
	uint8_t	device_serial_number[8];
	uint8_t	unused_2[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************
 * hwrm_func_qcfg *
 ******************/


/* hwrm_func_qcfg_input (size:192b/24B) */
struct hwrm_func_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 * 0xFFFE (REQUESTING_PARENT_FID) This is a special FID
	 * to be used by a trusted VF to query its parent PF.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_func_qcfg_output (size:1024b/128B) */
struct hwrm_func_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * FID value.  This value is used to identify operations on the PCI
	 * bus as belonging to a particular PCI function.
	 */
	uint16_t	fid;
	/*
	 * Port ID of port that this function is associated with.
	 * 0xFF... (All Fs) if this function is not associated with
	 * any port.
	 */
	uint16_t	port_id;
	/*
	 * This value is the current VLAN setting for this
	 * function. The value of 0 for this field indicates
	 * no priority tagging or VLAN is used.
	 * This field's format is same as 802.1Q Tag's
	 * Tag Control Information (TCI) format that includes both
	 * Priority Code Point (PCP) and VLAN Identifier (VID).
	 */
	uint16_t	vlan;
	uint16_t	flags;
	/*
	 * If 1, then magic packet based Out-Of-Box WoL is enabled on
	 * the port associated with this function.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_OOB_WOL_MAGICPKT_ENABLED \
		UINT32_C(0x1)
	/*
	 * If 1, then bitmap pattern based Out-Of-Box WoL packet is enabled
	 * on the port associated with this function.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_OOB_WOL_BMP_ENABLED \
		UINT32_C(0x2)
	/*
	 * If set to 1, then FW based DCBX agent is enabled and running on
	 * the port associated with this function.
	 * If set to 0, then DCBX agent is not running in the firmware.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_FW_DCBX_AGENT_ENABLED \
		UINT32_C(0x4)
	/*
	 * Standard TX Ring mode is used for the allocation of TX ring
	 * and underlying scheduling resources that allow bandwidth
	 * reservation and limit settings on the queried function.
	 * If set to 1, then standard TX ring mode is enabled
	 * on the queried function.
	 * If set to 0, then the standard TX ring mode is disabled
	 * on the queried function. In this extended TX ring resource
	 * mode, the minimum and maximum bandwidth settings are not
	 * supported to allow the allocation of TX rings to span multiple
	 * scheduler nodes.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_STD_TX_RING_MODE_ENABLED \
		UINT32_C(0x8)
	/*
	 * If set to 1 then FW based LLDP agent is enabled and running on
	 * the port associated with this function.
	 * If set to 0 then the LLDP agent is not running in the firmware.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_FW_LLDP_AGENT_ENABLED \
		UINT32_C(0x10)
	/*
	 * If set to 1, then multi-host mode is active for this function.
	 * The NIC is attached to two or more independent host systems
	 * through two or more PCIe endpoints.
	 * If set to 0, then multi-host mode is inactive for this function
	 * or not applicable for this device.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_MULTI_HOST \
		UINT32_C(0x20)
	/*
	 * If the function that is being queried is a PF, then the HWRM shall
	 * set this field to 0 and the HWRM client shall ignore this field.
	 * If the function that is being queried is a VF, then the HWRM shall
	 * set this field to 1 if the queried VF is trusted, otherwise the HWRM
	 * shall set this field to 0.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_TRUSTED_VF \
		UINT32_C(0x40)
	/*
	 * If set to 1, then secure mode is enabled for this function or device.
	 * If set to 0, then secure mode is disabled (or normal mode) for this
	 * function or device.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_SECURE_MODE_ENABLED \
		UINT32_C(0x80)
	/*
	 * If set to 1, then this PF is enabled with a preboot driver that
	 * requires access to the legacy L2 ring model and legacy 32b
	 * doorbells. If set to 0, then this PF is not allowed to use
	 * the legacy L2 rings. This feature is not allowed on VFs and
	 * is only relevant for devices that require a context backing
	 * store.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_PREBOOT_LEGACY_L2_RINGS \
		UINT32_C(0x100)
	/*
	 * If set to 1, then the firmware and all currently registered driver
	 * instances support hot reset. The hot reset support will be updated
	 * dynamically based on the driver interface advertisement.
	 * If set to 0, then the adapter is not currently able to initiate
	 * hot reset.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_HOT_RESET_ALLOWED \
		UINT32_C(0x200)
	/*
	 * If set to 1, then the PPP tx push mode is enabled for all the
	 * reserved TX rings of this function. If set to 0, then PPP tx push
	 * mode is disabled for all the reserved TX rings of this function.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_PPP_PUSH_MODE_ENABLED \
		UINT32_C(0x400)
	/*
	 * If set to 1, then the firmware will notify driver using async
	 * event when a ring is disabled due to a Hardware error.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_RING_MONITOR_ENABLED \
		UINT32_C(0x800)
	/*
	 * If set to 1, then the firmware and all currently registered driver
	 * instances support fast reset. The fast reset support will be
	 * updated dynamically based on the driver interface advertisement.
	 * If set to 0, then the adapter is not currently able to initiate
	 * fast reset.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_FAST_RESET_ALLOWED \
		UINT32_C(0x1000)
	/*
	 * If set to 1, then multi-root mode is active for this function.
	 * The NIC is attached to a single host with a single operating
	 * system, but through two or more PCIe endpoints.
	 * If set to 0, then multi-root mode is inactive for this function
	 * or not applicable for this device.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_MULTI_ROOT \
		UINT32_C(0x2000)
	/*
	 * This flag indicates RDMA support for child VFS of
	 * a physical function.
	 * If set to 1, RoCE is supported on all child VFs.
	 * If set to 0, RoCE is disabled on all child VFs.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_ENABLE_RDMA_SRIOV \
		UINT32_C(0x4000)
	/*
	 * This value is current MAC address configured for this
	 * function. A value of 00-00-00-00-00-00 indicates no
	 * MAC address is currently configured.
	 */
	uint8_t	mac_address[6];
	/*
	 * This value is current PCI ID of this
	 * function. If ARI is enabled, then it is
	 * Bus Number (8b):Function Number(8b). Otherwise, it is
	 * Bus Number (8b):Device Number (4b):Function Number(4b).
	 * If multi-host mode is active, the 4 lsb will indicate
	 * the PF index for this function.
	 */
	uint16_t	pci_id;
	/*
	 * The number of RSS/COS contexts currently
	 * allocated to the function.
	 */
	uint16_t	alloc_rsscos_ctx;
	/*
	 * The number of completion rings currently allocated to
	 * the function. This does not include the rings allocated
	 * to any children functions if any.
	 */
	uint16_t	alloc_cmpl_rings;
	/*
	 * The number of transmit rings currently allocated to
	 * the function. This does not include the rings allocated
	 * to any children functions if any.
	 */
	uint16_t	alloc_tx_rings;
	/*
	 * The number of receive rings currently allocated to
	 * the function. This does not include the rings allocated
	 * to any children functions if any.
	 */
	uint16_t	alloc_rx_rings;
	/* The allocated number of L2 contexts to the function. */
	uint16_t	alloc_l2_ctx;
	/* The allocated number of vnics to the function. */
	uint16_t	alloc_vnics;
	/*
	 * The maximum transmission unit of the function
	 * configured by the admin pf.
	 * If the reported mtu value is non-zero then it will be used for the
	 * rings allocated on this function, otherwise the default
	 * value is used if ring MTU is not specified.
	 * The driver cannot use any MTU bigger than this value
	 * if it is non-zero.
	 */
	uint16_t	admin_mtu;
	/*
	 * The maximum receive unit of the function.
	 * For vnics allocated on this function, this default
	 * value is used if vnic MRU is not specified.
	 */
	uint16_t	mru;
	/* The statistics context assigned to a function. */
	uint16_t	stat_ctx_id;
	/*
	 * The HWRM shall return Unknown value for this field
	 * when this command is used to query VF's configuration.
	 */
	uint8_t	port_partition_type;
	/* Single physical function */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_SPF     UINT32_C(0x0)
	/* Multiple physical functions */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_MPFS    UINT32_C(0x1)
	/* Network Partitioning 1.0 */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_NPAR1_0 UINT32_C(0x2)
	/* Network Partitioning 1.5 */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_NPAR1_5 UINT32_C(0x3)
	/* Network Partitioning 2.0 */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_NPAR2_0 UINT32_C(0x4)
	/* Network Partitioning 1.2 */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_NPAR1_2 UINT32_C(0x5)
	/* Unknown */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_UNKNOWN \
		UINT32_C(0xff)
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_LAST \
		HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_UNKNOWN
	/*
	 * This field will indicate number of physical functions on this port_partition.
	 * HWRM shall return unavail (i.e. value of 0) for this field
	 * when this command is used to query VF's configuration or
	 * from older firmware that doesn't support this field.
	 */
	uint8_t	port_pf_cnt;
	/* number of PFs is not available */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PF_CNT_UNAVAIL UINT32_C(0x0)
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PF_CNT_LAST \
		HWRM_FUNC_QCFG_OUTPUT_PORT_PF_CNT_UNAVAIL
	/*
	 * The default VNIC ID assigned to a function that is
	 * being queried.
	 */
	uint16_t	dflt_vnic_id;
	uint16_t	max_mtu_configured;
	/*
	 * Minimum guaranteed transmit bandwidth for this function. When
	 * specified for a PF, does not affect traffic from the PF's child VFs.
	 * A value of 0 indicates the minimum bandwidth is not configured.
	 */
	uint32_t	min_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_SFT              0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE_LAST \
		HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_SFT         29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of link bandwidth. */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum transmit rate for this function. When specified for a PF,
	 * does not affect traffic from the PF's child VFs.
	 * A value of 0 indicates that the maximum bandwidth is not configured.
	 */
	uint32_t	max_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_SFT              0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE_LAST \
		HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_SFT         29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of link bandwidth. */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_INVALID
	/*
	 * This value indicates the Edge virtual bridge mode for the
	 * domain that this function belongs to.
	 */
	uint8_t	evb_mode;
	/* No Edge Virtual Bridging (EVB) */
	#define HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_NO_EVB UINT32_C(0x0)
	/* Virtual Ethernet Bridge (VEB) */
	#define HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_VEB    UINT32_C(0x1)
	/* Virtual Ethernet Port Aggregator (VEPA) */
	#define HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_VEPA   UINT32_C(0x2)
	#define HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_LAST \
		HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_VEPA
	uint8_t	options;
	/*
	 * This value indicates the PCIE device cache line size.
	 * The cache line size allows the DMA writes to terminate and
	 * start at the cache boundary.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_MASK \
		UINT32_C(0x3)
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_SFT          0
	/* Cache Line Size 64 bytes */
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_SIZE_64 \
		UINT32_C(0x0)
	/* Cache Line Size 128 bytes */
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_SIZE_128 \
		UINT32_C(0x1)
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_LAST \
		HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_SIZE_128
	/* This value is the virtual link admin state setting. */
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_MASK \
		UINT32_C(0xc)
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_SFT        2
	/* Admin link state is in forced down mode. */
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_FORCED_DOWN \
		(UINT32_C(0x0) << 2)
	/* Admin link state is in forced up mode. */
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_FORCED_UP \
		(UINT32_C(0x1) << 2)
	/* Admin link state is in auto mode  - follows the physical link state. */
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_AUTO \
		(UINT32_C(0x2) << 2)
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_LAST \
		HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_AUTO
	/* Reserved for future. */
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_RSVD_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_RSVD_SFT                    4
	/*
	 * The number of VFs that are allocated to the function.
	 * This is valid only on the PF with SR-IOV enabled.
	 * 0xFF... (All Fs) if this command is called on a PF with
	 * SR-IOV disabled or on a VF.
	 */
	uint16_t	alloc_vfs;
	/*
	 * The number of allocated multicast filters for this
	 * function on the RX side.
	 */
	uint32_t	alloc_mcast_filters;
	/*
	 * The number of allocated HW ring groups for this
	 * function.
	 */
	uint32_t	alloc_hw_ring_grps;
	/*
	 * The number of strict priority transmit rings out of
	 * currently allocated TX rings to the function
	 * (alloc_tx_rings).
	 */
	uint16_t	alloc_sp_tx_rings;
	/*
	 * The number of statistics contexts
	 * currently reserved for the function.
	 */
	uint16_t	alloc_stat_ctx;
	/*
	 * This field specifies how many NQs are reserved for the PF.
	 * Remaining NQs that belong to the PF are available for VFs.
	 * Once a PF has created VFs, it cannot change how many NQs are
	 * reserved for itself (since the NQs must be contiguous in HW).
	 */
	uint16_t	alloc_msix;
	/*
	 * The number of registered VFs associated with the PF. This field
	 * should be ignored when the request received on the VF interface.
	 * This field will be updated on the PF interface to initiate
	 * the unregister request on PF in the HOT Reset Process.
	 */
	uint16_t	registered_vfs;
	/*
	 * The size of the doorbell BAR in KBytes reserved for L2 including
	 * any area that is shared between L2 and RoCE.  The L2 driver
	 * should only map the L2 portion of the doorbell BAR.  Any rounding
	 * of the BAR size to the native CPU page size should be performed
	 * by the driver.  If the value is zero, no special partitioning
	 * of the doorbell BAR between L2 and RoCE is required.
	 */
	uint16_t	l2_doorbell_bar_size_kb;
	uint8_t	unused_1;
	/*
	 * For backward compatibility this field must be set to 1.
	 * Older drivers might look for this field to be 1 before
	 * processing the message.
	 */
	uint8_t	always_1;
	/*
	 * This GRC address location is used by the Host driver interfaces to poll
	 * the adapter ready state to re-initiate the registration process again
	 * after receiving the RESET Notify event.
	 */
	uint32_t	reset_addr_poll;
	/*
	 * This field specifies legacy L2 doorbell size in KBytes. Drivers should use
	 * this value to find out the doorbell page offset from the BAR.
	 */
	uint16_t	legacy_l2_db_size_kb;
	uint16_t	svif_info;
	/*
	 * This field specifies the source virtual interface of the function being
	 * queried. Drivers can use this to program svif field in the L2 context
	 * table
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_SVIF_INFO_SVIF_MASK      UINT32_C(0x7fff)
	#define HWRM_FUNC_QCFG_OUTPUT_SVIF_INFO_SVIF_SFT       0
	/* This field specifies whether svif is valid or not */
	#define HWRM_FUNC_QCFG_OUTPUT_SVIF_INFO_SVIF_VALID     UINT32_C(0x8000)
	uint8_t	mpc_chnls;
	/*
	 * When this bit is '1', it indicates that a MPC channel with
	 * destination set to the TX crypto engine block is enabled.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_MPC_CHNLS_TCE_ENABLED \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates that a MPC channel with
	 * destination set to the RX crypto engine block is enabled.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_MPC_CHNLS_RCE_ENABLED \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates that a MPC channel with
	 * destination set to the TX configurable flow processing block is
	 * enabled.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_MPC_CHNLS_TE_CFA_ENABLED \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates that a MPC channel with
	 * destination set to the RX configurable flow processing block is
	 * enabled.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_MPC_CHNLS_RE_CFA_ENABLED \
		UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates that a MPC channel with
	 * destination set to the primate processor block is enabled.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_MPC_CHNLS_PRIMATE_ENABLED \
		UINT32_C(0x10)
	/*
	 * Configured doorbell page size for this function.
	 * This field is valid for PF only.
	 */
	uint8_t	db_page_size;
	/* DB page size is 4KB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_4KB   UINT32_C(0x0)
	/* DB page size is 8KB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_8KB   UINT32_C(0x1)
	/* DB page size is 16KB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_16KB  UINT32_C(0x2)
	/* DB page size is 32KB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_32KB  UINT32_C(0x3)
	/* DB page size is 64KB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_64KB  UINT32_C(0x4)
	/* DB page size is 128KB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_128KB UINT32_C(0x5)
	/* DB page size is 256KB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_256KB UINT32_C(0x6)
	/* DB page size is 512KB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_512KB UINT32_C(0x7)
	/* DB page size is 1MB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_1MB   UINT32_C(0x8)
	/* DB page size is 2MB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_2MB   UINT32_C(0x9)
	/* DB page size is 4MB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_4MB   UINT32_C(0xa)
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_LAST \
		HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_4MB
	uint8_t	unused_2[2];
	/*
	 * Minimum guaranteed bandwidth for the network partition made up
	 * of the caller physical function and all its child virtual
	 * functions. The rate is specified as a percentage of the bandwidth
	 * of the link the partition is associated with. A value of 0
	 * indicates that no minimum bandwidth is configured.
	 * The format of this field is defined to match min_bw, even though
	 * the partition minimum rate is always specified as a percentage.
	 */
	uint32_t	partition_min_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_SFT \
		0
	/*
	 * The granularity of the value (bits or bytes). Firmware never sets
	 * this field.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_SCALE_LAST \
		HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_SCALE_BYTES
	/* Always percentage of link bandwidth. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Bandwidth value is in hundredths of a percent of link bandwidth. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
	/*
	 * The maximum bandwidth that may be used by the network partition
	 * made up of the caller physical function and all its child virtual
	 * functions. The rate is specified as a percentage of the bandwidth
	 * of the link the partition is associated with. A value of 0
	 * indicates that no maximum bandwidth is configured.
	 * The format of this field is defined to match max_bw, even though
	 * the partition bandwidth must be specified as a percentage.
	 */
	uint32_t	partition_max_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_SFT \
		0
	/*
	 * The granularity of the value (bits or bytes). Firmware never sets
	 * this field.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_SCALE_LAST \
		HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_SCALE_BYTES
	/* Always a percentage of link bandwidth. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in hundredths of a percent of link bandwidth. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
	/*
	 * The maximum transmission unit of the function
	 * configured by the host pf/vf.
	 * If the reported mtu value is non-zero then it will be used for the
	 * rings allocated on this function, otherwise the default
	 * value is used if ring MTU is not specified.
	 */
	uint16_t	host_mtu;
	uint8_t	unused_3[2];
	uint8_t	unused_4[2];
	/*
	 * KDNet mode for the port for this function.  If a VF, KDNet
	 * mode is always disabled.
	 */
	uint8_t	port_kdnet_mode;
	/* KDNet mode is not enabled on the port for this function. */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_KDNET_MODE_DISABLED UINT32_C(0x0)
	/* KDNet mode is enabled on the port for this function. */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_KDNET_MODE_ENABLED  UINT32_C(0x1)
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_KDNET_MODE_LAST \
		HWRM_FUNC_QCFG_OUTPUT_PORT_KDNET_MODE_ENABLED
	/*
	 * If KDNet mode is enabled, the PCI function number of the
	 * KDNet partition.
	 */
	uint8_t	kdnet_pcie_function;
	/*
	 * Function ID of the KDNET function on this port.  If the
	 * KDNET partition does not exist and the FW supports this
	 * feature, 0xffff will be returned.
	 */
	uint16_t	port_kdnet_fid;
	uint8_t	unused_5[2];
	/* Number of Tx Key Contexts allocated. */
	uint32_t	alloc_tx_key_ctxs;
	/* Number of Rx Key Contexts allocated. */
	uint32_t	alloc_rx_key_ctxs;
	uint8_t	unused_6[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************
 * hwrm_func_cfg *
 *****************/


/* hwrm_func_cfg_input (size:1024b/128B) */
struct hwrm_func_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being
	 * configured.
	 * If set to 0xFF... (All Fs), then the configuration is
	 * for the requesting function.
	 */
	uint16_t	fid;
	/*
	 * This field specifies how many NQs will be reserved for the PF.
	 * Remaining NQs that belong to the PF become available for VFs.
	 * Once a PF has created VFs, it cannot change how many NQs are
	 * reserved for itself (since the NQs must be contiguous in HW).
	 */
	uint16_t	num_msix;
	uint32_t	flags;
	/*
	 * When this bit is '1', the function is disabled with
	 * source MAC address check.
	 * This is an anti-spoofing check. If this flag is set,
	 * then the function shall be configured to disallow
	 * transmission of frames with the source MAC address that
	 * is configured for this function.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_SRC_MAC_ADDR_CHECK_DISABLE \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', the function is enabled with
	 * source MAC address check.
	 * This is an anti-spoofing check. If this flag is set,
	 * then the function shall be configured to allow
	 * transmission of frames with the source MAC address that
	 * is configured for this function.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_SRC_MAC_ADDR_CHECK_ENABLE \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_RSVD_MASK \
		UINT32_C(0x1fc)
	#define HWRM_FUNC_CFG_INPUT_FLAGS_RSVD_SFT                       2
	/*
	 * Standard TX Ring mode is used for the allocation of TX ring
	 * and underlying scheduling resources that allow bandwidth
	 * reservation and limit settings on the queried function.
	 * If set to 1, then standard TX ring mode is requested to be
	 * enabled on the function being configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_STD_TX_RING_MODE_ENABLE \
		UINT32_C(0x200)
	/*
	 * Standard TX Ring mode is used for the allocation of TX ring
	 * and underlying scheduling resources that allow bandwidth
	 * reservation and limit settings on the queried function.
	 * If set to 1, then the standard TX ring mode is requested to
	 * be disabled on the function being configured. In this extended
	 * TX ring resource mode, the minimum and maximum bandwidth settings
	 * are not supported to allow the allocation of TX rings to
	 * span multiple scheduler nodes.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_STD_TX_RING_MODE_DISABLE \
		UINT32_C(0x400)
	/*
	 * If this bit is set, virtual mac address configured
	 * in this command will be persistent over warm boot.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_VIRT_MAC_PERSIST \
		UINT32_C(0x800)
	/*
	 * This bit only applies to the VF. If this bit is set, the statistic
	 * context counters will not be cleared when the statistic context is freed
	 * or a function reset is called on VF. This bit will be cleared when the PF
	 * is unloaded or a function reset is called on the PF.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_NO_AUTOCLEAR_STATISTIC \
		UINT32_C(0x1000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of TX rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_TX_ASSETS_TEST \
		UINT32_C(0x2000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of RX rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_RX_ASSETS_TEST \
		UINT32_C(0x4000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of CMPL rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_CMPL_ASSETS_TEST \
		UINT32_C(0x8000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of RSS ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_RSSCOS_CTX_ASSETS_TEST \
		UINT32_C(0x10000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of ring groups) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_RING_GRP_ASSETS_TEST \
		UINT32_C(0x20000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of stat ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_STAT_CTX_ASSETS_TEST \
		UINT32_C(0x40000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of VNICs) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_VNIC_ASSETS_TEST \
		UINT32_C(0x80000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of L2 ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_L2_CTX_ASSETS_TEST \
		UINT32_C(0x100000)
	/*
	 * This configuration change can be initiated by a PF driver. This
	 * configuration request shall be targeted to a VF. From local host
	 * resident HWRM clients, only the parent PF driver shall be allowed
	 * to initiate this change on one of its children VFs. If this bit is
	 * set to 1, then the VF that is being configured is requested to be
	 * trusted.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_TRUSTED_VF_ENABLE \
		UINT32_C(0x200000)
	/*
	 * When this bit it set, even if PF reserved pool size is zero,
	 * FW will allow driver to create TX rings in ring alloc,
	 * by reserving TX ring, S3 node dynamically.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_DYNAMIC_TX_RING_ALLOC \
		UINT32_C(0x400000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of NQ rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_NQ_ASSETS_TEST \
		UINT32_C(0x800000)
	/*
	 * This configuration change can be initiated by a PF driver. This
	 * configuration request shall be targeted to a VF. From local host
	 * resident HWRM clients, only the parent PF driver shall be allowed
	 * to initiate this change on one of its children VFs. If this bit is
	 * set to 1, then the VF that is being configured is requested to be
	 * untrusted.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_TRUSTED_VF_DISABLE \
		UINT32_C(0x1000000)
	/*
	 * This bit is used by preboot drivers on a PF that require access
	 * to the legacy L2 ring model and legacy 32b doorbells. This
	 * feature is not allowed on VFs and is only relevant for devices
	 * that require a context backing store.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_PREBOOT_LEGACY_L2_RINGS \
		UINT32_C(0x2000000)
	/*
	 * If this bit is set to 0, then the interface does not support hot
	 * reset capability which it advertised with the hot_reset_support
	 * flag in HWRM_FUNC_DRV_RGTR. If any of the function has set this
	 * flag to 0, adapter cannot do the hot reset. In this state, if the
	 * firmware receives a hot reset request, firmware must fail the
	 * request. If this bit is set to 1, then interface is renabling the
	 * hot reset capability.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_HOT_RESET_IF_EN_DIS \
		UINT32_C(0x4000000)
	/*
	 * If this bit is set to 1, the PF driver is requesting FW
	 * to enable PPP TX PUSH feature on all the TX rings specified in
	 * the num_tx_rings field. By default, the PPP TX push feature is
	 * disabled for all the TX rings of the function. This flag is
	 * ignored if num_tx_rings field is not specified or the function
	 * doesn't support PPP tx push feature.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_PPP_PUSH_MODE_ENABLE \
		UINT32_C(0x8000000)
	/*
	 * If this bit is set to 1, the PF driver is requesting FW
	 * to disable PPP TX PUSH feature on all the TX rings specified in
	 * the num_tx_rings field. This flag is ignored if num_tx_rings
	 * field is not specified or the function doesn't support PPP tx
	 * push feature.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_PPP_PUSH_MODE_DISABLE \
		UINT32_C(0x10000000)
	/*
	 * If this bit is set to 1, the driver is requesting FW to enable
	 * the BD_METADATA feature for this function. The FW returns error
	 * on this request if the TX_METADATA is enabled for this function.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_BD_METADATA_ENABLE \
		UINT32_C(0x20000000)
	/*
	 * If this bit is set to 1, the driver is requesting FW to disable
	 * the BD_METADATA feature for this function. The FW returns error
	 * on this request if the TX_METADATA is enabled for this function.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_BD_METADATA_DISABLE \
		UINT32_C(0x40000000)
	/*
	 * If this bit is set to 1, the driver is requesting FW to see if
	 * all the assets requested in this command (i.e. number of KTLS/
	 * QUIC key contexts) are available. The firmware will return an
	 * error if the requested assets are not available. The firmware
	 * will NOT reserve the assets if they are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_KEY_CTX_ASSETS_TEST \
		UINT32_C(0x80000000)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the admin_mtu field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_ADMIN_MTU \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the mru field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_MRU \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the num_rsscos_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_RSSCOS_CTXS \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the num_cmpl_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_CMPL_RINGS \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the num_tx_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_TX_RINGS \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the num_rx_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_RX_RINGS \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the num_l2_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_L2_CTXS \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the num_vnics field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_VNICS \
		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the num_stat_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_STAT_CTXS \
		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the dflt_mac_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_DFLT_MAC_ADDR \
		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the dflt_vlan field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_DFLT_VLAN \
		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the dflt_ip_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_DFLT_IP_ADDR \
		UINT32_C(0x800)
	/*
	 * This bit must be '1' for the min_bw field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_MIN_BW \
		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the max_bw field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_MAX_BW \
		UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the async_event_cr field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_ASYNC_EVENT_CR \
		UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the vlan_antispoof_mode field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_VLAN_ANTISPOOF_MODE \
		UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the allowed_vlan_pris field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_ALLOWED_VLAN_PRIS \
		UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the evb_mode field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_EVB_MODE \
		UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the num_mcast_filters field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_MCAST_FILTERS \
		UINT32_C(0x40000)
	/*
	 * This bit must be '1' for the num_hw_ring_grps field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_HW_RING_GRPS \
		UINT32_C(0x80000)
	/*
	 * This bit must be '1' for the cache_linesize field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_CACHE_LINESIZE \
		UINT32_C(0x100000)
	/*
	 * This bit must be '1' for the num_msix field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_MSIX \
		UINT32_C(0x200000)
	/*
	 * This bit must be '1' for the link admin state field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_ADMIN_LINK_STATE \
		UINT32_C(0x400000)
	/*
	 * This bit must be '1' for the hot_reset_if_en_dis field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_HOT_RESET_IF_SUPPORT \
		UINT32_C(0x800000)
	/*
	 * This bit must be '1' for the schq_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_SCHQ_ID \
		UINT32_C(0x1000000)
	/*
	 * This bit must be '1' for the mpc_chnls field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_MPC_CHNLS \
		UINT32_C(0x2000000)
	/*
	 * This bit must be '1' for the partition_min_bw field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_PARTITION_MIN_BW \
		UINT32_C(0x4000000)
	/*
	 * This bit must be '1' for the partition_max_bw field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_PARTITION_MAX_BW \
		UINT32_C(0x8000000)
	/*
	 * This bit must be '1' for the tpid field to be
	 * configured. This bit is only valid when dflt_vlan enable
	 * bit is set.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_TPID \
		UINT32_C(0x10000000)
	/*
	 * This bit must be '1' for the host_mtu field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_HOST_MTU \
		UINT32_C(0x20000000)
	/*
	 * This bit must be '1' for the number of Tx Key Contexts
	 * field to be configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_TX_KEY_CTXS \
		UINT32_C(0x40000000)
	/*
	 * This bit must be '1' for the number of Rx Key Contexts
	 * field to be configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_RX_KEY_CTXS \
		UINT32_C(0x80000000)
	/*
	 * This field can be used by the admin PF to configure
	 * mtu of foster PFs.
	 * The maximum transmission unit of the function.
	 * The HWRM should make sure that the mtu of
	 * the function does not exceed the mtu of the physical
	 * port that this function is associated with.
	 *
	 * In addition to configuring mtu per function, it is
	 * possible to configure mtu per transmit ring.
	 * By default, the mtu of each transmit ring associated
	 * with a function is equal to the mtu of the function.
	 * The HWRM should make sure that the mtu of each transmit
	 * ring that is assigned to a function has a valid mtu.
	 */
	uint16_t	admin_mtu;
	/*
	 * The maximum receive unit of the function.
	 * The HWRM should make sure that the mru of
	 * the function does not exceed the mru of the physical
	 * port that this function is associated with.
	 *
	 * In addition to configuring mru per function, it is
	 * possible to configure mru per vnic.
	 * By default, the mru of each vnic associated
	 * with a function is equal to the mru of the function.
	 * The HWRM should make sure that the mru of each vnic
	 * that is assigned to a function has a valid mru.
	 */
	uint16_t	mru;
	/*
	 * The number of RSS/COS contexts requested for the
	 * function.
	 */
	uint16_t	num_rsscos_ctxs;
	/*
	 * The number of completion rings requested for the
	 * function. This does not include the rings allocated
	 * to any children functions if any.
	 */
	uint16_t	num_cmpl_rings;
	/*
	 * The number of transmit rings requested for the function.
	 * This does not include the rings allocated to any
	 * children functions if any.
	 */
	uint16_t	num_tx_rings;
	/*
	 * The number of receive rings requested for the function.
	 * This does not include the rings allocated
	 * to any children functions if any.
	 */
	uint16_t	num_rx_rings;
	/* The requested number of L2 contexts for the function. */
	uint16_t	num_l2_ctxs;
	/* The requested number of vnics for the function. */
	uint16_t	num_vnics;
	/* The requested number of statistic contexts for the function. */
	uint16_t	num_stat_ctxs;
	/*
	 * The number of HW ring groups that should
	 * be reserved for this function.
	 */
	uint16_t	num_hw_ring_grps;
	/* The default MAC address for the function being configured. */
	uint8_t	dflt_mac_addr[6];
	/*
	 * The default VLAN for the function being configured.
	 * This field's format is same as 802.1Q Tag's
	 * Tag Control Information (TCI) format that includes both
	 * Priority Code Point (PCP) and VLAN Identifier (VID).
	 */
	uint16_t	dflt_vlan;
	/*
	 * The default IP address for the function being configured.
	 * This address is only used in enabling source property check.
	 */
	uint32_t	dflt_ip_addr[4];
	/*
	 * Minimum guaranteed transmit bandwidth for this function. When
	 * specified for a PF, does not affect traffic from the PF's child VFs.
	 * A value of 0 indicates the minimum bandwidth is not configured.
	 */
	uint32_t	min_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_SFT              0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE_LAST \
		HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_SFT         29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum transmit rate for this function. When specified for a PF,
	 * does not affect traffic from the PF's child VFs.
	 * A value of 0 indicates that the maximum bandwidth is not configured.
	 */
	uint32_t	max_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_SFT              0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE_LAST \
		HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_SFT         29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_INVALID
	/*
	 * ID of the target completion ring for receiving asynchronous
	 * event completions. If this field is not valid, then the
	 * HWRM shall use the default completion ring of the function
	 * that is being configured as the target completion ring for
	 * providing any asynchronous event completions for that
	 * function.
	 * If this field is valid, then the HWRM shall use the
	 * completion ring identified by this ID as the target
	 * completion ring for providing any asynchronous event
	 * completions for the function that is being configured.
	 */
	uint16_t	async_event_cr;
	/* VLAN Anti-spoofing mode. */
	uint8_t	vlan_antispoof_mode;
	/* No VLAN anti-spoofing checks are enabled */
	#define HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_NOCHECK \
		UINT32_C(0x0)
	/* Validate VLAN against the configured VLAN(s) */
	#define HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_VALIDATE_VLAN \
		UINT32_C(0x1)
	/* Insert VLAN if it does not exist, otherwise discard */
	#define HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_INSERT_IF_VLANDNE \
		UINT32_C(0x2)
	/* Insert VLAN if it does not exist, override VLAN if it exists */
	#define HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_INSERT_OR_OVERRIDE_VLAN \
		UINT32_C(0x3)
	#define HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_LAST \
		HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_INSERT_OR_OVERRIDE_VLAN
	/*
	 * This bit field defines VLAN PRIs that are allowed on
	 * this function.
	 * If nth bit is set, then VLAN PRI n is allowed on this
	 * function.
	 */
	uint8_t	allowed_vlan_pris;
	/*
	 * The evb_mode is configured on a per port basis. The default evb_mode
	 * is configured based on the NVM EVB mode setting upon firmware
	 * initialization. The HWRM allows a PF driver to change EVB mode for a
	 * port used by the PF only when one of the following conditions is
	 * satisfied.
	 * 1. The current operating mode is single function mode.
	 *    (ie. one PF per port)
	 * 2. For SmartNIC, any one of the PAXC PFs is permitted to change the
	 *    EVB mode of the port used by the PAXC PF. None of the X86 PFs
	 *    should have privileges.
	 * The HWRM doesn't permit any PFs to change the underlying EVB mode
	 * when running as MHB or NPAR mode in performance NIC configuration.
	 * The HWRM doesn't permit a VF driver to change the EVB mode.
	 * Once the HWRM determines a function doesn't meet the conditions
	 * to configure the EVB mode, it sets the evb_mode_cfg_not_supported
	 * flag in HWRM_FUNC_QCAPS command response for the function.
	 * The HWRM takes into account the switching of EVB mode from one to
	 * another and reconfigure hardware resources as reqiured. The
	 * switching from VEB to VEPA mode requires the disabling of the
	 * loopback traffic. Additionally, source knockouts are handled
	 * differently in VEB and VEPA modes.
	 */
	uint8_t	evb_mode;
	/* No Edge Virtual Bridging (EVB) */
	#define HWRM_FUNC_CFG_INPUT_EVB_MODE_NO_EVB UINT32_C(0x0)
	/* Virtual Ethernet Bridge (VEB) */
	#define HWRM_FUNC_CFG_INPUT_EVB_MODE_VEB    UINT32_C(0x1)
	/* Virtual Ethernet Port Aggregator (VEPA) */
	#define HWRM_FUNC_CFG_INPUT_EVB_MODE_VEPA   UINT32_C(0x2)
	#define HWRM_FUNC_CFG_INPUT_EVB_MODE_LAST \
		HWRM_FUNC_CFG_INPUT_EVB_MODE_VEPA
	uint8_t	options;
	/*
	 * This value indicates the PCIE device cache line size.
	 * The cache line size allows the DMA writes to terminate and
	 * start at the cache boundary.
	 */
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_MASK \
		UINT32_C(0x3)
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_SFT          0
	/* Cache Line Size 64 bytes */
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_SIZE_64 \
		UINT32_C(0x0)
	/* Cache Line Size 128 bytes */
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_SIZE_128 \
		UINT32_C(0x1)
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_LAST \
		HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_SIZE_128
	/* This value is the virtual link admin state setting. */
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_MASK \
		UINT32_C(0xc)
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_SFT        2
	/* Admin state is forced down. */
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_FORCED_DOWN \
		(UINT32_C(0x0) << 2)
	/* Admin state is forced up. */
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_FORCED_UP \
		(UINT32_C(0x1) << 2)
	/* Admin state is in auto mode - is to follow the physical link state. */
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_AUTO \
		(UINT32_C(0x2) << 2)
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_LAST \
		HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_AUTO
	/* Reserved for future. */
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_RSVD_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_RSVD_SFT                    4
	/*
	 * The number of multicast filters that should
	 * be reserved for this function on the RX side.
	 */
	uint16_t	num_mcast_filters;
	/* Used by a PF driver to associate a SCHQ with a VF. */
	uint16_t	schq_id;
	uint16_t	mpc_chnls;
	/*
	 * When this bit is '1', the caller requests to enable a MPC
	 * channel with destination to the TX crypto engine block.
	 * When this bit is 0, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_TCE_ENABLE          UINT32_C(0x1)
	/*
	 * When this bit is '1', the caller requests to disable a MPC
	 * channel with destination to the TX crypto engine block.
	 * When this bit is 0, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_TCE_DISABLE         UINT32_C(0x2)
	/*
	 * When this bit is '1', the caller requests to enable a MPC
	 * channel with destination to the RX crypto engine block.
	 * When this bit is 0, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_RCE_ENABLE          UINT32_C(0x4)
	/*
	 * When this bit is '1', the caller requests to disable a MPC
	 * channel with destination to the RX crypto engine block.
	 * When this bit is 0, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_RCE_DISABLE         UINT32_C(0x8)
	/*
	 * When this bit is '1', the caller requests to enable a MPC
	 * channel with destination to the TX configurable flow processing
	 * block. When this bit is 0, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_TE_CFA_ENABLE \
		UINT32_C(0x10)
	/*
	 * When this bit is '1', the caller requests to disable a MPC
	 * channel with destination to the TX configurable flow processing
	 * block. When this bit is 0, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_TE_CFA_DISABLE \
		UINT32_C(0x20)
	/*
	 * When this bit is '1', the caller requests to enable a MPC
	 * channel with destination to the RX configurable flow processing
	 * block. When this bit is 0, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_RE_CFA_ENABLE \
		UINT32_C(0x40)
	/*
	 * When this bit is '1', the caller requests to disable a MPC
	 * channel with destination to the RX configurable flow processing
	 * block. When this bit is 0, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_RE_CFA_DISABLE \
		UINT32_C(0x80)
	/*
	 * When this bit is '1', the caller requests to enable a MPC
	 * channel with destination to the primate processor block.
	 * When this bit is 0, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_PRIMATE_ENABLE \
		UINT32_C(0x100)
	/*
	 * When this bit is '1', the caller requests to disable a MPC
	 * channel with destination to the primate processor block.
	 * When this bit is 0, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_PRIMATE_DISABLE \
		UINT32_C(0x200)
	/*
	 * Minimum guaranteed bandwidth for the network partition made up
	 * of the caller physical function and all its child virtual
	 * functions. The rate is specified as a percentage of the bandwidth
	 * of the link the partition is associated with. A value of 0
	 * indicates that no minimum bandwidth is configured. The sum of the
	 * minimum bandwidths for all partitions on a link must not exceed
	 * 100%.
	 * The format of this field is defined to match min_bw, even though
	 * it does not allow all the options for min_bw at this time.
	 */
	uint32_t	partition_min_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_SFT \
		0
	/*
	 * The granularity of the value (bits or bytes). Firmware ignores
	 * this field.
	 */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_SCALE_LAST \
		HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_SCALE_BYTES
	/* Bandwidth units. Must be set to percent1_100. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in hundredths of a percent of link bandwidth. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
	/*
	 * The maximum bandwidth that may be used by the network partition
	 * made up of the caller physical function and all its child virtual
	 * functions. The rate is specified as a percentage of the bandwidth
	 * of the link the partition is associated with. A value of 0
	 * indicates that no maximum bandwidth is configured.
	 * The format of this field is defined to match max_bw, even though it
	 * does not allow all the options for max_bw at this time.
	 */
	uint32_t	partition_max_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_SFT \
		0
	/*
	 * The granularity of the value (bits or bytes). Firmware ignores
	 * this field.
	 */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_SCALE_LAST \
		HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_SCALE_BYTES
	/* Bandwidth units. Must be set to percent1_100. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in hundredths of a percent of link bandwidth. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
	/*
	 * The TPID for the function for which default VLAN
	 * is configured. If the dflt_vlan is not specified
	 * with the TPID, FW returns error. If the TPID is
	 * not specified with dflt_vlan, the default TPID of
	 * 0x8100 will be used. This field is specified in
	 * network byte order.
	 */
	uint16_t	tpid;
	/*
	 * This field can be used by the host PF to configure
	 * mtu value.
	 * The maximum transmission unit of the function.
	 * The HWRM should make sure that the mtu of
	 * the function does not exceed the mtu of the physical
	 * port that this function is associated with.
	 *
	 * In addition to configuring mtu per function, it is
	 * possible to configure mtu per transmit ring.
	 * By default, the mtu of each transmit ring associated
	 * with a function is equal to the mtu of the function.
	 * The HWRM should make sure that the mtu of each transmit
	 * ring that is assigned to a function has a valid mtu.
	 */
	uint16_t	host_mtu;
	uint8_t	unused_0[4];
	uint32_t	enables2;
	/*
	 * This bit must be '1' for the kdnet_mode field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES2_KDNET            UINT32_C(0x1)
	/*
	 * This bit must be '1' for the db_page_size field to be
	 * configured. Legacy controller core FW may silently ignore
	 * the db_page_size programming request through this command.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES2_DB_PAGE_SIZE     UINT32_C(0x2)
	/*
	 * KDNet mode for the port for this function.  If NPAR is
	 * also configured on this port, it takes precedence.  KDNet
	 * mode is ignored for a VF.
	 */
	uint8_t	port_kdnet_mode;
	/* KDNet mode is not enabled. */
	#define HWRM_FUNC_CFG_INPUT_PORT_KDNET_MODE_DISABLED UINT32_C(0x0)
	/* KDNet mode enabled. */
	#define HWRM_FUNC_CFG_INPUT_PORT_KDNET_MODE_ENABLED  UINT32_C(0x1)
	#define HWRM_FUNC_CFG_INPUT_PORT_KDNET_MODE_LAST \
		HWRM_FUNC_CFG_INPUT_PORT_KDNET_MODE_ENABLED
	/*
	 * This field can be used by the PF driver to configure the doorbell
	 * page size. L2 driver can use different pages to ring the doorbell
	 * for L2 push operation. The doorbell page size should be configured
	 * to match the native CPU page size for proper RoCE and L2 doorbell
	 * operations. This value supersedes the older method of configuring
	 * the doorbell page size by the RoCE driver using the command queue
	 * method. The default is 4K.
	 */
	uint8_t	db_page_size;
	/* DB page size is 4KB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_4KB   UINT32_C(0x0)
	/* DB page size is 8KB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_8KB   UINT32_C(0x1)
	/* DB page size is 16KB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_16KB  UINT32_C(0x2)
	/* DB page size is 32KB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_32KB  UINT32_C(0x3)
	/* DB page size is 64KB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_64KB  UINT32_C(0x4)
	/* DB page size is 128KB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_128KB UINT32_C(0x5)
	/* DB page size is 256KB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_256KB UINT32_C(0x6)
	/* DB page size is 512KB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_512KB UINT32_C(0x7)
	/* DB page size is 1MB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_1MB   UINT32_C(0x8)
	/* DB page size is 2MB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_2MB   UINT32_C(0x9)
	/* DB page size is 4MB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_4MB   UINT32_C(0xa)
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_LAST \
		HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_4MB
	uint8_t	unused_1[2];
	/* Number of Tx Key Contexts requested. */
	uint32_t	num_tx_key_ctxs;
	/* Number of Rx Key Contexts requested. */
	uint32_t	num_rx_key_ctxs;
	uint8_t	unused_2[4];
} __rte_packed;

/* hwrm_func_cfg_output (size:128b/16B) */
struct hwrm_func_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* hwrm_func_cfg_cmd_err (size:64b/8B) */
struct hwrm_func_cfg_cmd_err {
	/* command specific error codes for the cmd_err field in hwrm_err_output */
	uint8_t	code;
	/* Unknown error. */
	#define HWRM_FUNC_CFG_CMD_ERR_CODE_UNKNOWN \
		UINT32_C(0x0)
	/* The partition minimum bandwidth is out of range. */
	#define HWRM_FUNC_CFG_CMD_ERR_CODE_PARTITION_MIN_BW_RANGE \
		UINT32_C(0x1)
	/* The minimum bandwidth is more than the maximum bandwidth. */
	#define HWRM_FUNC_CFG_CMD_ERR_CODE_PARTITION_MIN_MORE_THAN_MAX \
		UINT32_C(0x2)
	/*
	 * The NIC does not support enforcement of a minimum guaranteed
	 * bandwidth for a partition.
	 */
	#define HWRM_FUNC_CFG_CMD_ERR_CODE_PARTITION_MIN_BW_UNSUPPORTED \
		UINT32_C(0x3)
	/* Partition bandwidths must be specified as a percentage. */
	#define HWRM_FUNC_CFG_CMD_ERR_CODE_PARTITION_BW_PERCENT \
		UINT32_C(0x4)
	#define HWRM_FUNC_CFG_CMD_ERR_CODE_LAST \
		HWRM_FUNC_CFG_CMD_ERR_CODE_PARTITION_BW_PERCENT
	uint8_t	unused_0[7];
} __rte_packed;

/********************
 * hwrm_func_qstats *
 ********************/


/* hwrm_func_qstats_input (size:192b/24B) */
struct hwrm_func_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 * A privileged PF can query for other function's statistics.
	 */
	uint16_t	fid;
	uint8_t	flags;
	/*
	 * This bit should be set to 1 when request is for only RoCE
	 * statistics. This will be honored only if the caller_fid is
	 * a privileged PF. In all other cases FID and caller_fid should
	 * be the same.
	 */
	#define HWRM_FUNC_QSTATS_INPUT_FLAGS_ROCE_ONLY        UINT32_C(0x1)
	/*
	 * This bit should be set to 1 when request is for the counter mask,
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_FUNC_QSTATS_INPUT_FLAGS_COUNTER_MASK     UINT32_C(0x2)
	/*
	 * This bit should be set to 1 when request is for only L2
	 * statistics. This will be honored only if the caller_fid is
	 * a privileged PF. In all other cases FID and caller_fid should
	 * be the same.
	 */
	#define HWRM_FUNC_QSTATS_INPUT_FLAGS_L2_ONLY          UINT32_C(0x4)
	uint8_t	unused_0[5];
} __rte_packed;

/* hwrm_func_qstats_output (size:1408b/176B) */
struct hwrm_func_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of transmitted unicast packets on the function. */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets on the function. */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets on the function. */
	uint64_t	tx_bcast_pkts;
	/*
	 * Number of transmitted packets that were discarded due to
	 * internal NIC resource problems.  For transmit, this
	 * can only happen if TMP is configured to allow dropping
	 * in HOL blocking conditions, which is not a normal
	 * configuration.
	 */
	uint64_t	tx_discard_pkts;
	/*
	 * Number of dropped packets on transmit path on the function.
	 * These are packets that have been marked for drop by
	 * the TE CFA block or are packets that exceeded the
	 * transmit MTU limit for the function.
	 */
	uint64_t	tx_drop_pkts;
	/* Number of transmitted bytes for unicast traffic on the function. */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic on the function. */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic on the function. */
	uint64_t	tx_bcast_bytes;
	/* Number of received unicast packets on the function. */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets on the function. */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets on the function. */
	uint64_t	rx_bcast_pkts;
	/*
	 * Number of received packets that were discarded on the function
	 * due to resource limitations.  This can happen for 3 reasons.
	 * # The BD used for the packet has a bad format.
	 * # There were no BDs available in the ring for the packet.
	 * # There were no BDs available on-chip for the packet.
	 */
	uint64_t	rx_discard_pkts;
	/*
	 * Number of dropped packets on received path on the function.
	 * These are packets that have been marked for drop by the
	 * RE CFA.
	 */
	uint64_t	rx_drop_pkts;
	/* Number of received bytes for unicast traffic on the function. */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic on the function. */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic on the function. */
	uint64_t	rx_bcast_bytes;
	/* Number of aggregated unicast packets on the function. */
	uint64_t	rx_agg_pkts;
	/* Number of aggregated unicast bytes on the function. */
	uint64_t	rx_agg_bytes;
	/* Number of aggregation events on the function. */
	uint64_t	rx_agg_events;
	/* Number of aborted aggregations on the function. */
	uint64_t	rx_agg_aborts;
	/*
	 * This field is the sequence of the statistics of a function being
	 * cleared. Firmware starts the sequence from zero. It increments
	 * the sequence number every time the statistics of the function
	 * are cleared, which can be triggered by a clear statistics request
	 * or by freeing all statistics contexts of the function. If a user
	 * is interested in knowing if the statistics have been cleared
	 * since the last query, it can keep track of this sequence number
	 * between queries.
	 */
	uint8_t	clear_seq;
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_func_qstats_ext *
 ************************/


/* hwrm_func_qstats_ext_input (size:256b/32B) */
struct hwrm_func_qstats_ext_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 * A privileged PF can query for other function's statistics.
	 */
	uint16_t	fid;
	uint8_t	flags;
	/*
	 * This bit should be set to 1 when request is for only RoCE
	 * statistics. This will be honored only if the caller_fid is
	 * a privileged PF. In all other cases FID and caller_fid should
	 * be the same.
	 */
	#define HWRM_FUNC_QSTATS_EXT_INPUT_FLAGS_ROCE_ONLY        UINT32_C(0x1)
	/*
	 * This bit should be set to 1 when request is for the counter mask
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_FUNC_QSTATS_EXT_INPUT_FLAGS_COUNTER_MASK     UINT32_C(0x2)
	uint8_t	unused_0[1];
	uint32_t	enables;
	/*
	 * This bit must be '1' for the schq_id and traffic_class fields to
	 * be configured.
	 */
	#define HWRM_FUNC_QSTATS_EXT_INPUT_ENABLES_SCHQ_ID     UINT32_C(0x1)
	/* Specifies the SCHQ for which to gather statistics */
	uint16_t	schq_id;
	/*
	 * Specifies the traffic class for which to gather statistics. Valid
	 * values are 0 through (max_configurable_queues - 1), where
	 * max_configurable_queues is in the response of HWRM_QUEUE_QPORTCFG
	 */
	uint16_t	traffic_class;
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_func_qstats_ext_output (size:1536b/192B) */
struct hwrm_func_qstats_ext_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of received unicast packets */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets */
	uint64_t	rx_bcast_pkts;
	/* Number of discarded packets on received path */
	uint64_t	rx_discard_pkts;
	/* Number of packets on receive path with error */
	uint64_t	rx_error_pkts;
	/* Number of received bytes for unicast traffic */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic */
	uint64_t	rx_bcast_bytes;
	/* Number of transmitted unicast packets */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets */
	uint64_t	tx_bcast_pkts;
	/* Number of packets on transmit path with error */
	uint64_t	tx_error_pkts;
	/* Number of discarded packets on transmit path */
	uint64_t	tx_discard_pkts;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	tx_bcast_bytes;
	/* Number of TPA eligible packets */
	uint64_t	rx_tpa_eligible_pkt;
	/* Number of TPA eligible bytes */
	uint64_t	rx_tpa_eligible_bytes;
	/* Number of TPA packets */
	uint64_t	rx_tpa_pkt;
	/* Number of TPA bytes */
	uint64_t	rx_tpa_bytes;
	/* Number of TPA errors */
	uint64_t	rx_tpa_errors;
	/* Number of TPA errors */
	uint64_t	rx_tpa_events;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_func_clr_stats *
 ***********************/


/* hwrm_func_clr_stats_input (size:192b/24B) */
struct hwrm_func_clr_stats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_func_clr_stats_output (size:128b/16B) */
struct hwrm_func_clr_stats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_func_vf_resc_free *
 **************************/


/* hwrm_func_vf_resc_free_input (size:192b/24B) */
struct hwrm_func_vf_resc_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	vf_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_func_vf_resc_free_output (size:128b/16B) */
struct hwrm_func_vf_resc_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_func_drv_rgtr *
 **********************/


/* hwrm_func_drv_rgtr_input (size:896b/112B) */
struct hwrm_func_drv_rgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the function driver is requesting
	 * all requests from its children VF drivers to be
	 * forwarded to itself.
	 * This flag can only be set by the PF driver.
	 * If a VF driver sets this flag, it should be ignored
	 * by the HWRM.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_FWD_ALL_MODE \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', the function is requesting none of
	 * the requests from its children VF drivers to be
	 * forwarded to itself.
	 * This flag can only be set by the PF driver.
	 * If a VF driver sets this flag, it should be ignored
	 * by the HWRM.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_FWD_NONE_MODE \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', then ver_maj_8b, ver_min_8b, ver_upd_8b
	 * fields shall be ignored and ver_maj, ver_min, ver_upd
	 * and ver_patch shall be used for the driver version information.
	 * When this bit is '0', then ver_maj_8b, ver_min_8b, ver_upd_8b
	 * fields shall be used for the driver version information and
	 * ver_maj, ver_min, ver_upd and ver_patch shall be ignored.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_16BIT_VER_MODE \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', the function is indicating support of
	 * 64bit flow handle.  The firmware that only supports 64bit flow
	 * handle should check this bit before allowing processing of
	 * HWRM_CFA_FLOW_XXX commands from the requesting function as firmware
	 * with 64bit flow handle support can only be compatible with drivers
	 * that support 64bit flow handle. The legacy drivers that don't support
	 * 64bit flow handle won't be able to use HWRM_CFA_FLOW_XXX commands when
	 * running with new firmware that only supports 64bit flow handle. The new
	 * firmware support 64bit flow handle returns HWRM_ERR_CODE_CMD_NOT_SUPPORTED
	 * status to the legacy driver when encounters these commands.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_FLOW_HANDLE_64BIT_MODE \
		UINT32_C(0x8)
	/*
	 * When this bit is '1', the function is indicating support of
	 * Hot Reset. The driver interface will destroy the resources,
	 * unregister the function and register again up on receiving
	 * the RESET_NOTIFY Async notification from the core firmware.
	 * The core firmware will this use flag and trigger the Hot Reset
	 * process only if all the registered driver instances are capable
	 * of this support.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_HOT_RESET_SUPPORT \
		UINT32_C(0x10)
	/*
	 * When this bit is 1, the function is indicating the support of the
	 * error recovery capability. Error recovery support will be used by
	 * firmware only if all the driver instances support error recovery
	 * process. By setting this bit, driver is indicating support for
	 * corresponding async event completion message. These will be
	 * delivered to the driver even if they did not register for it.
	 * If supported, after receiving reset notify async event with fatal
	 * flag set in event data1, then all the drivers have to tear down
	 * their resources without sending any HWRM commands to FW.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_ERROR_RECOVERY_SUPPORT \
		UINT32_C(0x20)
	/*
	 * When this bit is 1, the function is indicating the support of the
	 * Master capability. The Firmware will use this capability to select the
	 * Master function. The master function will be used to initiate
	 * designated functionality like error recovery etc If none of the
	 * registered PFs or trusted VFs indicate this support, then
	 * firmware will select the 1st registered PF as Master capable instance.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_MASTER_SUPPORT \
		UINT32_C(0x40)
	/*
	 * When this bit is 1, the function is indicating the support of the
	 * fast reset capability. Fast reset support will be used by
	 * firmware only if all the driver instances support fast reset
	 * process. By setting this bit, driver is indicating support for
	 * corresponding async event completion message. These will be
	 * delivered to the driver even if they did not register for it.
	 * If supported, after receiving reset notify async event with fast
	 * reset flag set in event data1, then all the drivers have to tear
	 * down their resources without sending any HWRM commands to FW.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_FAST_RESET_SUPPORT \
		UINT32_C(0x80)
	/*
	 * When this bit is 1, the function's driver is indicating the
	 * support of handling the vnic_rss_cfg's INVALID_PARAM error
	 * returned by firmware. Firmware returns error, if host driver
	 * configures the invalid hash_types bit combination for a given
	 * IP version.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_RSS_STRICT_HASH_TYPE_SUPPORT \
		UINT32_C(0x100)
	/*
	 * When this bit is 1, the function's driver is indicating the
	 * support of handling the NPAR 1.2 feature where the s-tag may be
	 * a value other than 0x8100 or 0x88a8.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_NPAR_1_2_SUPPORT \
		UINT32_C(0x200)
	/*
	 * When this bit is 1, the function's driver is indicating the
	 * support for asymmetric queue configuration, such that queue
	 * ids and service profiles on TX side are not the same as the
	 * corresponding queue configuration on the RX side
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_ASYM_QUEUE_CFG_SUPPORT \
		UINT32_C(0x400)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the os_type field to be
	 * configured.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_OS_TYPE \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the ver field to be
	 * configured.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_VER \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the timestamp field to be
	 * configured.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_TIMESTAMP \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the vf_req_fwd field to be
	 * configured.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_VF_REQ_FWD \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the async_event_fwd field to be
	 * configured.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_ASYNC_EVENT_FWD \
		UINT32_C(0x10)
	/* This value indicates the type of OS.  The values are based on CIM_OperatingSystem.mof file as published by the DMTF. */
	uint16_t	os_type;
	/* Unknown */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_UNKNOWN   UINT32_C(0x0)
	/* Other OS not listed below. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_OTHER     UINT32_C(0x1)
	/* MSDOS OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_MSDOS     UINT32_C(0xe)
	/* Windows OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_WINDOWS   UINT32_C(0x12)
	/* Solaris OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_SOLARIS   UINT32_C(0x1d)
	/* Linux OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_LINUX     UINT32_C(0x24)
	/* FreeBSD OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_FREEBSD   UINT32_C(0x2a)
	/* VMware ESXi OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_ESXI      UINT32_C(0x68)
	/* Microsoft Windows 8 64-bit OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_WIN864    UINT32_C(0x73)
	/* Microsoft Windows Server 2012 R2 OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_WIN2012R2 UINT32_C(0x74)
	/* UEFI driver. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_UEFI      UINT32_C(0x8000)
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_LAST \
		HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_UEFI
	/* This is the 8bit major version of the driver. */
	uint8_t	ver_maj_8b;
	/* This is the 8bit minor version of the driver. */
	uint8_t	ver_min_8b;
	/* This is the 8bit update version of the driver. */
	uint8_t	ver_upd_8b;
	uint8_t	unused_0[3];
	/*
	 * This is a 32-bit timestamp provided by the driver for
	 * keep alive.
	 * The timestamp is in multiples of 1ms.
	 */
	uint32_t	timestamp;
	uint8_t	unused_1[4];
	/*
	 * This is a 256-bit bit mask provided by the PF driver for
	 * letting the HWRM know what commands issued by the VF driver
	 * to the HWRM should be forwarded to the PF driver.
	 * Nth bit refers to the Nth req_type.
	 *
	 * Setting Nth bit to 1 indicates that requests from the
	 * VF driver with req_type equal to N shall be forwarded to
	 * the parent PF driver.
	 *
	 * This field is not valid for the VF driver.
	 */
	uint32_t	vf_req_fwd[8];
	/*
	 * This is a 256-bit bit mask provided by the function driver
	 * (PF or VF driver) to indicate the list of asynchronous event
	 * completions to be forwarded.
	 *
	 * Nth bit refers to the Nth event_id.
	 *
	 * Setting Nth bit to 1 by the function driver shall result in
	 * the HWRM forwarding asynchronous event completion with
	 * event_id equal to N.
	 *
	 * If all bits are set to 0 (value of 0), then the HWRM shall
	 * not forward any asynchronous event completion to this
	 * function driver.
	 */
	uint32_t	async_event_fwd[8];
	/* This is the 16bit major version of the driver. */
	uint16_t	ver_maj;
	/* This is the 16bit minor version of the driver. */
	uint16_t	ver_min;
	/* This is the 16bit update version of the driver. */
	uint16_t	ver_upd;
	/* This is the 16bit patch version of the driver. */
	uint16_t	ver_patch;
} __rte_packed;

/* hwrm_func_drv_rgtr_output (size:128b/16B) */
struct hwrm_func_drv_rgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When this bit is '1', it indicates that the
	 * HWRM_FUNC_DRV_IF_CHANGE call is supported.
	 */
	#define HWRM_FUNC_DRV_RGTR_OUTPUT_FLAGS_IF_CHANGE_SUPPORTED \
		UINT32_C(0x1)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_func_drv_unrgtr *
 ************************/


/* hwrm_func_drv_unrgtr_input (size:192b/24B) */
struct hwrm_func_drv_unrgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the function driver is notifying
	 * the HWRM to prepare for the shutdown.
	 */
	#define HWRM_FUNC_DRV_UNRGTR_INPUT_FLAGS_PREPARE_FOR_SHUTDOWN \
		UINT32_C(0x1)
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_func_drv_unrgtr_output (size:128b/16B) */
struct hwrm_func_drv_unrgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_func_buf_rgtr *
 **********************/


/* hwrm_func_buf_rgtr_input (size:1024b/128B) */
struct hwrm_func_buf_rgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vf_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_BUF_RGTR_INPUT_ENABLES_VF_ID            UINT32_C(0x1)
	/*
	 * This bit must be '1' for the err_buf_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_BUF_RGTR_INPUT_ENABLES_ERR_BUF_ADDR     UINT32_C(0x2)
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	vf_id;
	/*
	 * This field represents the number of pages used for request
	 * buffer(s).
	 */
	uint16_t	req_buf_num_pages;
	/*
	 * This field represents the page size used for request
	 * buffer(s).
	 */
	uint16_t	req_buf_page_size;
	/* 16 bytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_16B UINT32_C(0x4)
	/* 4 Kbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_4K  UINT32_C(0xc)
	/* 8 Kbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_8K  UINT32_C(0xd)
	/* 64 Kbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_64K UINT32_C(0x10)
	/* 2 Mbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_2M  UINT32_C(0x15)
	/* 4 Mbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_4M  UINT32_C(0x16)
	/* 1 Gbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_1G  UINT32_C(0x1e)
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_LAST \
		HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_1G
	/* The length of the request buffer per VF in bytes. */
	uint16_t	req_buf_len;
	/* The length of the response buffer in bytes. */
	uint16_t	resp_buf_len;
	uint8_t	unused_0[2];
	/* This field represents the page address of page #0. */
	uint64_t	req_buf_page_addr0;
	/* This field represents the page address of page #1. */
	uint64_t	req_buf_page_addr1;
	/* This field represents the page address of page #2. */
	uint64_t	req_buf_page_addr2;
	/* This field represents the page address of page #3. */
	uint64_t	req_buf_page_addr3;
	/* This field represents the page address of page #4. */
	uint64_t	req_buf_page_addr4;
	/* This field represents the page address of page #5. */
	uint64_t	req_buf_page_addr5;
	/* This field represents the page address of page #6. */
	uint64_t	req_buf_page_addr6;
	/* This field represents the page address of page #7. */
	uint64_t	req_buf_page_addr7;
	/* This field represents the page address of page #8. */
	uint64_t	req_buf_page_addr8;
	/* This field represents the page address of page #9. */
	uint64_t	req_buf_page_addr9;
	/*
	 * This field is used to receive the error reporting from
	 * the chipset. Only applicable for PFs.
	 */
	uint64_t	error_buf_addr;
	/*
	 * This field is used to receive the response forwarded by the
	 * HWRM.
	 */
	uint64_t	resp_buf_addr;
} __rte_packed;

/* hwrm_func_buf_rgtr_output (size:128b/16B) */
struct hwrm_func_buf_rgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_func_buf_unrgtr *
 ************************/


/* hwrm_func_buf_unrgtr_input (size:192b/24B) */
struct hwrm_func_buf_unrgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vf_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_BUF_UNRGTR_INPUT_ENABLES_VF_ID     UINT32_C(0x1)
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	vf_id;
	uint8_t	unused_0[2];
} __rte_packed;

/* hwrm_func_buf_unrgtr_output (size:128b/16B) */
struct hwrm_func_buf_unrgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_func_drv_qver *
 **********************/


/* hwrm_func_drv_qver_input (size:192b/24B) */
struct hwrm_func_drv_qver_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Reserved for future use. */
	uint32_t	reserved;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[2];
} __rte_packed;

/* hwrm_func_drv_qver_output (size:256b/32B) */
struct hwrm_func_drv_qver_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value indicates the type of OS.  The values are based on CIM_OperatingSystem.mof file as published by the DMTF. */
	uint16_t	os_type;
	/* Unknown */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_UNKNOWN   UINT32_C(0x0)
	/* Other OS not listed below. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_OTHER     UINT32_C(0x1)
	/* MSDOS OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_MSDOS     UINT32_C(0xe)
	/* Windows OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_WINDOWS   UINT32_C(0x12)
	/* Solaris OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_SOLARIS   UINT32_C(0x1d)
	/* Linux OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_LINUX     UINT32_C(0x24)
	/* FreeBSD OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_FREEBSD   UINT32_C(0x2a)
	/* VMware ESXi OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_ESXI      UINT32_C(0x68)
	/* Microsoft Windows 8 64-bit OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_WIN864    UINT32_C(0x73)
	/* Microsoft Windows Server 2012 R2 OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_WIN2012R2 UINT32_C(0x74)
	/* UEFI driver. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_UEFI      UINT32_C(0x8000)
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_LAST \
		HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_UEFI
	/* This is the 8bit major version of the driver. */
	uint8_t	ver_maj_8b;
	/* This is the 8bit minor version of the driver. */
	uint8_t	ver_min_8b;
	/* This is the 8bit update version of the driver. */
	uint8_t	ver_upd_8b;
	uint8_t	unused_0[3];
	/* This is the 16bit major version of the driver. */
	uint16_t	ver_maj;
	/* This is the 16bit minor version of the driver. */
	uint16_t	ver_min;
	/* This is the 16bit update version of the driver. */
	uint16_t	ver_upd;
	/* This is the 16bit patch version of the driver. */
	uint16_t	ver_patch;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/****************************
 * hwrm_func_resource_qcaps *
 ****************************/


/* hwrm_func_resource_qcaps_input (size:192b/24B) */
struct hwrm_func_resource_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_func_resource_qcaps_output (size:576b/72B) */
struct hwrm_func_resource_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Maximum guaranteed number of VFs supported by PF. Not applicable for VFs. */
	uint16_t	max_vfs;
	/* Maximum guaranteed number of MSI-X vectors supported by function */
	uint16_t	max_msix;
	/* Hint of strategy to be used by PF driver to reserve resources for its VF */
	uint16_t	vf_reservation_strategy;
	/* The PF driver should evenly divide its remaining resources among all VFs. */
	#define HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_VF_RESERVATION_STRATEGY_MAXIMAL \
		UINT32_C(0x0)
	/* The PF driver should only reserve minimal resources for each VF. */
	#define HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_VF_RESERVATION_STRATEGY_MINIMAL \
		UINT32_C(0x1)
	/*
	 * The PF driver should not reserve any resources for each VF until
	 * the VF interface is brought up.
	 */
	#define HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_VF_RESERVATION_STRATEGY_MINIMAL_STATIC \
		UINT32_C(0x2)
	#define HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_VF_RESERVATION_STRATEGY_LAST \
		HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_VF_RESERVATION_STRATEGY_MINIMAL_STATIC
	/* Minimum guaranteed number of RSS/COS contexts */
	uint16_t	min_rsscos_ctx;
	/* Maximum non-guaranteed number of RSS/COS contexts */
	uint16_t	max_rsscos_ctx;
	/* Minimum guaranteed number of completion rings */
	uint16_t	min_cmpl_rings;
	/* Maximum non-guaranteed number of completion rings */
	uint16_t	max_cmpl_rings;
	/* Minimum guaranteed number of transmit rings */
	uint16_t	min_tx_rings;
	/* Maximum non-guaranteed number of transmit rings */
	uint16_t	max_tx_rings;
	/* Minimum guaranteed number of receive rings */
	uint16_t	min_rx_rings;
	/* Maximum non-guaranteed number of receive rings */
	uint16_t	max_rx_rings;
	/* Minimum guaranteed number of L2 contexts */
	uint16_t	min_l2_ctxs;
	/* Maximum non-guaranteed number of L2 contexts */
	uint16_t	max_l2_ctxs;
	/* Minimum guaranteed number of VNICs */
	uint16_t	min_vnics;
	/* Maximum non-guaranteed number of VNICs */
	uint16_t	max_vnics;
	/* Minimum guaranteed number of statistic contexts */
	uint16_t	min_stat_ctx;
	/* Maximum non-guaranteed number of statistic contexts */
	uint16_t	max_stat_ctx;
	/* Minimum guaranteed number of ring groups */
	uint16_t	min_hw_ring_grps;
	/* Maximum non-guaranteed number of ring groups */
	uint16_t	max_hw_ring_grps;
	/*
	 * Maximum number of inputs into the transmit scheduler for this function.
	 * The number of TX rings assigned to the function cannot exceed this value.
	 */
	uint16_t	max_tx_scheduler_inputs;
	uint16_t	flags;
	/*
	 * When this bit is '1', it indicates that VF_RESOURCE_CFG supports
	 * feature to reserve all minimum resources when minimum >= 1, otherwise
	 * returns an error.
	 */
	#define HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_FLAGS_MIN_GUARANTEED \
		UINT32_C(0x1)
	uint8_t	unused_0[2];
	/* Minimum guaranteed number of Tx Key Contexts */
	uint32_t	min_tx_key_ctxs;
	/* Maximum non-guaranteed number of Tx Key Contexts */
	uint32_t	max_tx_key_ctxs;
	/* Minimum guaranteed number of Rx Key Contexts */
	uint32_t	min_rx_key_ctxs;
	/* Maximum non-guaranteed number of Rx Key Contexts */
	uint32_t	max_rx_key_ctxs;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************************
 * hwrm_func_vf_resource_cfg *
 *****************************/


/* hwrm_func_vf_resource_cfg_input (size:576b/72B) */
struct hwrm_func_vf_resource_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* VF ID that is being configured by PF */
	uint16_t	vf_id;
	/* Maximum guaranteed number of MSI-X vectors for the function */
	uint16_t	max_msix;
	/* Minimum guaranteed number of RSS/COS contexts */
	uint16_t	min_rsscos_ctx;
	/* Maximum non-guaranteed number of RSS/COS contexts */
	uint16_t	max_rsscos_ctx;
	/* Minimum guaranteed number of completion rings */
	uint16_t	min_cmpl_rings;
	/* Maximum non-guaranteed number of completion rings */
	uint16_t	max_cmpl_rings;
	/* Minimum guaranteed number of transmit rings */
	uint16_t	min_tx_rings;
	/* Maximum non-guaranteed number of transmit rings */
	uint16_t	max_tx_rings;
	/* Minimum guaranteed number of receive rings */
	uint16_t	min_rx_rings;
	/* Maximum non-guaranteed number of receive rings */
	uint16_t	max_rx_rings;
	/* Minimum guaranteed number of L2 contexts */
	uint16_t	min_l2_ctxs;
	/* Maximum non-guaranteed number of L2 contexts */
	uint16_t	max_l2_ctxs;
	/* Minimum guaranteed number of VNICs */
	uint16_t	min_vnics;
	/* Maximum non-guaranteed number of VNICs */
	uint16_t	max_vnics;
	/* Minimum guaranteed number of statistic contexts */
	uint16_t	min_stat_ctx;
	/* Maximum non-guaranteed number of statistic contexts */
	uint16_t	max_stat_ctx;
	/* Minimum guaranteed number of ring groups */
	uint16_t	min_hw_ring_grps;
	/* Maximum non-guaranteed number of ring groups */
	uint16_t	max_hw_ring_grps;
	uint16_t	flags;
	/*
	 * If this bit is set, all minimum resources requested should be
	 * reserved if minimum >= 1, otherwise return error. In case of
	 * error, keep all existing reservations before the call.
	 */
	#define HWRM_FUNC_VF_RESOURCE_CFG_INPUT_FLAGS_MIN_GUARANTEED \
		UINT32_C(0x1)
	uint8_t	unused_0[2];
	/* Minimum guaranteed number of Tx Key Contexts */
	uint32_t	min_tx_key_ctxs;
	/* Maximum non-guaranteed number of Tx Key Contexts */
	uint32_t	max_tx_key_ctxs;
	/* Minimum guaranteed number of Rx Key Contexts */
	uint32_t	min_rx_key_ctxs;
	/* Maximum non-guaranteed number of Rx Key Contexts */
	uint32_t	max_rx_key_ctxs;
} __rte_packed;

/* hwrm_func_vf_resource_cfg_output (size:320b/40B) */
struct hwrm_func_vf_resource_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Reserved number of RSS/COS contexts */
	uint16_t	reserved_rsscos_ctx;
	/* Reserved number of completion rings */
	uint16_t	reserved_cmpl_rings;
	/* Reserved number of transmit rings */
	uint16_t	reserved_tx_rings;
	/* Reserved number of receive rings */
	uint16_t	reserved_rx_rings;
	/* Reserved number of L2 contexts */
	uint16_t	reserved_l2_ctxs;
	/* Reserved number of VNICs */
	uint16_t	reserved_vnics;
	/* Reserved number of statistic contexts */
	uint16_t	reserved_stat_ctx;
	/* Reserved number of ring groups */
	uint16_t	reserved_hw_ring_grps;
	/* Actual number of Tx Key Contexts reserved */
	uint32_t	reserved_tx_key_ctxs;
	/* Actual number of Rx Key Contexts reserved */
	uint32_t	reserved_rx_key_ctxs;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************************
 * hwrm_func_backing_store_qcaps *
 *********************************/


/* hwrm_func_backing_store_qcaps_input (size:128b/16B) */
struct hwrm_func_backing_store_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_func_backing_store_qcaps_output (size:832b/104B) */
struct hwrm_func_backing_store_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Maximum number of QP context entries supported for this function. */
	uint32_t	qp_max_entries;
	/*
	 * Minimum number of QP context entries that are needed to be reserved
	 * for QP1 for the PF and its VFs. PF drivers must allocate at least
	 * this many QP context entries, even if RoCE will not be used.
	 */
	uint16_t	qp_min_qp1_entries;
	/*
	 * Maximum number of QP context entries that can be used for L2 and
	 * mid-path.
	 */
	uint16_t	qp_max_l2_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	qp_entry_size;
	/* Maximum number of SRQ context entries that can be used for L2. */
	uint16_t	srq_max_l2_entries;
	/* Maximum number of SRQ context entries supported for this function. */
	uint32_t	srq_max_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	srq_entry_size;
	/* Maximum number of CQ context entries that can be used for L2. */
	uint16_t	cq_max_l2_entries;
	/* Maximum number of CQ context entries supported for this function. */
	uint32_t	cq_max_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	cq_entry_size;
	/* Maximum number of VNIC context entries supported for this function. */
	uint16_t	vnic_max_vnic_entries;
	/* Maximum number of Ring table context entries supported for this function. */
	uint16_t	vnic_max_ring_table_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	vnic_entry_size;
	/* Maximum number of statistic context entries supported for this function. */
	uint32_t	stat_max_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	stat_entry_size;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	tqm_entry_size;
	/* Minimum number of TQM context entries required per ring. */
	uint32_t	tqm_min_entries_per_ring;
	/*
	 * Maximum number of TQM context entries supported per ring. This is
	 * actually a recommended TQM queue size based on worst case usage of
	 * the TQM queue.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * TQM slowpath rings should be sized as follows:
	 *
	 * num_entries = num_vnics + num_l2_tx_rings + 2 * num_roce_qps + tqm_min_size
	 *
	 * Where:
	 *   num_vnics is the number of VNICs allocated in the VNIC backing store
	 *   num_l2_tx_rings is the number of L2 rings in the QP backing store
	 *   num_roce_qps is the number of RoCE QPs in the QP backing store
	 *   tqm_min_size is tqm_min_entries_per_ring reported by
	 *     HWRM_FUNC_BACKING_STORE_QCAPS
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_max_entries_per_ring;
	/*
	 * Maximum number of MR plus AV context entries supported for this
	 * function.
	 */
	uint32_t	mrav_max_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	mrav_entry_size;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	tim_entry_size;
	/* Maximum number of Timer context entries supported for this function. */
	uint32_t	tim_max_entries;
	/*
	 * When this field is zero, the 32b `mrav_num_entries` field in the
	 * `backing_store_cfg` and `backing_store_qcfg` commands represents
	 * the total number of MR plus AV entries allowed in the MR/AV backing
	 * store PBL.
	 *
	 * When this field is non-zero, the 32b `mrav_num_entries` field in
	 * the `backing_store_cfg` and `backing_store_qcfg` commands is
	 * logically divided into two 16b fields. Bits `[31:16]` represents
	 * the `mr_num_entries` and bits `[15:0]` represents `av_num_entries`.
	 * Both of these values are represented in a unit granularity
	 * specified by this field. For example, if this field is 16 and
	 * `mrav_num_entries` is `0x02000100`, then the number of MR entries
	 * is 8192 and the number of AV entries is 4096.
	 */
	uint16_t	mrav_num_entries_units;
	/*
	 * The number of entries specified for any TQM ring must be a
	 * multiple of this value to prevent any resource allocation
	 * limitations.
	 */
	uint8_t	tqm_entries_multiple;
	/*
	 * Initializer to be used by drivers
	 * to initialize context memory to ensure
	 * context subsystem flags an error for an attack
	 * before the first time context load.
	 */
	uint8_t	ctx_kind_initializer;
	/*
	 * Specifies which context kinds need to be initialized with the
	 * ctx_kind_initializer.
	 */
	uint16_t	ctx_init_mask;
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_QP \
		UINT32_C(0x1)
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_SRQ \
		UINT32_C(0x2)
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_CQ \
		UINT32_C(0x4)
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_VNIC \
		UINT32_C(0x8)
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_STAT \
		UINT32_C(0x10)
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_MRAV \
		UINT32_C(0x20)
	/*
	 * If this bit is '1' then the Tx KTLS context type should be
	 * initialized with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_TKC \
		UINT32_C(0x40)
	/*
	 * If this bit is '1' then the Rx KTLS context type should be
	 * initialized with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_RKC \
		UINT32_C(0x80)
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	qp_init_offset;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	srq_init_offset;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	cq_init_offset;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	vnic_init_offset;
	/*
	 * Count of TQM fastpath rings to be used for allocating backing store.
	 * Backing store configuration must be specified for each TQM ring from
	 * this count in `backing_store_cfg`.
	 * Only first 8 TQM FP rings will be advertised with this field.
	 */
	uint8_t	tqm_fp_rings_count;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	stat_init_offset;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	mrav_init_offset;
	/*
	 * Count of TQM extended fastpath rings to be used for allocating
	 * backing store beyond 8 rings(rings 9,10,11)
	 * Backing store configuration must be specified for each TQM ring from
	 * this count in `backing_store_cfg`.
	 */
	uint8_t	tqm_fp_rings_count_ext;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for Tx
	 * KTLS context type.
	 */
	uint8_t	tkc_init_offset;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for Rx
	 * KTLS context type.
	 */
	uint8_t	rkc_init_offset;
	/* Tx KTLS context entry size in bytes. */
	uint16_t	tkc_entry_size;
	/* Rx KTLS context entry size in bytes. */
	uint16_t	rkc_entry_size;
	/*
	 * Maximum number of Tx KTLS context entries supported for this
	 * function.
	 */
	uint32_t	tkc_max_entries;
	/*
	 * Maximum number of Rx KTLS context entries supported for this
	 * function.
	 */
	uint32_t	rkc_max_entries;
	/*
	 * Additional number of RoCE QP context entries required for this
	 * function to support fast QP destroy feature.
	 */
	uint16_t	fast_qpmd_qp_num_entries;
	/* Reserved for future. */
	uint8_t	rsvd1[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* tqm_fp_ring_cfg (size:128b/16B) */
struct tqm_fp_ring_cfg {
	/* TQM ring page size and level. */
	uint8_t	tqm_ring_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_MASK \
		UINT32_C(0xf)
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_LVL_2 \
		UINT32_C(0x2)
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_LAST \
		TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_SFT   4
	/* 4KB. */
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_LAST \
		TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_1G
	uint8_t	unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring_page_dir;
} __rte_packed;

/*******************************
 * hwrm_func_backing_store_cfg *
 *******************************/


/* hwrm_func_backing_store_cfg_input (size:2688b/336B) */
struct hwrm_func_backing_store_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When set, the firmware only uses on-chip resources and does not
	 * expect any backing store to be provided by the host driver. This
	 * mode provides minimal L2 functionality (e.g. limited L2 resources,
	 * no RoCE).
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_FLAGS_PREBOOT_MODE \
		UINT32_C(0x1)
	/*
	 * When set, the 32b `mrav_num_entries` field is logically divided
	 * into two 16b fields, `mr_num_entries` and `av_num_entries`.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_FLAGS_MRAV_RESERVATION_SPLIT \
		UINT32_C(0x2)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the qp fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_QP \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the srq fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_SRQ \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the cq fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_CQ \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the vnic fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_VNIC \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the stat fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_STAT \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the tqm_sp fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_SP \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the tqm_ring0 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING0 \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the tqm_ring1 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING1 \
		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the tqm_ring2 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING2 \
		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the tqm_ring3 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING3 \
		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the tqm_ring4 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING4 \
		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the tqm_ring5 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING5 \
		UINT32_C(0x800)
	/*
	 * This bit must be '1' for the tqm_ring6 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING6 \
		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the tqm_ring7 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING7 \
		UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the mrav fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_MRAV \
		UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the tim fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TIM \
		UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the tqm_ring8 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING8 \
		UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the tqm_ring9 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING9 \
		UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the tqm_ring10 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING10 \
		UINT32_C(0x40000)
	/*
	 * This bit must be '1' for the Tx KTLS context
	 * fields to be configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TKC \
		UINT32_C(0x80000)
	/*
	 * This bit must be '1' for the Rx KTLS context
	 * fields to be configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_RKC \
		UINT32_C(0x100000)
	/* QPC page size and level. */
	uint8_t	qpc_pg_size_qpc_lvl;
	/* QPC PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_LVL_2
	/* QPC page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_1G
	/* SRQ page size and level. */
	uint8_t	srq_pg_size_srq_lvl;
	/* SRQ PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_LVL_2
	/* SRQ page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_1G
	/* CQ page size and level. */
	uint8_t	cq_pg_size_cq_lvl;
	/* CQ PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_LVL_2
	/* CQ page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_1G
	/* VNIC page size and level. */
	uint8_t	vnic_pg_size_vnic_lvl;
	/* VNIC PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_LVL_2
	/* VNIC page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_1G
	/* Stat page size and level. */
	uint8_t	stat_pg_size_stat_lvl;
	/* Stat PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_LVL_2
	/* Stat page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_1G
	/* TQM slow path page size and level. */
	uint8_t	tqm_sp_pg_size_tqm_sp_lvl;
	/* TQM slow path PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_LVL_2
	/* TQM slow path page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_1G
	/* TQM ring 0 page size and level. */
	uint8_t	tqm_ring0_pg_size_tqm_ring0_lvl;
	/* TQM ring 0 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_LVL_2
	/* TQM ring 0 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_1G
	/* TQM ring 1 page size and level. */
	uint8_t	tqm_ring1_pg_size_tqm_ring1_lvl;
	/* TQM ring 1 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_LVL_2
	/* TQM ring 1 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_1G
	/* TQM ring 2 page size and level. */
	uint8_t	tqm_ring2_pg_size_tqm_ring2_lvl;
	/* TQM ring 2 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_LVL_2
	/* TQM ring 2 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_1G
	/* TQM ring 3 page size and level. */
	uint8_t	tqm_ring3_pg_size_tqm_ring3_lvl;
	/* TQM ring 3 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_LVL_2
	/* TQM ring 3 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_1G
	/* TQM ring 4 page size and level. */
	uint8_t	tqm_ring4_pg_size_tqm_ring4_lvl;
	/* TQM ring 4 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_LVL_2
	/* TQM ring 4 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_1G
	/* TQM ring 5 page size and level. */
	uint8_t	tqm_ring5_pg_size_tqm_ring5_lvl;
	/* TQM ring 5 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_LVL_2
	/* TQM ring 5 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_1G
	/* TQM ring 6 page size and level. */
	uint8_t	tqm_ring6_pg_size_tqm_ring6_lvl;
	/* TQM ring 6 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_LVL_2
	/* TQM ring 6 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_1G
	/* TQM ring 7 page size and level. */
	uint8_t	tqm_ring7_pg_size_tqm_ring7_lvl;
	/* TQM ring 7 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_LVL_2
	/* TQM ring 7 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_1G
	/* MR/AV page size and level. */
	uint8_t	mrav_pg_size_mrav_lvl;
	/* MR/AV PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_LVL_2
	/* MR/AV page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_1G
	/* Timer page size and level. */
	uint8_t	tim_pg_size_tim_lvl;
	/* Timer PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_LVL_2
	/* Timer page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_1G
	/* QP page directory. */
	uint64_t	qpc_page_dir;
	/* SRQ page directory. */
	uint64_t	srq_page_dir;
	/* CQ page directory. */
	uint64_t	cq_page_dir;
	/* VNIC page directory. */
	uint64_t	vnic_page_dir;
	/* Stat page directory. */
	uint64_t	stat_page_dir;
	/* TQM slowpath page directory. */
	uint64_t	tqm_sp_page_dir;
	/* TQM ring 0 page directory. */
	uint64_t	tqm_ring0_page_dir;
	/* TQM ring 1 page directory. */
	uint64_t	tqm_ring1_page_dir;
	/* TQM ring 2 page directory. */
	uint64_t	tqm_ring2_page_dir;
	/* TQM ring 3 page directory. */
	uint64_t	tqm_ring3_page_dir;
	/* TQM ring 4 page directory. */
	uint64_t	tqm_ring4_page_dir;
	/* TQM ring 5 page directory. */
	uint64_t	tqm_ring5_page_dir;
	/* TQM ring 6 page directory. */
	uint64_t	tqm_ring6_page_dir;
	/* TQM ring 7 page directory. */
	uint64_t	tqm_ring7_page_dir;
	/* MR/AV page directory. */
	uint64_t	mrav_page_dir;
	/* Timer page directory. */
	uint64_t	tim_page_dir;
	/* Number of QPs. */
	uint32_t	qp_num_entries;
	/* Number of SRQs. */
	uint32_t	srq_num_entries;
	/* Number of CQs. */
	uint32_t	cq_num_entries;
	/* Number of Stats. */
	uint32_t	stat_num_entries;
	/*
	 * Number of TQM slowpath entries.
	 *
	 * TQM slowpath rings should be sized as follows:
	 *
	 * num_entries = num_vnics + num_l2_tx_rings + 2 * num_roce_qps + tqm_min_size
	 *
	 * Where:
	 *   num_vnics is the number of VNICs allocated in the VNIC backing store
	 *   num_l2_tx_rings is the number of L2 rings in the QP backing store
	 *   num_roce_qps is the number of RoCE QPs in the QP backing store
	 *   tqm_min_size is tqm_min_entries_per_ring reported by
	 *     HWRM_FUNC_BACKING_STORE_QCAPS
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_sp_num_entries;
	/*
	 * Number of TQM ring 0 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring0_num_entries;
	/*
	 * Number of TQM ring 1 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring1_num_entries;
	/*
	 * Number of TQM ring 2 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring2_num_entries;
	/*
	 * Number of TQM ring 3 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring3_num_entries;
	/*
	 * Number of TQM ring 4 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring4_num_entries;
	/*
	 * Number of TQM ring 5 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring5_num_entries;
	/*
	 * Number of TQM ring 6 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring6_num_entries;
	/*
	 * Number of TQM ring 7 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring7_num_entries;
	/*
	 * If the MR/AV split reservation flag is not set, then this field
	 * represents the total number of MR plus AV entries. For versions
	 * of firmware that support the split reservation, when it is not
	 * specified half of the entries will be reserved for MRs and the
	 * other half for AVs.
	 *
	 * If the MR/AV split reservation flag is set, then this
	 * field is logically divided into two 16b fields. Bits `[31:16]`
	 * represents the `mr_num_entries` and bits `[15:0]` represents
	 * `av_num_entries`. The granularity of these values is defined by
	 * the `mrav_num_entries_unit` field returned by the
	 * `backing_store_qcaps` command.
	 */
	uint32_t	mrav_num_entries;
	/* Number of Timer entries. */
	uint32_t	tim_num_entries;
	/* Number of entries to reserve for QP1 */
	uint16_t	qp_num_qp1_entries;
	/* Number of entries to reserve for L2 */
	uint16_t	qp_num_l2_entries;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	qp_entry_size;
	/* Number of entries to reserve for L2 */
	uint16_t	srq_num_l2_entries;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	srq_entry_size;
	/* Number of entries to reserve for L2 */
	uint16_t	cq_num_l2_entries;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	cq_entry_size;
	/* Number of entries to reserve for VNIC entries */
	uint16_t	vnic_num_vnic_entries;
	/* Number of entries to reserve for Ring table entries */
	uint16_t	vnic_num_ring_table_entries;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	vnic_entry_size;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	stat_entry_size;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	tqm_entry_size;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	mrav_entry_size;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	tim_entry_size;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring8_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_SFT \
		0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_SFT \
		4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring8_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring8_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring8_page_dir;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring9_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_SFT \
		0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_SFT \
		4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring9_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring9_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring9_page_dir;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring10_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_SFT \
		0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_SFT \
		4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring10_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring10_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring10_page_dir;
	/* Number of Tx KTLS context entries allocated. */
	uint32_t	tkc_num_entries;
	/* Number of Rx KTLS context entries allocated. */
	uint32_t	rkc_num_entries;
	/* Tx KTLS context page directory. */
	uint64_t	tkc_page_dir;
	/* Rx KTLS context page directory. */
	uint64_t	rkc_page_dir;
	/* Number of bytes allocated for each Tx KTLS context entry. */
	uint16_t	tkc_entry_size;
	/* Number of bytes allocated for each Rx KTLS context entry. */
	uint16_t	rkc_entry_size;
	/* Tx KTLS context page size and level. */
	uint8_t	tkc_pg_size_tkc_lvl;
	/* Tx KTLS context PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_LVL_2
	/* Tx KTLS context page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_1G
	/* Rx KTLS context page size and level. */
	uint8_t	rkc_pg_size_rkc_lvl;
	/* Rx KTLS context PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_LVL_2
	/* Rx KTLS context page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_1G
	/* Reserved for future. */
	uint8_t	rsvd[2];
} __rte_packed;

/* hwrm_func_backing_store_cfg_output (size:128b/16B) */
struct hwrm_func_backing_store_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/********************************
 * hwrm_func_backing_store_qcfg *
 ********************************/


/* hwrm_func_backing_store_qcfg_input (size:128b/16B) */
struct hwrm_func_backing_store_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_func_backing_store_qcfg_output (size:2496b/312B) */
struct hwrm_func_backing_store_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When set, the firmware only uses on-chip resources and does not
	 * expect any backing store to be provided by the host driver. This
	 * mode provides minimal L2 functionality (e.g. limited L2 resources,
	 * no RoCE).
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_FLAGS_PREBOOT_MODE \
		UINT32_C(0x1)
	/*
	 * When set, the 32b `mrav_num_entries` field is logically divided
	 * into two 16b fields, `mr_num_entries` and `av_num_entries`.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_FLAGS_MRAV_RESERVATION_SPLIT \
		UINT32_C(0x2)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the qp fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_QP \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the srq fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_SRQ \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the cq fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_CQ \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the vnic fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_VNIC \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the stat fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_STAT \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the tqm_sp fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_SP \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the tqm_ring0 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING0 \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the tqm_ring1 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING1 \
		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the tqm_ring2 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING2 \
		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the tqm_ring3 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING3 \
		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the tqm_ring4 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING4 \
		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the tqm_ring5 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING5 \
		UINT32_C(0x800)
	/*
	 * This bit must be '1' for the tqm_ring6 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING6 \
		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the tqm_ring7 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING7 \
		UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the mrav fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_MRAV \
		UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the tim fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TIM \
		UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the tqm_ring8 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING8 \
		UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the tqm_ring9 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING9 \
		UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the tqm_ring10 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING10 \
		UINT32_C(0x40000)
	/*
	 * This bit must be '1' for the Tx KTLS context
	 * fields to be configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TKC \
		UINT32_C(0x80000)
	/*
	 * This bit must be '1' for the Rx KTLS context
	 * fields to be configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_RKC \
		UINT32_C(0x100000)
	/* QPC page size and level. */
	uint8_t	qpc_pg_size_qpc_lvl;
	/* QPC PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_LVL_2
	/* QPC page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_1G
	/* SRQ page size and level. */
	uint8_t	srq_pg_size_srq_lvl;
	/* SRQ PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_LVL_2
	/* SRQ page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_1G
	/* CQ page size and level. */
	uint8_t	cq_pg_size_cq_lvl;
	/* CQ PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_LVL_2
	/* CQ page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_1G
	/* VNIC page size and level. */
	uint8_t	vnic_pg_size_vnic_lvl;
	/* VNIC PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_LVL_2
	/* VNIC page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_1G
	/* Stat page size and level. */
	uint8_t	stat_pg_size_stat_lvl;
	/* Stat PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_LVL_2
	/* Stat page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_1G
	/* TQM slow path page size and level. */
	uint8_t	tqm_sp_pg_size_tqm_sp_lvl;
	/* TQM slow path PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_LVL_2
	/* TQM slow path page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_1G
	/* TQM ring 0 page size and level. */
	uint8_t	tqm_ring0_pg_size_tqm_ring0_lvl;
	/* TQM ring 0 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_LVL_2
	/* TQM ring 0 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_1G
	/* TQM ring 1 page size and level. */
	uint8_t	tqm_ring1_pg_size_tqm_ring1_lvl;
	/* TQM ring 1 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_LVL_2
	/* TQM ring 1 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_1G
	/* TQM ring 2 page size and level. */
	uint8_t	tqm_ring2_pg_size_tqm_ring2_lvl;
	/* TQM ring 2 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_LVL_2
	/* TQM ring 2 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_1G
	/* TQM ring 3 page size and level. */
	uint8_t	tqm_ring3_pg_size_tqm_ring3_lvl;
	/* TQM ring 3 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_LVL_2
	/* TQM ring 3 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_1G
	/* TQM ring 4 page size and level. */
	uint8_t	tqm_ring4_pg_size_tqm_ring4_lvl;
	/* TQM ring 4 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_LVL_2
	/* TQM ring 4 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_1G
	/* TQM ring 5 page size and level. */
	uint8_t	tqm_ring5_pg_size_tqm_ring5_lvl;
	/* TQM ring 5 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_LVL_2
	/* TQM ring 5 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_1G
	/* TQM ring 6 page size and level. */
	uint8_t	tqm_ring6_pg_size_tqm_ring6_lvl;
	/* TQM ring 6 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_LVL_2
	/* TQM ring 6 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_1G
	/* TQM ring 7 page size and level. */
	uint8_t	tqm_ring7_pg_size_tqm_ring7_lvl;
	/* TQM ring 7 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_LVL_2
	/* TQM ring 7 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_1G
	/* MR/AV page size and level. */
	uint8_t	mrav_pg_size_mrav_lvl;
	/* MR/AV PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_LVL_2
	/* MR/AV page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_1G
	/* Timer page size and level. */
	uint8_t	tim_pg_size_tim_lvl;
	/* Timer PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_LVL_1 \
		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_LVL_2
	/* Timer page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_1G
	/* QP page directory. */
	uint64_t	qpc_page_dir;
	/* SRQ page directory. */
	uint64_t	srq_page_dir;
	/* CQ page directory. */
	uint64_t	cq_page_dir;
	/* VNIC page directory. */
	uint64_t	vnic_page_dir;
	/* Stat page directory. */
	uint64_t	stat_page_dir;
	/* TQM slowpath page directory. */
	uint64_t	tqm_sp_page_dir;
	/* TQM ring 0 page directory. */
	uint64_t	tqm_ring0_page_dir;
	/* TQM ring 1 page directory. */
	uint64_t	tqm_ring1_page_dir;
	/* TQM ring 2 page directory. */
	uint64_t	tqm_ring2_page_dir;
	/* TQM ring 3 page directory. */
	uint64_t	tqm_ring3_page_dir;
	/* TQM ring 4 page directory. */
	uint64_t	tqm_ring4_page_dir;
	/* TQM ring 5 page directory. */
	uint64_t	tqm_ring5_page_dir;
	/* TQM ring 6 page directory. */
	uint64_t	tqm_ring6_page_dir;
	/* TQM ring 7 page directory. */
	uint64_t	tqm_ring7_page_dir;
	/* MR/AV page directory. */
	uint64_t	mrav_page_dir;
	/* Timer page directory. */
	uint64_t	tim_page_dir;
	/* Number of entries to reserve for QP1 */
	uint16_t	qp_num_qp1_entries;
	/* Number of entries to reserve for L2 */
	uint16_t	qp_num_l2_entries;
	/* Number of QPs. */
	uint32_t	qp_num_entries;
	/* Number of SRQs. */
	uint32_t	srq_num_entries;
	/* Number of entries to reserve for L2 */
	uint16_t	srq_num_l2_entries;
	/* Number of entries to reserve for L2 */
	uint16_t	cq_num_l2_entries;
	/* Number of CQs. */
	uint32_t	cq_num_entries;
	/* Number of entries to reserve for VNIC entries */
	uint16_t	vnic_num_vnic_entries;
	/* Number of entries to reserve for Ring table entries */
	uint16_t	vnic_num_ring_table_entries;
	/* Number of Stats. */
	uint32_t	stat_num_entries;
	/* Number of TQM slowpath entries. */
	uint32_t	tqm_sp_num_entries;
	/* Number of TQM ring 0 entries. */
	uint32_t	tqm_ring0_num_entries;
	/* Number of TQM ring 1 entries. */
	uint32_t	tqm_ring1_num_entries;
	/* Number of TQM ring 2 entries. */
	uint32_t	tqm_ring2_num_entries;
	/* Number of TQM ring 3 entries. */
	uint32_t	tqm_ring3_num_entries;
	/* Number of TQM ring 4 entries. */
	uint32_t	tqm_ring4_num_entries;
	/* Number of TQM ring 5 entries. */
	uint32_t	tqm_ring5_num_entries;
	/* Number of TQM ring 6 entries. */
	uint32_t	tqm_ring6_num_entries;
	/* Number of TQM ring 7 entries. */
	uint32_t	tqm_ring7_num_entries;
	/*
	 * If the MR/AV split reservation flag is not set, then this field
	 * represents the total number of MR plus AV entries. For versions
	 * of firmware that support the split reservation, when it is not
	 * specified half of the entries will be reserved for MRs and the
	 * other half for AVs.
	 *
	 * If the MR/AV split reservation flag is set, then this
	 * field is logically divided into two 16b fields. Bits `[31:16]`
	 * represents the `mr_num_entries` and bits `[15:0]` represents
	 * `av_num_entries`. The granularity of these values is defined by
	 * the `mrav_num_entries_unit` field returned by the
	 * `backing_store_qcaps` command.
	 */
	uint32_t	mrav_num_entries;
	/* Number of Timer entries. */
	uint32_t	tim_num_entries;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring8_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_SFT \
		0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_SFT \
		4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring8_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring8_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring8_page_dir;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring9_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_SFT \
		0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_SFT \
		4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring9_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring9_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring9_page_dir;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring10_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_SFT \
		0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_SFT \
		4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring10_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring10_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring10_page_dir;
	/* Number of Tx KTLS context entries. */
	uint32_t	tkc_num_entries;
	/* Number of Rx KTLS context entries. */
	uint32_t	rkc_num_entries;
	/* Tx KTLS context page directory. */
	uint64_t	tkc_page_dir;
	/* Rx KTLS context page directory. */
	uint64_t	rkc_page_dir;
	/* Tx KTLS context page size and level. */
	uint8_t	tkc_pg_size_tkc_lvl;
	/* Tx KTLS context PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_LVL_2
	/* Tx KTLS context page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_1G
	/* Rx KTLS context page size and level. */
	uint8_t	rkc_pg_size_rkc_lvl;
	/* Rx KTLS context PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_LVL_2
	/* Rx KTLS context page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_1G
	uint8_t	unused_1[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as 1
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/****************************
 * hwrm_error_recovery_qcfg *
 ****************************/


/* hwrm_error_recovery_qcfg_input (size:192b/24B) */
struct hwrm_error_recovery_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	unused_0[8];
} __rte_packed;

/* hwrm_error_recovery_qcfg_output (size:1664b/208B) */
struct hwrm_error_recovery_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When this flag is set to 1, error recovery will be initiated
	 * through master function driver.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FLAGS_HOST       UINT32_C(0x1)
	/*
	 * When this flag is set to 1, error recovery will be performed
	 * through Co processor.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FLAGS_CO_CPU     UINT32_C(0x2)
	/*
	 * Driver Polling frequency. This value is in units of 100msec.
	 * Typical value would be 10 to indicate 1sec.
	 * Drivers can poll FW health status, Heartbeat, reset_counter with
	 * this frequency.
	 */
	uint32_t	driver_polling_freq;
	/*
	 * This value is in units of 100msec.
	 * Typical value would be 30 to indicate 3sec.
	 * Master function wait period from detecting a fatal error to
	 * initiating reset. In this time period Master PF expects every
	 * active driver will detect fatal error.
	 */
	uint32_t	master_func_wait_period;
	/*
	 * This value is in units of 100msec.
	 * Typical value would be 50 to indicate 5sec.
	 * Normal function wait period from fatal error detection to
	 * polling FW health status. In this time period, drivers should not
	 * do any PCIe MMIO transaction and should not send any HWRM commands.
	 */
	uint32_t	normal_func_wait_period;
	/*
	 * This value is in units of 100msec.
	 * Typical value would be 20 to indicate 2sec.
	 * This field indicates that, master function wait period after chip
	 * reset. After this time, master function should reinitialize with
	 * FW.
	 */
	uint32_t	master_func_wait_period_after_reset;
	/*
	 * This value is in units of 100msec.
	 * Typical value would be 60 to indicate 6sec.
	 * This field is applicable to both master and normal functions.
	 * Even after chip reset, if FW status not changed to ready,
	 * then all the functions can poll for this much time and bailout.
	 */
	uint32_t	max_bailout_time_after_reset;
	/*
	 * FW health status register.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates upper 30bits of the register address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	fw_health_status_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_MASK \
		UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_SFT \
		0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_PCIE_CFG \
		UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_GRC \
		UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_BAR0 \
		UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_BAR1 \
		UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_LAST \
		HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_MASK \
		UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SFT \
		2
	/*
	 * FW HeartBeat register.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates actual address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	fw_heartbeat_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_MASK \
		UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_SFT \
		0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_PCIE_CFG \
		UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_GRC \
		UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_BAR0 \
		UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_BAR1 \
		UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_LAST \
		HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_MASK \
		UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SFT \
		2
	/*
	 * FW reset counter.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates actual address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	fw_reset_cnt_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_MASK \
		UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_SFT \
		0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_PCIE_CFG \
		UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_GRC \
		UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_BAR0 \
		UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_BAR1 \
		UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_LAST \
		HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_MASK \
		UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SFT \
		2
	/*
	 * Reset Inprogress Register address for PFs.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates actual address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	reset_inprogress_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_MASK \
		UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_SFT \
		0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_PCIE_CFG \
		UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_GRC \
		UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_BAR0 \
		UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_BAR1 \
		UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_LAST \
		HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_MASK \
		UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SFT \
		2
	/* This field indicates the mask value for reset_inprogress_reg. */
	uint32_t	reset_inprogress_reg_mask;
	uint8_t	unused_0[3];
	/*
	 * Array of registers and value count to reset the Chip
	 * Each array count has reset_reg, reset_reg_val, delay_after_reset
	 * in TLV format. Depending upon Chip type, number of reset registers
	 * will vary. Drivers have to write reset_reg_val in the reset_reg
	 * location in the same sequence in order to recover from a fatal
	 * error.
	 */
	uint8_t	reg_array_cnt;
	/*
	 * Reset register.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates actual address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	reset_reg[16];
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_MASK \
		UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_SFT     0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_PCIE_CFG \
		UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_GRC \
		UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_BAR0 \
		UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_BAR1 \
		UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_LAST \
		HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_MASK \
		UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SFT           2
	/* Value to be written in reset_reg to reset the controller. */
	uint32_t	reset_reg_val[16];
	/*
	 * This value is in units of 1msec.
	 * Typical value would be 10 to indicate 10msec.
	 * Some of the operations like Core reset require delay before
	 * accessing PCIE MMIO register space.
	 * If this value is non-zero, drivers have to wait for
	 * this much time after writing reset_reg_val in reset_reg.
	 */
	uint8_t	delay_after_reset[16];
	/*
	 * Error recovery counter.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates actual address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	err_recovery_cnt_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_MASK \
		UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_SFT \
		0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_PCIE_CFG \
		UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_GRC \
		UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_BAR0 \
		UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_BAR1 \
		UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_LAST \
		HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_MASK \
		UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SFT \
		2
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_func_echo_response *
 ***************************/


/* hwrm_func_echo_response_input (size:192b/24B) */
struct hwrm_func_echo_response_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	event_data1;
	uint32_t	event_data2;
} __rte_packed;

/* hwrm_func_echo_response_output (size:128b/16B) */
struct hwrm_func_echo_response_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_func_ptp_pin_qcfg *
 **************************/


/* hwrm_func_ptp_pin_qcfg_input (size:192b/24B) */
struct hwrm_func_ptp_pin_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	unused_0[8];
} __rte_packed;

/* hwrm_func_ptp_pin_qcfg_output (size:128b/16B) */
struct hwrm_func_ptp_pin_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The number of TSIO pins that are configured on this board
	 * Up to 4 pins can be returned in the response.
	 */
	uint8_t	num_pins;
	/* Pin state */
	uint8_t	state;
	/*
	 * When this bit is '1', TSIO pin 0 is enabled.
	 * When this bit is '0', TSIO pin 0 is disabled.
	 */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_STATE_PIN0_ENABLED \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', TSIO pin 1 is enabled.
	 * When this bit is '0', TSIO pin 1 is disabled.
	 */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_STATE_PIN1_ENABLED \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', TSIO pin 2 is enabled.
	 * When this bit is '0', TSIO pin 2 is disabled.
	 */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_STATE_PIN2_ENABLED \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', TSIO pin 3 is enabled.
	 * When this bit is '0', TSIO pin 3 is disabled.
	 */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_STATE_PIN3_ENABLED \
		UINT32_C(0x8)
	/* Type of function for Pin #0. */
	uint8_t	pin0_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_NONE     UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_PPS_IN   UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_PPS_OUT  UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_SYNC_IN  UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_SYNC_OUT UINT32_C(0x4)
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_LAST \
		HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_SYNC_OUT
	/* Type of function for Pin #1. */
	uint8_t	pin1_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_NONE     UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_PPS_IN   UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_PPS_OUT  UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_SYNC_IN  UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_SYNC_OUT UINT32_C(0x4)
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_LAST \
		HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_SYNC_OUT
	/* Type of function for Pin #2. */
	uint8_t	pin2_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_NONE \
		UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_PPS_IN \
		UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_PPS_OUT \
		UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_SYNC_IN \
		UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_SYNC_OUT \
		UINT32_C(0x4)
	/* SYNCE primary clock OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_SYNCE_PRIMARY_CLOCK_OUT \
		UINT32_C(0x5)
	/* SYNCE secondary clock OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_SYNCE_SECONDARY_CLOCK_OUT \
		UINT32_C(0x6)
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_LAST \
		HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_SYNCE_SECONDARY_CLOCK_OUT
	/* Type of function for Pin #3. */
	uint8_t	pin3_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_NONE \
		UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_PPS_IN \
		UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_PPS_OUT \
		UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_SYNC_IN \
		UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_SYNC_OUT \
		UINT32_C(0x4)
	/* SYNCE primary clock OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_SYNCE_PRIMARY_CLOCK_OUT \
		UINT32_C(0x5)
	/* SYNCE secondary OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_SYNCE_SECONDARY_CLOCK_OUT \
		UINT32_C(0x6)
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_LAST \
		HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_SYNCE_SECONDARY_CLOCK_OUT
	uint8_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_func_ptp_pin_cfg *
 *************************/


/* hwrm_func_ptp_pin_cfg_input (size:256b/32B) */
struct hwrm_func_ptp_pin_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the pin0_state field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN0_STATE \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the pin0_usage field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN0_USAGE \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the pin1_state field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN1_STATE \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the pin1_usage field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN1_USAGE \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the pin2_state field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN2_STATE \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the pin2_usage field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN2_USAGE \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the pin3_state field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN3_STATE \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the pin3_usage field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN3_USAGE \
		UINT32_C(0x80)
	/* Enable or disable functionality of Pin #0. */
	uint8_t	pin0_state;
	/* Disabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_STATE_DISABLED UINT32_C(0x0)
	/* Enabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_STATE_ENABLED  UINT32_C(0x1)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_STATE_LAST \
		HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_STATE_ENABLED
	/* Configure function for TSIO pin#0. */
	uint8_t	pin0_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_NONE     UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_PPS_IN   UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_PPS_OUT  UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_SYNC_IN  UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_SYNC_OUT UINT32_C(0x4)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_LAST \
		HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_SYNC_OUT
	/* Enable or disable functionality of Pin #1. */
	uint8_t	pin1_state;
	/* Disabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_STATE_DISABLED UINT32_C(0x0)
	/* Enabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_STATE_ENABLED  UINT32_C(0x1)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_STATE_LAST \
		HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_STATE_ENABLED
	/* Configure function for TSIO pin#1. */
	uint8_t	pin1_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_NONE     UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_PPS_IN   UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_PPS_OUT  UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_SYNC_IN  UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_SYNC_OUT UINT32_C(0x4)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_LAST \
		HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_SYNC_OUT
	/* Enable or disable functionality of Pin #2. */
	uint8_t	pin2_state;
	/* Disabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_STATE_DISABLED UINT32_C(0x0)
	/* Enabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_STATE_ENABLED  UINT32_C(0x1)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_STATE_LAST \
		HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_STATE_ENABLED
	/* Configure function for TSIO pin#2. */
	uint8_t	pin2_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_NONE \
		UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_PPS_IN \
		UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_PPS_OUT \
		UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_SYNC_IN \
		UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_SYNC_OUT \
		UINT32_C(0x4)
	/* SYNCE primary clock OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_SYNCE_PRIMARY_CLOCK_OUT \
		UINT32_C(0x5)
	/* SYNCE secondary clock OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_SYNCE_SECONDARY_CLOCK_OUT \
		UINT32_C(0x6)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_LAST \
		HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_SYNCE_SECONDARY_CLOCK_OUT
	/* Enable or disable functionality of Pin #3. */
	uint8_t	pin3_state;
	/* Disabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_STATE_DISABLED UINT32_C(0x0)
	/* Enabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_STATE_ENABLED  UINT32_C(0x1)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_STATE_LAST \
		HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_STATE_ENABLED
	/* Configure function for TSIO pin#3. */
	uint8_t	pin3_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_NONE \
		UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_PPS_IN \
		UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_PPS_OUT \
		UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_SYNC_IN \
		UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_SYNC_OUT \
		UINT32_C(0x4)
	/* SYNCE primary clock OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_SYNCE_PRIMARY_CLOCK_OUT \
		UINT32_C(0x5)
	/* SYNCE secondary clock OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_SYNCE_SECONDARY_CLOCK_OUT \
		UINT32_C(0x6)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_LAST \
		HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_SYNCE_SECONDARY_CLOCK_OUT
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_func_ptp_pin_cfg_output (size:128b/16B) */
struct hwrm_func_ptp_pin_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_func_ptp_cfg *
 *********************/


/* hwrm_func_ptp_cfg_input (size:384b/48B) */
struct hwrm_func_ptp_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	enables;
	/*
	 * This bit must be '1' for the ptp_pps_event field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_PPS_EVENT \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the ptp_freq_adj_dll_source field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_DLL_SOURCE \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the ptp_freq_adj_dll_phase field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_DLL_PHASE \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the ptp_freq_adj_ext_period field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_EXT_PERIOD \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the ptp_freq_adj_ext_up field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_EXT_UP \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the ptp_freq_adj_ext_phase field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_EXT_PHASE \
		UINT32_C(0x20)
	/* This bit must be '1' for ptp_set_time field to be configured. */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_SET_TIME \
		UINT32_C(0x40)
	/* This field is used to enable interrupt for a specific PPS event. */
	uint8_t	ptp_pps_event;
	/*
	 * When this bit is set to '1', interrupt is enabled for internal
	 * PPS event. Latches timestamp on PPS_OUT TSIO Pin. If user does
	 * not configure PPS_OUT on a TSIO pin, then firmware will allocate
	 * PPS_OUT to an unallocated pin.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_PPS_EVENT_INTERNAL \
		UINT32_C(0x1)
	/*
	 * When this bit is set to '1', interrupt is enabled for external
	 * PPS event. Latches timestamp on PPS_IN TSIO pin.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_PPS_EVENT_EXTERNAL \
		UINT32_C(0x2)
	/*
	 * This field is used to set the source signal used to discipline
	 * PHC (PTP Hardware Clock)
	 */
	uint8_t	ptp_freq_adj_dll_source;
	/* No source is selected. Use servo to discipline PHC */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_NONE \
		UINT32_C(0x0)
	/* TSIO Pin #0 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_TSIO_0 \
		UINT32_C(0x1)
	/* TSIO Pin #1 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_TSIO_1 \
		UINT32_C(0x2)
	/* TSIO Pin #2 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_TSIO_2 \
		UINT32_C(0x3)
	/* TSIO Pin #3 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_TSIO_3 \
		UINT32_C(0x4)
	/* Port #0 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_PORT_0 \
		UINT32_C(0x5)
	/* Port #1 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_PORT_1 \
		UINT32_C(0x6)
	/* Port #2 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_PORT_2 \
		UINT32_C(0x7)
	/* Port #3 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_PORT_3 \
		UINT32_C(0x8)
	/* Invalid signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_INVALID \
		UINT32_C(0xff)
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_LAST \
		HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_INVALID
	/*
	 * This field is used to provide phase adjustment for DLL
	 * used to discipline PHC (PTP Hardware clock)
	 */
	uint8_t	ptp_freq_adj_dll_phase;
	/* No Phase adjustment. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_NONE \
		UINT32_C(0x0)
	/* 4Khz sync in frequency. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_4K \
		UINT32_C(0x1)
	/* 8Khz sync in frequency. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_8K \
		UINT32_C(0x2)
	/* 10Mhz sync in frequency. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_10M \
		UINT32_C(0x3)
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_LAST \
		HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_10M
	uint8_t	unused_0[3];
	/*
	 * Period in nanoseconds (ns) for external signal
	 * input.
	 */
	uint32_t	ptp_freq_adj_ext_period;
	/*
	 * Up time in nanoseconds (ns) of the duty cycle
	 * of the external signal. This value should be
	 * less than ptp_freq_adj_ext_period.
	 */
	uint32_t	ptp_freq_adj_ext_up;
	/*
	 * Phase value is provided. This field provides the
	 * least significant 32 bits of the phase input. The
	 * most significant 16 bits come from
	 * ptp_freq_adj_ext_phase_upper field. Setting this
	 * field requires setting ptp_freq_adj_ext_period
	 * field as well to identify the external signal
	 * pin.
	 */
	uint32_t	ptp_freq_adj_ext_phase_lower;
	/*
	 * Phase value is provided. The lower 16 bits of this field is used
	 * with the 32 bit value from ptp_freq_adj_ext_phase_lower
	 * to provide a 48 bit value input for Phase.
	 */
	uint32_t	ptp_freq_adj_ext_phase_upper;
	/*
	 * Allows driver to set the full 64bit time in FW. The upper 16 bits
	 * will be stored in FW and the lower 48bits will be programmed in
	 * PHC. Firmware will send a broadcast async event to all functions
	 * to indicate the programmed upper 16 bits.
	 */
	uint64_t	ptp_set_time;
} __rte_packed;

/* hwrm_func_ptp_cfg_output (size:128b/16B) */
struct hwrm_func_ptp_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_func_ptp_ts_query *
 **************************/


/* hwrm_func_ptp_ts_query_input (size:192b/24B) */
struct hwrm_func_ptp_ts_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* If set, the response includes PPS event timestamps */
	#define HWRM_FUNC_PTP_TS_QUERY_INPUT_FLAGS_PPS_TIME     UINT32_C(0x1)
	/* If set, the response includes PTM timestamps */
	#define HWRM_FUNC_PTP_TS_QUERY_INPUT_FLAGS_PTM_TIME     UINT32_C(0x2)
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_func_ptp_ts_query_output (size:320b/40B) */
struct hwrm_func_ptp_ts_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Timestamp value of last PPS event latched. */
	uint64_t	pps_event_ts;
	/*
	 * PHC timestamp value when PTM responseD request is received
	 * at downstream port (t4'). This is a 48 bit timestamp in nanoseconds.
	 */
	uint64_t	ptm_local_ts;
	/*
	 * PTM System timestamp value corresponding to t4' at
	 * root complex (T4'). Together with ptm_local_ts, these
	 * two timestamps provide the cross-trigger timestamps.
	 * Driver can directly use these values for cross-trigger.
	 * This is a 48 bit timestamp in nanoseconds.
	 */
	uint64_t	ptm_system_ts;
	/*
	 * PTM Link delay. This is the time taken at root complex (RC)
	 * between receiving PTM request and sending PTM response to
	 * downstream port. This is a 32 bit value in nanoseconds.
	 */
	uint32_t	ptm_link_delay;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_func_ptp_ext_cfg *
 *************************/


/* hwrm_func_ptp_ext_cfg_input (size:256b/32B) */
struct hwrm_func_ptp_ext_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	enables;
	/*
	 * This bit must be '1' for the phc_master_fid field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_EXT_CFG_INPUT_ENABLES_PHC_MASTER_FID \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the phc_sec_fid field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_EXT_CFG_INPUT_ENABLES_PHC_SEC_FID \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the phc_sec_mode field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_EXT_CFG_INPUT_ENABLES_PHC_SEC_MODE \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the failover_timer field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_EXT_CFG_INPUT_ENABLES_FAILOVER_TIMER \
		UINT32_C(0x8)
	/*
	 * This field is used to configure the Master function. Only this
	 * function can modify or condition the PHC. Only driver calls from
	 * this function are allowed to adjust frequency of PHC or configure
	 * PPS functionality.
	 * If driver does not specify this FID, then firmware will auto select
	 * the first function that makes the call to modify PHC as the Master.
	 */
	uint16_t	phc_master_fid;
	/*
	 * This field is used to configure the secondary function. This
	 * function becomes the Master function in case of failover from
	 * Master function.
	 * If driver does not specify this FID, firmware will auto select
	 * the last non-master function to make a call to condition PHC as
	 * secondary.
	 */
	uint16_t	phc_sec_fid;
	/*
	 * This field is used to configure conditions under which a function
	 * can become a secondary function.
	 */
	uint8_t	phc_sec_mode;
	/*
	 * Immediately failover to the current secondary function. If there
	 * is no secondary function available, failover does not happen.
	 */
	#define HWRM_FUNC_PTP_EXT_CFG_INPUT_PHC_SEC_MODE_SWITCH  UINT32_C(0x0)
	/*
	 * All functions (PF and VF) can be used during auto selection
	 * of a secondary function. This is not used in case of admin
	 * configured secondary function.
	 */
	#define HWRM_FUNC_PTP_EXT_CFG_INPUT_PHC_SEC_MODE_ALL     UINT32_C(0x1)
	/*
	 * Only PF's can be selected as a secondary function during auto
	 * selection. This is not used in case of admin configured secondary
	 * function.
	 */
	#define HWRM_FUNC_PTP_EXT_CFG_INPUT_PHC_SEC_MODE_PF_ONLY UINT32_C(0x2)
	#define HWRM_FUNC_PTP_EXT_CFG_INPUT_PHC_SEC_MODE_LAST \
		HWRM_FUNC_PTP_EXT_CFG_INPUT_PHC_SEC_MODE_PF_ONLY
	uint8_t	unused_0;
	/*
	 * This field indicates the failover time is milliseconds. If the
	 * timeout expires, firmware will failover PTP configurability from
	 * current master to secondary fid.
	 * 0 - Failover timer is automatically selected based on the last
	 * adjFreq() call. If adjFreq() is not called for 3 * (last interval)
	 * the failover kicks in. For example, if last interval between
	 * adjFreq() calls was 2 seconds and the next adjFreq() is not made for
	 * at least 6 seconds, then secondary takes over as master to condition
	 * PHC. Firmware rounds up the failover timer to be a multiple of 250
	 * ms. Firmware checks every 250 ms to see if timer expired.
	 * 0xFFFFFFFF - If driver specifies this value, then failover never
	 * happens. Admin or auto selected Master will always be used for
	 * conditioning PHC.
	 * X - If driver specifies any other value, this is admin indicated
	 * failover timeout. If no adjFreq() call is made within this timeout
	 * value, then failover happens. This value should be a multiple of
	 * 250 ms. Firmware checks every 250 ms to see if timer expired.
	 */
	uint32_t	failover_timer;
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_func_ptp_ext_cfg_output (size:128b/16B) */
struct hwrm_func_ptp_ext_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_func_ptp_ext_qcfg *
 **************************/


/* hwrm_func_ptp_ext_qcfg_input (size:192b/24B) */
struct hwrm_func_ptp_ext_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	unused_0[8];
} __rte_packed;

/* hwrm_func_ptp_ext_qcfg_output (size:256b/32B) */
struct hwrm_func_ptp_ext_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Firmware returns the current PHC master function. This function
	 * could either be admin selected or auto selected.
	 */
	uint16_t	phc_master_fid;
	/*
	 * Firmware returns the current PHC secondary function. This function
	 * could either be admin selected or auto selected.
	 */
	uint16_t	phc_sec_fid;
	/*
	 * Firmware returns the last non-master/non-secondary function to
	 * make a call to condition PHC.
	 */
	uint16_t	phc_active_fid0;
	/*
	 * Firmware returns the second last non-master/non-secondary function
	 * to make a call to condition PHC.
	 */
	uint16_t	phc_active_fid1;
	/*
	 * Timestamp indicating the last time a failover happened. The master
	 * and secondary functions in the failover event is indicated in the
	 * next two fields.
	 */
	uint32_t	last_failover_event;
	/*
	 * Last failover happened from this function. This was the master
	 * function at the time of failover.
	 */
	uint16_t	from_fid;
	/*
	 * Last failover happened to this function. This was the secondary
	 * function at the time of failover.
	 */
	uint16_t	to_fid;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_func_key_ctx_alloc *
 ***************************/


/* hwrm_func_key_ctx_alloc_input (size:320b/40B) */
struct hwrm_func_key_ctx_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Function ID. */
	uint16_t	fid;
	/* Number of Key Contexts to be allocated. */
	uint16_t	num_key_ctxs;
	/* DMA buffer size in bytes. */
	uint32_t	dma_bufr_size_bytes;
	/* Key Context type. */
	uint8_t	key_ctx_type;
	/* KTLS Tx Key Context type. */
	#define HWRM_FUNC_KEY_CTX_ALLOC_INPUT_KEY_CTX_TYPE_TX \
		UINT32_C(0x0)
	/* KTLS Rx Key Context type. */
	#define HWRM_FUNC_KEY_CTX_ALLOC_INPUT_KEY_CTX_TYPE_RX \
		UINT32_C(0x1)
	/* QUIC Tx Key Context type. */
	#define HWRM_FUNC_KEY_CTX_ALLOC_INPUT_KEY_CTX_TYPE_QUIC_TX \
		UINT32_C(0x2)
	/* QUIC Rx Key Context type. */
	#define HWRM_FUNC_KEY_CTX_ALLOC_INPUT_KEY_CTX_TYPE_QUIC_RX \
		UINT32_C(0x3)
	#define HWRM_FUNC_KEY_CTX_ALLOC_INPUT_KEY_CTX_TYPE_LAST \
		HWRM_FUNC_KEY_CTX_ALLOC_INPUT_KEY_CTX_TYPE_QUIC_RX
	uint8_t	unused_0[7];
	/* Host DMA address to send back KTLS context IDs. */
	uint64_t	host_dma_addr;
} __rte_packed;

/* hwrm_func_key_ctx_alloc_output (size:128b/16B) */
struct hwrm_func_key_ctx_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Actual number of Key Contexts allocated. */
	uint16_t	num_key_ctxs_allocated;
	/* Control flags. */
	uint8_t	flags;
	/*
	 * When set, it indicates that all key contexts allocated by this
	 * command are contiguous. As a result, the driver has to read the
	 * start context ID from the first entry of the DMA data buffer
	 * and figures out the end context ID by start context ID +
	 * num_key_ctxs_allocated - 1.
	 */
	#define HWRM_FUNC_KEY_CTX_ALLOC_OUTPUT_FLAGS_KEY_CTXS_CONTIGUOUS \
		UINT32_C(0x1)
	uint8_t	unused_0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************************
 * hwrm_func_backing_store_cfg_v2 *
 **********************************/


/* hwrm_func_backing_store_cfg_v2_input (size:448b/56B) */
struct hwrm_func_backing_store_cfg_v2_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Type of backing store to be configured. */
	uint16_t	type;
	/* Queue pair. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_QP \
		UINT32_C(0x0)
	/* Shared receive queue. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_SRQ \
		UINT32_C(0x1)
	/* Completion queue. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_CQ \
		UINT32_C(0x2)
	/* Virtual NIC. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_VNIC \
		UINT32_C(0x3)
	/* Statistic context. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_STAT \
		UINT32_C(0x4)
	/* Slow-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_SP_TQM_RING \
		UINT32_C(0x5)
	/* Fast-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_FP_TQM_RING \
		UINT32_C(0x6)
	/* Memory Region and Memory Address Vector Context. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_MRAV \
		UINT32_C(0xe)
	/* TIM. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_TIM \
		UINT32_C(0xf)
	/* Tx key context. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_TKC \
		UINT32_C(0x13)
	/* Rx key context. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_RKC \
		UINT32_C(0x14)
	/* Mid-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_MP_TQM_RING \
		UINT32_C(0x15)
	/* SQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_SQ_DB_SHADOW \
		UINT32_C(0x16)
	/* RQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_RQ_DB_SHADOW \
		UINT32_C(0x17)
	/* SRQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_SRQ_DB_SHADOW \
		UINT32_C(0x18)
	/* CQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_CQ_DB_SHADOW \
		UINT32_C(0x19)
	/* QUIC Tx key context. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_QUIC_TKC \
		UINT32_C(0x1a)
	/* QUIC Rx key context. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_QUIC_RKC \
		UINT32_C(0x1b)
	/* Invalid type. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_INVALID \
		UINT32_C(0xffff)
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_INVALID
	/*
	 * Instance of the backing store type. It is zero-based,
	 * which means "0" indicates the first instance. For backing
	 * stores with single instance only, leave this field to 0.
	 * 1. If the backing store type is MPC TQM ring, use the following
	 *    instance value to MPC client mapping:
	 *    TCE (0), RCE (1), TE_CFA(2), RE_CFA (3), PRIMATE(4)
	 */
	uint16_t	instance;
	/* Control flags. */
	uint32_t	flags;
	/*
	 * When set, the firmware only uses on-chip resources and
	 * does not expect any backing store to be provided by the
	 * host driver. This mode provides minimal L2 functionality
	 * (e.g. limited L2 resources, no RoCE).
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_FLAGS_PREBOOT_MODE \
		UINT32_C(0x1)
	/*
	 * When set, the driver indicates that the backing store type
	 * to be configured in this command is the last one to do for
	 * the associated PF. That means all backing store type
	 * configurations are done for the corresponding PF after this
	 * command. As a result, the firmware has to do the necessary
	 * post configurations.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_FLAGS_BS_CFG_ALL_DONE \
		UINT32_C(0x2)
	/*
	 * When set, the driver indicates extending the size of the specific
	 * backing store type instead of configuring the corresponding PBLs.
	 * The size specified in the command will be the new size to be
	 * configured. The operation is only valid when the specific backing
	 * store has been configured before. Otherwise, the firmware will
	 * return an error. The driver needs to zero out the entry_size,
	 * flags, page_dir, and page_size_pbl_level fields, and the
	 * firmware will ignore these inputs. Further, the firmware expects
	 * the num_entries and any valid split entries to be no less than
	 * the initial value that has been configured. If not, it will
	 * return an error code.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_FLAGS_BS_EXTEND \
		UINT32_C(0x4)
	/* Page directory. */
	uint64_t	page_dir;
	/* Number of entries */
	uint32_t	num_entries;
	/* Number of bytes allocated for each entry */
	uint16_t	entry_size;
	/* Page size and pbl level. */
	uint8_t	page_size_pbl_level;
	/* PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PBL_LEVEL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PBL_LEVEL_SFT   0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PBL_LEVEL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PBL_LEVEL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PBL_LEVEL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PBL_LEVEL_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PBL_LEVEL_LVL_2
	/* Page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_PG_1G
	/*
	 * This field counts how many split entries contain valid data.
	 * Below is the table that maps the count value:
	 * | Count |                     Indication                     |
	 * | ----- | -------------------------------------------------- |
	 * |   0   | None of the split entries has valid data.          |
	 * |   1   | Only "split_entry_0" contains valid data.          |
	 * |   2   | Only "split_entry_0" and "1" have valid data.      |
	 * |   3   | Only "split_entry_0", "1" and "2" have valid data. |
	 * |   4   | All four split entries have valid data.            |
	 */
	uint8_t	subtype_valid_cnt;
	/*
	 * Split entry #0. Note that the four split entries (as a group)
	 * must be cast to a type-specific data structure first before
	 * accessing it! Below is the table that maps a backing store
	 * type to the associated split entry casting data structure.
	 * | Type |       Split Entry Casting Data Structure           |
	 * | ---- | -------------------------------------------------- |
	 * | QPC  |             qpc_split_entries                      |
	 * | SRQ  |             srq_split_entries                      |
	 * | CQ   |             cq_split_entries                       |
	 * | VINC |            vnic_split_entries                      |
	 * | MRAV |            marv_split_entries                      |
	 */
	uint32_t	split_entry_0;
	/* Split entry #1. */
	uint32_t	split_entry_1;
	/* Split entry #2. */
	uint32_t	split_entry_2;
	/* Split entry #3. */
	uint32_t	split_entry_3;
} __rte_packed;

/* hwrm_func_backing_store_cfg_v2_output (size:128b/16B) */
struct hwrm_func_backing_store_cfg_v2_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	rsvd0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM.  This field should be
	 * read as '1' to indicate that the output has been completely
	 * written. When writing a command completion or response to
	 * an internal processor, the order of writes has to be such
	 * that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************************
 * hwrm_func_backing_store_qcfg_v2 *
 ***********************************/


/* hwrm_func_backing_store_qcfg_v2_input (size:192b/24B) */
struct hwrm_func_backing_store_qcfg_v2_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Type of backing store to be configured. */
	uint16_t	type;
	/* Queue pair. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_QP \
		UINT32_C(0x0)
	/* Shared receive queue. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_SRQ \
		UINT32_C(0x1)
	/* Completion queue. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_CQ \
		UINT32_C(0x2)
	/* Virtual NIC. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_VNIC \
		UINT32_C(0x3)
	/* Statistic context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_STAT \
		UINT32_C(0x4)
	/* Slow-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_SP_TQM_RING \
		UINT32_C(0x5)
	/* Fast-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_FP_TQM_RING \
		UINT32_C(0x6)
	/* Memory Region and Memory Address Vector Context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_MRAV \
		UINT32_C(0xe)
	/* TIM. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_TIM \
		UINT32_C(0xf)
	/* Tx key context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_TKC \
		UINT32_C(0x13)
	/* Rx key context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_RKC \
		UINT32_C(0x14)
	/* Mid-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_MP_TQM_RING \
		UINT32_C(0x15)
	/* SQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_SQ_DB_SHADOW \
		UINT32_C(0x16)
	/* RQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_RQ_DB_SHADOW \
		UINT32_C(0x17)
	/* SRQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_SRQ_DB_SHADOW \
		UINT32_C(0x18)
	/* CQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_CQ_DB_SHADOW \
		UINT32_C(0x19)
	/* QUIC Tx key context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_QUIC_TKC \
		UINT32_C(0x1a)
	/* QUIC Rx key context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_QUIC_RKC \
		UINT32_C(0x1b)
	/* Invalid type. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_INVALID \
		UINT32_C(0xffff)
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_INVALID
	/*
	 * Instance of the backing store type. It is zero-based,
	 * which means "0" indicates the first instance. For backing
	 * stores with single instance only, leave this field to 0.
	 */
	uint16_t	instance;
	uint8_t	rsvd[4];
} __rte_packed;

/* hwrm_func_backing_store_qcfg_v2_output (size:448b/56B) */
struct hwrm_func_backing_store_qcfg_v2_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Type of backing store to be configured. */
	uint16_t	type;
	/* Queue pair. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_QP \
		UINT32_C(0x0)
	/* Shared receive queue. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_SRQ \
		UINT32_C(0x1)
	/* Completion queue. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_CQ \
		UINT32_C(0x2)
	/* Virtual NIC. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_VNIC \
		UINT32_C(0x3)
	/* Statistic context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_STAT \
		UINT32_C(0x4)
	/* Slow-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_SP_TQM_RING \
		UINT32_C(0x5)
	/* Fast-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_FP_TQM_RING \
		UINT32_C(0x6)
	/* Memory Region and Memory Address Vector Context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_MRAV \
		UINT32_C(0xe)
	/* TIM. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_TIM \
		UINT32_C(0xf)
	/* Tx key context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_TKC \
		UINT32_C(0x13)
	/* Rx key context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_RKC \
		UINT32_C(0x14)
	/* Mid-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_MP_TQM_RING \
		UINT32_C(0x15)
	/* QUIC Tx key context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_QUIC_TKC \
		UINT32_C(0x1a)
	/* QUIC Rx key context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_QUIC_RKC \
		UINT32_C(0x1b)
	/* Invalid type. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_INVALID \
		UINT32_C(0xffff)
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_INVALID
	/*
	 * Instance of the backing store type. It is zero-based,
	 * which means "0" indicates the first instance. For backing
	 * stores with single instance only, leave this field to 0.
	 */
	uint16_t	instance;
	/* Control flags. */
	uint32_t	flags;
	/* Page directory. */
	uint64_t	page_dir;
	/* Number of entries */
	uint32_t	num_entries;
	/* Page size and pbl level. */
	uint8_t	page_size_pbl_level;
	/* PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PBL_LEVEL_MASK \
		UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PBL_LEVEL_SFT   0
	/* PBL pointer is physical start address. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PBL_LEVEL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PBL_LEVEL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PBL_LEVEL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PBL_LEVEL_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PBL_LEVEL_LVL_2
	/* Page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_LAST \
		HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_PG_1G
	/*
	 * This field counts how many split entries contain valid data.
	 * Below is the table that maps the count value:
	 * | count |                     Indication                     |
	 * | ----- | -------------------------------------------------- |
	 * |   0   | None of the split entries has valid data.          |
	 * |   1   | Only "split_entry_0" contains valid data.          |
	 * |   2   | Only "split_entry_0" and "1" have valid data.      |
	 * |   3   | Only "split_entry_0", "1" and "2" have valid data. |
	 * |   4   | All four split entries have valid data.            |
	 */
	uint8_t	subtype_valid_cnt;
	uint8_t	rsvd[2];
	/*
	 * Split entry #0. Note that the four split entries (as a group)
	 * must be cast to a type-specific data structure first before
	 * accessing it! Below is the table that maps a backing store
	 * type to the associated split entry casting data structure.
	 * | Type |       Split Entry Casting Data Structure           |
	 * | ---- | -------------------------------------------------- |
	 * | QPC  |             qpc_split_entries                      |
	 * | SRQ  |             srq_split_entries                      |
	 * | CQ   |             cq_split_entries                       |
	 * | VINC |            vnic_split_entries                      |
	 * | MRAV |            marv_split_entries                      |
	 */
	uint32_t	split_entry_0;
	/* Split entry #1. */
	uint32_t	split_entry_1;
	/* Split entry #2. */
	uint32_t	split_entry_2;
	/* Split entry #3. */
	uint32_t	split_entry_3;
	uint8_t	rsvd2[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM.  This field should be
	 * read as '1' to indicate that the output has been completely
	 * written. When writing a command completion or response to
	 * an internal processor, the order of writes has to be such
	 * that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* Common structure to cast QPC split entries. This casting is required in the following HWRM command inputs/outputs if the backing store type is QPC. 1. hwrm_func_backing_store_cfg_v2_input 2. hwrm_func_backing_store_qcfg_v2_output 3. hwrm_func_backing_store_qcaps_v2_output */
/* qpc_split_entries (size:128b/16B) */
struct qpc_split_entries {
	/* Number of L2 QP backing store entries. */
	uint32_t	qp_num_l2_entries;
	/* Number of QP1 entries. */
	uint32_t	qp_num_qp1_entries;
	uint32_t	rsvd[2];
} __rte_packed;

/* Common structure to cast SRQ split entries. This casting is required in the following HWRM command inputs/outputs if the backing store type is SRQ. 1. hwrm_func_backing_store_cfg_v2_input 2. hwrm_func_backing_store_qcfg_v2_output 3. hwrm_func_backing_store_qcaps_v2_output */
/* srq_split_entries (size:128b/16B) */
struct srq_split_entries {
	/* Number of L2 SRQ backing store entries. */
	uint32_t	srq_num_l2_entries;
	uint32_t	rsvd;
	uint32_t	rsvd2[2];
} __rte_packed;

/* Common structure to cast CQ split entries. This casting is required in the following HWRM command inputs/outputs if the backing store type is CQ. 1. hwrm_func_backing_store_cfg_v2_input 2. hwrm_func_backing_store_qcfg_v2_output 3. hwrm_func_backing_store_qcaps_v2_output */
/* cq_split_entries (size:128b/16B) */
struct cq_split_entries {
	/* Number of L2 CQ backing store entries. */
	uint32_t	cq_num_l2_entries;
	uint32_t	rsvd;
	uint32_t	rsvd2[2];
} __rte_packed;

/* Common structure to cast VNIC split entries. This casting is required in the following HWRM command inputs/outputs if the backing store type is VNIC. 1. hwrm_func_backing_store_cfg_v2_input 2. hwrm_func_backing_store_qcfg_v2_output 3. hwrm_func_backing_store_qcaps_v2_output */
/* vnic_split_entries (size:128b/16B) */
struct vnic_split_entries {
	/* Number of VNIC backing store entries. */
	uint32_t	vnic_num_vnic_entries;
	uint32_t	rsvd;
	uint32_t	rsvd2[2];
} __rte_packed;

/* Common structure to cast MRAV split entries. This casting is required in the following HWRM command inputs/outputs if the backing store type is MRAV. 1. hwrm_func_backing_store_cfg_v2_input 2. hwrm_func_backing_store_qcfg_v2_output 3. hwrm_func_backing_store_qcaps_v2_output */
/* mrav_split_entries (size:128b/16B) */
struct mrav_split_entries {
	/* Number of AV backing store entries. */
	uint32_t	mrav_num_av_entries;
	uint32_t	rsvd;
	uint32_t	rsvd2[2];
} __rte_packed;

/************************************
 * hwrm_func_backing_store_qcaps_v2 *
 ************************************/


/* hwrm_func_backing_store_qcaps_v2_input (size:192b/24B) */
struct hwrm_func_backing_store_qcaps_v2_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Type of backing store to be queried. */
	uint16_t	type;
	/* Queue pair. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_QP \
		UINT32_C(0x0)
	/* Shared receive queue. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_SRQ \
		UINT32_C(0x1)
	/* Completion queue. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_CQ \
		UINT32_C(0x2)
	/* Virtual NIC. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_VNIC \
		UINT32_C(0x3)
	/* Statistic context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_STAT \
		UINT32_C(0x4)
	/* Slow-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_SP_TQM_RING \
		UINT32_C(0x5)
	/* Fast-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_FP_TQM_RING \
		UINT32_C(0x6)
	/* Memory Region and Memory Address Vector Context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_MRAV \
		UINT32_C(0xe)
	/* TIM. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_TIM \
		UINT32_C(0xf)
	/* Tx key context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_TKC \
		UINT32_C(0x13)
	/* Rx key context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_RKC \
		UINT32_C(0x14)
	/* Mid-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_MP_TQM_RING \
		UINT32_C(0x15)
	/* SQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_SQ_DB_SHADOW \
		UINT32_C(0x16)
	/* RQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_RQ_DB_SHADOW \
		UINT32_C(0x17)
	/* SRQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_SRQ_DB_SHADOW \
		UINT32_C(0x18)
	/* CQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_CQ_DB_SHADOW \
		UINT32_C(0x19)
	/* QUIC Tx key context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_QUIC_TKC \
		UINT32_C(0x1a)
	/* QUIC Rx key context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_QUIC_RKC \
		UINT32_C(0x1b)
	/* Invalid type. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_INVALID \
		UINT32_C(0xffff)
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_LAST \
		HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_INVALID
	uint8_t	rsvd[6];
} __rte_packed;

/* hwrm_func_backing_store_qcaps_v2_output (size:448b/56B) */
struct hwrm_func_backing_store_qcaps_v2_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Type of backing store to be queried. */
	uint16_t	type;
	/* Queue pair. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_QP \
		UINT32_C(0x0)
	/* Shared receive queue. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_SRQ \
		UINT32_C(0x1)
	/* Completion queue. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_CQ \
		UINT32_C(0x2)
	/* Virtual NIC. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_VNIC \
		UINT32_C(0x3)
	/* Statistic context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_STAT \
		UINT32_C(0x4)
	/* Slow-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_SP_TQM_RING \
		UINT32_C(0x5)
	/* Fast-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_FP_TQM_RING \
		UINT32_C(0x6)
	/* Memory Region and Memory Address Vector Context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_MRAV \
		UINT32_C(0xe)
	/* TIM. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_TIM \
		UINT32_C(0xf)
	/* KTLS Tx key context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_TKC \
		UINT32_C(0x13)
	/* KTLS Rx key context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_RKC \
		UINT32_C(0x14)
	/* Mid-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_MP_TQM_RING \
		UINT32_C(0x15)
	/* SQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_SQ_DB_SHADOW \
		UINT32_C(0x16)
	/* RQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_RQ_DB_SHADOW \
		UINT32_C(0x17)
	/* SRQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_SRQ_DB_SHADOW \
		UINT32_C(0x18)
	/* CQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_CQ_DB_SHADOW \
		UINT32_C(0x19)
	/* QUIC Tx key context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_QUIC_TKC \
		UINT32_C(0x1a)
	/* QUIC Rx key context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_QUIC_RKC \
		UINT32_C(0x1b)
	/* Invalid type. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_INVALID \
		UINT32_C(0xffff)
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_LAST \
		HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_INVALID
	/* Number of bytes per backing store entry. */
	uint16_t	entry_size;
	/* Control flags. */
	uint32_t	flags;
	/*
	 * When set, it indicates the context type should be initialized
	 * with the ctx_init_value at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_FLAGS_ENABLE_CTX_KIND_INIT \
		UINT32_C(0x1)
	/* When set, it indicates the context type is valid. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_FLAGS_TYPE_VALID \
		UINT32_C(0x2)
	/*
	 * When set, it indicates the region for this type is not a regular
	 * context memory but a driver managed memory that is created,
	 * initialized and managed by the driver.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_FLAGS_DRIVER_MANAGED_MEMORY \
		UINT32_C(0x4)
	/*
	 * Bit map of the valid instances associated with the
	 * backing store type.
	 * 1. If the backing store type is MPC TQM ring, use the following
	 *    bit to MPC client mapping:
	 *    TCE (0), RCE (1), TE_CFA(2), RE_CFA (3), PRIMATE(4)
	 */
	uint32_t	instance_bit_map;
	/*
	 * Initializer to be used by drivers to initialize context memory
	 * to ensure context subsystem flags an error for an attack before
	 * the first time context load.
	 */
	uint8_t	ctx_init_value;
	/*
	 * Specifies the doubleword offset of ctx_init_value for this
	 * context type.
	 */
	uint8_t	ctx_init_offset;
	/*
	 * Some backing store types, e.g., TQM rings, require the number
	 * of entries to be a multiple of this value to prevent any
	 * resource allocation limitations. If not applicable, leave
	 * this field with "0".
	 */
	uint8_t	entry_multiple;
	uint8_t	rsvd;
	/* Maximum number of backing store entries supported for this type. */
	uint32_t	max_num_entries;
	/*
	 * Minimum number of backing store entries required for this type.
	 * This field is only valid for some backing store types, e.g.,
	 * TQM rings. If not applicable, leave this field with "0".
	 */
	uint32_t	min_num_entries;
	/*
	 * Next valid backing store type. If current type queried is already
	 * the last valid type, firmware must set this field to invalid type.
	 */
	uint16_t	next_valid_type;
	/*
	 * This field counts how many split entries contain valid data.
	 * Below is the table that maps the count value:
	 * | count |                     Indication                     |
	 * | ----- | -------------------------------------------------- |
	 * |   0   | None of the split entries has valid data.          |
	 * |   1   | Only "split_entry_0" contains valid data.          |
	 * |   2   | Only "split_entry_0" and "1" have valid data.      |
	 * |   3   | Only "split_entry_0", "1" and "2" have valid data. |
	 * |   4   | All four split entries have valid data.            |
	 */
	uint8_t	subtype_valid_cnt;
	uint8_t	rsvd2;
	/*
	 * Split entry #0. Note that the four split entries (as a group)
	 * must be cast to a type-specific data structure first before
	 * accessing it! Below is the table that maps a backing store
	 * type to the associated split entry casting data structure.
	 * | Type |       Split Entry Casting Data Structure           |
	 * | ---- | -------------------------------------------------- |
	 * | QPC  |             qpc_split_entries                      |
	 * | SRQ  |             srq_split_entries                      |
	 * | CQ   |             cq_split_entries                       |
	 * | VINC |            vnic_split_entries                      |
	 * | MRAV |            marv_split_entries                      |
	 */
	uint32_t	split_entry_0;
	/* Split entry #1. */
	uint32_t	split_entry_1;
	/* Split entry #2. */
	uint32_t	split_entry_2;
	/* Split entry #3. */
	uint32_t	split_entry_3;
	uint8_t	rsvd3[3];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM.  This field should be
	 * read as '1' to indicate that the output has been completely
	 * written. When writing a command completion or response to
	 * an internal processor, the order of writes has to be such
	 * that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/****************************
 * hwrm_func_dbr_pacing_cfg *
 ****************************/


/* hwrm_func_dbr_pacing_cfg_input (size:320b/40B) */
struct hwrm_func_dbr_pacing_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * This bit must be '1' to enable DBR NQ events. The NQ ID to
	 * receive the events must be specified in the primary_nq_id
	 * field.
	 */
	#define HWRM_FUNC_DBR_PACING_CFG_INPUT_FLAGS_DBR_NQ_EVENT_ENABLE \
		UINT32_C(0x1)
	/* This bit must be '1' to disable DBR NQ events. */
	#define HWRM_FUNC_DBR_PACING_CFG_INPUT_FLAGS_DBR_NQ_EVENT_DISABLE \
		UINT32_C(0x2)
	uint8_t	unused_0[7];
	uint32_t	enables;
	/*
	 * This bit must be '1' for the primary_nq_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_DBR_PACING_CFG_INPUT_ENABLES_PRIMARY_NQ_ID_VALID \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the pacing_threshold field to be
	 * configured.
	 */
	#define HWRM_FUNC_DBR_PACING_CFG_INPUT_ENABLES_PACING_THRESHOLD_VALID \
		UINT32_C(0x2)
	/*
	 * Specify primary functions NQ ID to receive the doorbell pacing
	 * threshold crossing events.
	 */
	uint32_t	primary_nq_id;
	/*
	 * Specify pacing threshold value, as a percentage of the max
	 * doorbell FIFO depth. The range is 1 to 36.
	 */
	uint32_t	pacing_threshold;
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_func_dbr_pacing_cfg_output (size:128b/16B) */
struct hwrm_func_dbr_pacing_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************************
 * hwrm_func_dbr_pacing_qcfg *
 *****************************/


/* hwrm_func_dbr_pacing_qcfg_input (size:128b/16B) */
struct hwrm_func_dbr_pacing_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_func_dbr_pacing_qcfg_output (size:512b/64B) */
struct hwrm_func_dbr_pacing_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	flags;
	/* When this bit is '1', it indicates DBR NQ events are enabled. */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_FLAGS_DBR_NQ_EVENT_ENABLED \
		UINT32_C(0x1)
	uint8_t	unused_0[7];
	/*
	 * The Doorbell global FIFO occupancy register. This field should be
	 * used by the driver and user library in the doorbell pacing
	 * algorithm. Lower 2 bits indicates address space location and upper
	 * 30 bits indicates upper 30bits of the register address. A value of
	 * 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	dbr_stat_db_fifo_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SPACE_MASK \
		UINT32_C(0x3)
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SPACE_SFT \
		0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SPACE_PCIE_CFG \
		UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SPACE_GRC \
		UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SPACE_BAR0 \
		UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SPACE_BAR1 \
		UINT32_C(0x3)
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SPACE_LAST \
		HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_MASK \
		UINT32_C(0xfffffffc)
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SFT \
		2
	/*
	 * This field indicates the mask value for dbr_stat_db_fifo_reg
	 * to get the high watermark for doorbell FIFO.
	 */
	uint32_t	dbr_stat_db_fifo_reg_watermark_mask;
	/*
	 * This field indicates the shift value for dbr_stat_db_fifo_reg
	 * to get the high watermark for doorbell FIFO.
	 */
	uint8_t	dbr_stat_db_fifo_reg_watermark_shift;
	uint8_t	unused_1[3];
	/*
	 * This field indicates the mask value for dbr_stat_db_fifo_reg
	 * to get the amount of room left for doorbell FIFO.
	 */
	uint32_t	dbr_stat_db_fifo_reg_fifo_room_mask;
	/*
	 * This field indicates the shift value for dbr_stat_db_fifo_reg
	 * to get the amount of room left for doorbell FIFO.
	 */
	uint8_t	dbr_stat_db_fifo_reg_fifo_room_shift;
	uint8_t	unused_2[3];
	/*
	 * DBR_REG_AEQ_ARM register. This field should be used by the driver
	 * to rearm the interrupt for regeneration of a notification to the
	 * host from the hardware when the global doorbell occupancy threshold
	 * is above the threshold value. Lower 2 bits indicates address space
	 * location and upper 30 bits indicates upper 30bits of the register
	 * address. A value of 0xFFFF-FFFF indicates this register does not
	 * exist.
	 */
	uint32_t	dbr_throttling_aeq_arm_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SPACE_MASK \
		UINT32_C(0x3)
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SPACE_SFT \
		0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SPACE_PCIE_CFG \
		UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SPACE_GRC \
		UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SPACE_BAR0 \
		UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SPACE_BAR1 \
		UINT32_C(0x3)
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SPACE_LAST \
		HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_MASK \
		UINT32_C(0xfffffffc)
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SFT \
		2
	/*
	 * This field indicates the value to be written for
	 * dbr_throttling_aeq_arm_reg register.
	 */
	uint8_t	dbr_throttling_aeq_arm_reg_val;
	uint8_t	unused_3[7];
	/*
	 * Specifies primary functions NQ ID.
	 * A value of 0xFFFF FFFF indicates NQ ID is invalid.
	 */
	uint32_t	primary_nq_id;
	/*
	 * Specifies the pacing threshold value, as a percentage of the
	 * max doorbell FIFO depth. The range is 1 to 100.
	 */
	uint32_t	pacing_threshold;
	uint8_t	unused_4[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/****************************************
 * hwrm_func_dbr_pacing_broadcast_event *
 ****************************************/


/* hwrm_func_dbr_pacing_broadcast_event_input (size:128b/16B) */
struct hwrm_func_dbr_pacing_broadcast_event_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_func_dbr_pacing_broadcast_event_output (size:128b/16B) */
struct hwrm_func_dbr_pacing_broadcast_event_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************************
 * hwrm_func_dbr_pacing_nqlist_query *
 *************************************/


/* hwrm_func_dbr_pacing_nqlist_query_input (size:128b/16B) */
struct hwrm_func_dbr_pacing_nqlist_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_func_dbr_pacing_nqlist_query_output (size:384b/48B) */
struct hwrm_func_dbr_pacing_nqlist_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id0;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id1;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id2;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id3;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id4;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id5;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id6;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id7;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id8;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id9;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id10;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id11;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id12;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id13;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id14;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id15;
	/* Number of consecutive NQ ring IDs populated in the response. */
	uint32_t	num_nqs;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************************
 * hwrm_func_dbr_recovery_completed *
 ************************************/


/* hwrm_func_dbr_recovery_completed_input (size:192b/24B) */
struct hwrm_func_dbr_recovery_completed_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Specifies the epoch value with the one that was specified by the
	 * firmware in the error_report_doorbell_drop_threshold async event
	 * corresponding to the specific recovery cycle.
	 */
	uint32_t	epoch;
	/* The epoch value. */
	#define HWRM_FUNC_DBR_RECOVERY_COMPLETED_INPUT_EPOCH_VALUE_MASK \
		UINT32_C(0xffffff)
	#define HWRM_FUNC_DBR_RECOVERY_COMPLETED_INPUT_EPOCH_VALUE_SFT 0
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_func_dbr_recovery_completed_output (size:128b/16B) */
struct hwrm_func_dbr_recovery_completed_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_func_synce_cfg *
 ***********************/


/* hwrm_func_synce_cfg_input (size:192b/24B) */
struct hwrm_func_synce_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	enables;
	/*
	 * This bit must be '1' for the freq_profile field to be
	 * configured.
	 */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_ENABLES_FREQ_PROFILE \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the primary_clock_state field to be
	 * configured.
	 */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_ENABLES_PRIMARY_CLOCK \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the secondary_clock_state field to be
	 * configured.
	 */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_ENABLES_SECONDARY_CLOCK \
		UINT32_C(0x4)
	/* Frequency profile for SyncE recovered clock. */
	uint8_t	freq_profile;
	/* Invalid frequency profile */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_FREQ_PROFILE_INVALID UINT32_C(0x0)
	/* 25MHz SyncE clock profile */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_FREQ_PROFILE_25MHZ   UINT32_C(0x1)
	#define HWRM_FUNC_SYNCE_CFG_INPUT_FREQ_PROFILE_LAST \
		HWRM_FUNC_SYNCE_CFG_INPUT_FREQ_PROFILE_25MHZ
	/*
	 * Enable or disable primary clock for PF/port, overriding previous
	 * primary clock setting.
	 */
	uint8_t	primary_clock_state;
	/* Disable clock */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_PRIMARY_CLOCK_STATE_DISABLE \
		UINT32_C(0x0)
	/* Enable clock */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_PRIMARY_CLOCK_STATE_ENABLE \
		UINT32_C(0x1)
	#define HWRM_FUNC_SYNCE_CFG_INPUT_PRIMARY_CLOCK_STATE_LAST \
		HWRM_FUNC_SYNCE_CFG_INPUT_PRIMARY_CLOCK_STATE_ENABLE
	/*
	 * Enable or disable secondary clock for PF/port, overriding previous
	 * secondary clock setting.
	 */
	uint8_t	secondary_clock_state;
	/* Clock disabled */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_SECONDARY_CLOCK_STATE_DISABLE \
		UINT32_C(0x0)
	/* Clock enabled */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_SECONDARY_CLOCK_STATE_ENABLE \
		UINT32_C(0x1)
	#define HWRM_FUNC_SYNCE_CFG_INPUT_SECONDARY_CLOCK_STATE_LAST \
		HWRM_FUNC_SYNCE_CFG_INPUT_SECONDARY_CLOCK_STATE_ENABLE
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_func_synce_cfg_output (size:128b/16B) */
struct hwrm_func_synce_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_func_synce_qcfg *
 ************************/


/* hwrm_func_synce_qcfg_input (size:192b/24B) */
struct hwrm_func_synce_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	unused_0[8];
} __rte_packed;

/* hwrm_func_synce_qcfg_output (size:128b/16B) */
struct hwrm_func_synce_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Frequency profile for SyncE recovered clock. */
	uint8_t	freq_profile;
	/* Invalid frequency profile */
	#define HWRM_FUNC_SYNCE_QCFG_OUTPUT_FREQ_PROFILE_INVALID UINT32_C(0x0)
	/* 25MHz SyncE clock profile */
	#define HWRM_FUNC_SYNCE_QCFG_OUTPUT_FREQ_PROFILE_25MHZ   UINT32_C(0x1)
	#define HWRM_FUNC_SYNCE_QCFG_OUTPUT_FREQ_PROFILE_LAST \
		HWRM_FUNC_SYNCE_QCFG_OUTPUT_FREQ_PROFILE_25MHZ
	/* SyncE recovered clock state */
	uint8_t	state;
	/*
	 * When this bit is '1', primary clock is enabled for this PF/port.
	 * When this bit is '0', primary clock is disabled for this PF/port.
	 */
	#define HWRM_FUNC_SYNCE_QCFG_OUTPUT_STATE_PRIMARY_CLOCK_ENABLED \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', secondary clock is enabled for this
	 * PF/port.
	 * When this bit is '0', secondary clock is disabled for this
	 * PF/port.
	 */
	#define HWRM_FUNC_SYNCE_QCFG_OUTPUT_STATE_SECONDARY_CLOCK_ENABLED \
		UINT32_C(0x2)
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_func_vlan_qcfg *
 ***********************/


/* hwrm_func_vlan_qcfg_input (size:192b/24B) */
struct hwrm_func_vlan_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being
	 * configured.
	 * If set to 0xFF... (All Fs), then the configuration is
	 * for the requesting function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_func_vlan_qcfg_output (size:320b/40B) */
struct hwrm_func_vlan_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint64_t	unused_0;
	/* S-TAG VLAN identifier configured for the function. */
	uint16_t	stag_vid;
	/* S-TAG PCP value configured for the function. */
	uint8_t	stag_pcp;
	uint8_t	unused_1;
	/*
	 * S-TAG TPID value configured for the function. This field is specified in
	 * network byte order.
	 */
	uint16_t	stag_tpid;
	/* C-TAG VLAN identifier configured for the function. */
	uint16_t	ctag_vid;
	/* C-TAG PCP value configured for the function. */
	uint8_t	ctag_pcp;
	uint8_t	unused_2;
	/*
	 * C-TAG TPID value configured for the function. This field is specified in
	 * network byte order.
	 */
	uint16_t	ctag_tpid;
	/* Future use. */
	uint32_t	rsvd2;
	/* Future use. */
	uint32_t	rsvd3;
	uint8_t	unused_3[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_func_vlan_cfg *
 **********************/


/* hwrm_func_vlan_cfg_input (size:384b/48B) */
struct hwrm_func_vlan_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being
	 * configured.
	 * If set to 0xFF... (All Fs), then the configuration is
	 * for the requesting function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[2];
	uint32_t	enables;
	/*
	 * This bit must be '1' for the stag_vid field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_STAG_VID      UINT32_C(0x1)
	/*
	 * This bit must be '1' for the ctag_vid field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_CTAG_VID      UINT32_C(0x2)
	/*
	 * This bit must be '1' for the stag_pcp field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_STAG_PCP      UINT32_C(0x4)
	/*
	 * This bit must be '1' for the ctag_pcp field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_CTAG_PCP      UINT32_C(0x8)
	/*
	 * This bit must be '1' for the stag_tpid field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_STAG_TPID     UINT32_C(0x10)
	/*
	 * This bit must be '1' for the ctag_tpid field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_CTAG_TPID     UINT32_C(0x20)
	/* S-TAG VLAN identifier configured for the function. */
	uint16_t	stag_vid;
	/* S-TAG PCP value configured for the function. */
	uint8_t	stag_pcp;
	uint8_t	unused_1;
	/*
	 * S-TAG TPID value configured for the function. This field is specified in
	 * network byte order.
	 */
	uint16_t	stag_tpid;
	/* C-TAG VLAN identifier configured for the function. */
	uint16_t	ctag_vid;
	/* C-TAG PCP value configured for the function. */
	uint8_t	ctag_pcp;
	uint8_t	unused_2;
	/*
	 * C-TAG TPID value configured for the function. This field is specified in
	 * network byte order.
	 */
	uint16_t	ctag_tpid;
	/* Future use. */
	uint32_t	rsvd1;
	/* Future use. */
	uint32_t	rsvd2;
	uint8_t	unused_3[4];
} __rte_packed;

/* hwrm_func_vlan_cfg_output (size:128b/16B) */
struct hwrm_func_vlan_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************************
 * hwrm_func_vf_vnic_ids_query *
 *******************************/


/* hwrm_func_vf_vnic_ids_query_input (size:256b/32B) */
struct hwrm_func_vf_vnic_ids_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	vf_id;
	uint8_t	unused_0[2];
	/* Max number of vnic ids in vnic id table */
	uint32_t	max_vnic_id_cnt;
	/* This is the address for VF VNIC ID table */
	uint64_t	vnic_id_tbl_addr;
} __rte_packed;

/* hwrm_func_vf_vnic_ids_query_output (size:128b/16B) */
struct hwrm_func_vf_vnic_ids_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Actual number of vnic ids
	 *
	 * Each VNIC ID is written as a 32-bit number.
	 */
	uint32_t	vnic_id_cnt;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_func_vf_bw_cfg *
 ***********************/


/* hwrm_func_vf_bw_cfg_input (size:960b/120B) */
struct hwrm_func_vf_bw_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The number of VF functions that are being configured.
	 * The cmd space allows up to 50 VFs' BW to be configured with one cmd.
	 */
	uint16_t	num_vfs;
	uint16_t	unused[3];
	/* These 16-bit fields contain the VF fid and the rate scale percentage. */
	uint16_t	vfn[48];
	/* The physical VF id the adjustment will be made to. */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_VFID_MASK     UINT32_C(0xfff)
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_VFID_SFT      0
	/*
	 * This field configures the rate scale percentage of the VF as specified
	 * by the physical VF id.
	 */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_MASK     UINT32_C(0xf000)
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_SFT      12
	/* 0% of the max tx rate */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_0 \
		(UINT32_C(0x0) << 12)
	/* 6.66% of the max tx rate */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_6_66 \
		(UINT32_C(0x1) << 12)
	/* 13.33% of the max tx rate */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_13_33 \
		(UINT32_C(0x2) << 12)
	/* 20% of the max tx rate */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_20 \
		(UINT32_C(0x3) << 12)
	/* 26.66% of the max tx rate */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_26_66 \
		(UINT32_C(0x4) << 12)
	/* 33% of the max tx rate */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_33_33 \
		(UINT32_C(0x5) << 12)
	/* 40% of the max tx rate */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_40 \
		(UINT32_C(0x6) << 12)
	/* 46.66% of the max tx rate */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_46_66 \
		(UINT32_C(0x7) << 12)
	/* 53.33% of the max tx rate */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_53_33 \
		(UINT32_C(0x8) << 12)
	/* 60% of the max tx rate */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_60 \
		(UINT32_C(0x9) << 12)
	/* 66.66% of the max tx rate */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_66_66 \
		(UINT32_C(0xa) << 12)
	/* 53.33% of the max tx rate */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_73_33 \
		(UINT32_C(0xb) << 12)
	/* 80% of the max tx rate */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_80 \
		(UINT32_C(0xc) << 12)
	/* 86.66% of the max tx rate */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_86_66 \
		(UINT32_C(0xd) << 12)
	/* 93.33% of the max tx rate */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_93_33 \
		(UINT32_C(0xe) << 12)
	/* 100% of the max tx rate */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_100 \
		(UINT32_C(0xf) << 12)
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_LAST \
		HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_100
} __rte_packed;

/* hwrm_func_vf_bw_cfg_output (size:128b/16B) */
struct hwrm_func_vf_bw_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_func_vf_bw_qcfg *
 ************************/


/* hwrm_func_vf_bw_qcfg_input (size:960b/120B) */
struct hwrm_func_vf_bw_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The number of VF functions that are being queried.
	 * The inline response space allows the host to query up to 50 VFs'
	 * rate scale percentage
	 */
	uint16_t	num_vfs;
	uint16_t	unused[3];
	/* These 16-bit fields contain the VF fid */
	uint16_t	vfn[48];
	/* The physical VF id of interest */
	#define HWRM_FUNC_VF_BW_QCFG_INPUT_VFN_VFID_MASK UINT32_C(0xfff)
	#define HWRM_FUNC_VF_BW_QCFG_INPUT_VFN_VFID_SFT 0
} __rte_packed;

/* hwrm_func_vf_bw_qcfg_output (size:960b/120B) */
struct hwrm_func_vf_bw_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The number of VF functions that are being queried.
	 * The inline response space allows the host to query up to 50 VFs' rate
	 * scale percentage
	 */
	uint16_t	num_vfs;
	uint16_t	unused[3];
	/* These 16-bit fields contain the VF fid and the rate scale percentage. */
	uint16_t	vfn[48];
	/* The physical VF id the adjustment will be made to. */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_VFID_MASK     UINT32_C(0xfff)
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_VFID_SFT      0
	/*
	 * This field configures the rate scale percentage of the VF as specified
	 * by the physical VF id.
	 */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_MASK     UINT32_C(0xf000)
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_SFT      12
	/* 0% of the max tx rate */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_0 \
		(UINT32_C(0x0) << 12)
	/* 6.66% of the max tx rate */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_6_66 \
		(UINT32_C(0x1) << 12)
	/* 13.33% of the max tx rate */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_13_33 \
		(UINT32_C(0x2) << 12)
	/* 20% of the max tx rate */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_20 \
		(UINT32_C(0x3) << 12)
	/* 26.66% of the max tx rate */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_26_66 \
		(UINT32_C(0x4) << 12)
	/* 33% of the max tx rate */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_33_33 \
		(UINT32_C(0x5) << 12)
	/* 40% of the max tx rate */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_40 \
		(UINT32_C(0x6) << 12)
	/* 46.66% of the max tx rate */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_46_66 \
		(UINT32_C(0x7) << 12)
	/* 53.33% of the max tx rate */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_53_33 \
		(UINT32_C(0x8) << 12)
	/* 60% of the max tx rate */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_60 \
		(UINT32_C(0x9) << 12)
	/* 66.66% of the max tx rate */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_66_66 \
		(UINT32_C(0xa) << 12)
	/* 53.33% of the max tx rate */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_73_33 \
		(UINT32_C(0xb) << 12)
	/* 80% of the max tx rate */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_80 \
		(UINT32_C(0xc) << 12)
	/* 86.66% of the max tx rate */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_86_66 \
		(UINT32_C(0xd) << 12)
	/* 93.33% of the max tx rate */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_93_33 \
		(UINT32_C(0xe) << 12)
	/* 100% of the max tx rate */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_100 \
		(UINT32_C(0xf) << 12)
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_LAST \
		HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_100
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_func_drv_if_change *
 ***************************/


/* hwrm_func_drv_if_change_input (size:192b/24B) */
struct hwrm_func_drv_if_change_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the function driver is indicating
	 * that the IF state is changing to UP state.  The call should
	 * be made at the beginning of the driver's open call before
	 * resources are allocated.  After making the call, the driver
	 * should check the response to see if any resources may have
	 * changed (see the response below).  If the driver fails
	 * the open call, the driver should make this call again with
	 * this bit cleared to indicate that the IF state is not UP.
	 * During the driver's close call when the IF state is changing
	 * to DOWN, the driver should make this call with the bit cleared
	 * after all resources have been freed.
	 */
	#define HWRM_FUNC_DRV_IF_CHANGE_INPUT_FLAGS_UP     UINT32_C(0x1)
	uint32_t	unused;
} __rte_packed;

/* hwrm_func_drv_if_change_output (size:128b/16B) */
struct hwrm_func_drv_if_change_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When this bit is '1', it indicates that the resources reserved
	 * for this function may have changed.  The driver should check
	 * resource capabilities and reserve resources again before
	 * allocating resources.
	 */
	#define HWRM_FUNC_DRV_IF_CHANGE_OUTPUT_FLAGS_RESC_CHANGE \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates that the firmware got changed / reset.
	 * The driver should do complete re-initialization when that bit is set.
	 */
	#define HWRM_FUNC_DRV_IF_CHANGE_OUTPUT_FLAGS_HOT_FW_RESET_DONE \
		UINT32_C(0x2)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************************
 * hwrm_func_host_pf_ids_query *
 *******************************/


/* hwrm_func_host_pf_ids_query_input (size:192b/24B) */
struct hwrm_func_host_pf_ids_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	host;
	/*
	 * # If this bit is set to '1', the query will contain PF(s)
	 * belongs to SOC host.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_HOST_SOC      UINT32_C(0x1)
	/*
	 * # If this bit is set to '1', the query will contain PF(s)
	 * belongs to EP0 host.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_HOST_EP_0     UINT32_C(0x2)
	/*
	 * # If this bit is set to '1', the query will contain PF(s)
	 * belongs to EP1 host.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_HOST_EP_1     UINT32_C(0x4)
	/*
	 * # If this bit is set to '1', the query will contain PF(s)
	 * belongs to EP2 host.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_HOST_EP_2     UINT32_C(0x8)
	/*
	 * # If this bit is set to '1', the query will contain PF(s)
	 * belongs to EP3 host.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_HOST_EP_3     UINT32_C(0x10)
	/*
	 * This provides a filter of what PF(s) will be returned in the
	 * query..
	 */
	uint8_t	filter;
	/*
	 * all available PF(s) belong to the host(s) (defined in the
	 * host field). This includes the hidden PFs.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_FILTER_ALL  UINT32_C(0x0)
	/*
	 * all available PF(s) belong to the host(s) (defined in the
	 * host field) that is available for L2 traffic.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_FILTER_L2   UINT32_C(0x1)
	/*
	 * all available PF(s) belong to the host(s) (defined in the
	 * host field) that is available for ROCE traffic.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_FILTER_ROCE UINT32_C(0x2)
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_FILTER_LAST \
		HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_FILTER_ROCE
	uint8_t	unused_1[6];
} __rte_packed;

/* hwrm_func_host_pf_ids_query_output (size:128b/16B) */
struct hwrm_func_host_pf_ids_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This provides the first PF ID of the device. */
	uint16_t	first_pf_id;
	uint16_t	pf_ordinal_mask;
	/*
	 * When this bit is '1', it indicates first PF belongs to one of
	 * the hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_0 \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates 2nd PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_1 \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates 3rd PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_2 \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates 4th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_3 \
		UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates 5th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_4 \
		UINT32_C(0x10)
	/*
	 * When this bit is '1', it indicates 6th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_5 \
		UINT32_C(0x20)
	/*
	 * When this bit is '1', it indicates 7th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_6 \
		UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates 8th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_7 \
		UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates 9th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_8 \
		UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates 10th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_9 \
		UINT32_C(0x200)
	/*
	 * When this bit is '1', it indicates 11th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_10 \
		UINT32_C(0x400)
	/*
	 * When this bit is '1', it indicates 12th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_11 \
		UINT32_C(0x800)
	/*
	 * When this bit is '1', it indicates 13th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_12 \
		UINT32_C(0x1000)
	/*
	 * When this bit is '1', it indicates 14th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_13 \
		UINT32_C(0x2000)
	/*
	 * When this bit is '1', it indicates 15th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_14 \
		UINT32_C(0x4000)
	/*
	 * When this bit is '1', it indicates 16th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_15 \
		UINT32_C(0x8000)
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_func_spd_cfg *
 *********************/


/* hwrm_func_spd_cfg_input (size:384b/48B) */
struct hwrm_func_spd_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* Set this bit is '1' to enable the SPD datapath forwarding. */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_FWD_ENABLE       UINT32_C(0x1)
	/* Set this bit is '1' to disable the SPD datapath forwarding. */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_FWD_DISABLE      UINT32_C(0x2)
	/*
	 * Set this bit is '1' to enable the SPD datapath checksum
	 * feature.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_CSUM_ENABLE      UINT32_C(0x4)
	/*
	 * Set this bit is '1' to disable the SPD datapath checksum
	 * feature.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_CSUM_DISABLE     UINT32_C(0x8)
	/*
	 * Set this bit is '1' to enable the SPD datapath debug
	 * feature.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_DBG_ENABLE       UINT32_C(0x10)
	/*
	 * Set this bit is '1' to disable the SPD datapath debug
	 * feature.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_DBG_DISABLE      UINT32_C(0x20)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the ethertype field to be
	 * configured.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_ENABLES_ETHERTYPE \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the hash_mode_flags field to be
	 * configured.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_ENABLES_HASH_MODE_FLAGS \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the hash_type field to be
	 * configured.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_ENABLES_HASH_TYPE \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the ring_tbl_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_ENABLES_RING_TBL_ADDR \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the hash_key_tbl_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_ENABLES_HASH_KEY_TBL_ADDR \
		UINT32_C(0x10)
	/*
	 * Ethertype value used in the encapsulated SPD packet header.
	 * The user must choose a value that is not conflicting with
	 * publicly defined ethertype values. By default, the ethertype
	 * value of 0xffff is used if there is no user specified value.
	 */
	uint16_t	ethertype;
	/* Flags to specify different RSS hash modes. */
	uint8_t	hash_mode_flags;
	/*
	 * When this bit is '1', it indicates using current RSS
	 * hash mode setting configured in the device.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_MODE_FLAGS_DEFAULT \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 4 tuples {l3.src, l3.dest,
	 * l4.src, l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_MODE_FLAGS_INNERMOST_4 \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 2 tuples {l3.src, l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_MODE_FLAGS_INNERMOST_2 \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 4 tuples {t_l3.src, t_l3.dest,
	 * t_l4.src, t_l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_MODE_FLAGS_OUTERMOST_4 \
		UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 2 tuples {t_l3.src, t_l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_MODE_FLAGS_OUTERMOST_2 \
		UINT32_C(0x10)
	uint8_t	unused_1;
	uint32_t	hash_type;
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv4
	 * packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_IPV4         UINT32_C(0x1)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of TCP/IPv4 packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_TCP_IPV4     UINT32_C(0x2)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of UDP/IPv4 packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_UDP_IPV4     UINT32_C(0x4)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv6
	 * packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_IPV6         UINT32_C(0x8)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of TCP/IPv6 packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_TCP_IPV6     UINT32_C(0x10)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of UDP/IPv6 packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_UDP_IPV6     UINT32_C(0x20)
	/* This is the address for rss ring group table */
	uint64_t	ring_grp_tbl_addr;
	/* This is the address for rss hash key table */
	uint64_t	hash_key_tbl_addr;
} __rte_packed;

/* hwrm_func_spd_cfg_output (size:128b/16B) */
struct hwrm_func_spd_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_func_spd_qcfg *
 **********************/


/* hwrm_func_spd_qcfg_input (size:128b/16B) */
struct hwrm_func_spd_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_func_spd_qcfg_output (size:512b/64B) */
struct hwrm_func_spd_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * The SPD datapath forwarding is currently enabled when this
	 * flag is set to '1'.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_FLAGS_FWD_ENABLED      UINT32_C(0x1)
	/*
	 * The SPD datapath checksum feature is currently enabled when
	 * this flag is set to '1'.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_FLAGS_CSUM_ENABLED     UINT32_C(0x2)
	/*
	 * The SPD datapath debug feature is currently enabled when
	 * this flag is set to '1'.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_FLAGS_DBG_ENABLED      UINT32_C(0x4)
	uint32_t	hash_type;
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv4
	 * packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_IPV4         UINT32_C(0x1)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of TCP/IPv4 packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_TCP_IPV4     UINT32_C(0x2)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of UDP/IPv4 packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_UDP_IPV4     UINT32_C(0x4)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv6
	 * packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_IPV6         UINT32_C(0x8)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of TCP/IPv6 packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_TCP_IPV6     UINT32_C(0x10)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of UDP/IPv6 packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_UDP_IPV6     UINT32_C(0x20)
	/* This is the value of rss hash key */
	uint32_t	hash_key[10];
	/* Flags to specify different RSS hash modes. */
	uint8_t	hash_mode_flags;
	/*
	 * When this bit is '1', it indicates using current RSS
	 * hash mode setting configured in the device.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_MODE_FLAGS_DEFAULT \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 4 tuples {l3.src, l3.dest,
	 * l4.src, l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_MODE_FLAGS_INNERMOST_4 \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 2 tuples {l3.src, l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_MODE_FLAGS_INNERMOST_2 \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 4 tuples {t_l3.src, t_l3.dest,
	 * t_l4.src, t_l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_MODE_FLAGS_OUTERMOST_4 \
		UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 2 tuples {t_l3.src, t_l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_MODE_FLAGS_OUTERMOST_2 \
		UINT32_C(0x10)
	uint8_t	unused_1;
	/*
	 * Ethertype value used in the encapsulated SPD packet header.
	 * The user must choose a value that is not conflicting with
	 * publicly defined ethertype values. By default, the ethertype
	 * value of 0xffff is used if there is no user specified value.
	 */
	uint16_t	ethertype;
	uint8_t	unused_2[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_port_phy_cfg *
 *********************/


/* hwrm_port_phy_cfg_input (size:448b/56B) */
struct hwrm_port_phy_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is set to '1', the PHY for the port shall
	 * be reset.
	 *
	 * # If this bit is set to 1, then the HWRM shall reset the
	 * PHY after applying PHY configuration changes specified
	 * in this command.
	 * # In order to guarantee that PHY configuration changes
	 * specified in this command take effect, the HWRM
	 * client should set this flag to 1.
	 * # If this bit is not set to 1, then the HWRM may reset
	 * the PHY depending on the current PHY configuration and
	 * settings specified in this command.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_RESET_PHY \
		UINT32_C(0x1)
	/* deprecated bit.  Do not use!!! */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_DEPRECATED \
		UINT32_C(0x2)
	/*
	 * When this bit is set to '1', and the force_pam4_link_speed
	 * bit in the 'enables' field is '0', the link shall be forced
	 * to the force_link_speed value.
	 *
	 * When this bit is set to '1', and the force_pam4_link_speed
	 * bit in the 'enables' field is '1', the link shall be forced
	 * to the force_pam4_link_speed value.
	 *
	 * When this bit is set to '1', the HWRM client should
	 * not enable any of the auto negotiation related
	 * fields represented by auto_XXX fields in this command.
	 * When this bit is set to '1' and the HWRM client has
	 * enabled a auto_XXX field in this command, then the
	 * HWRM shall ignore the enabled auto_XXX field.
	 *
	 * When this bit is set to zero, the link
	 * shall be allowed to autoneg.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FORCE \
		UINT32_C(0x4)
	/*
	 * When this bit is set to '1', the auto-negotiation process
	 * shall be restarted on the link.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_RESTART_AUTONEG \
		UINT32_C(0x8)
	/*
	 * When this bit is set to '1', Energy Efficient Ethernet
	 * (EEE) is requested to be enabled on this link.
	 * If EEE is not supported on this port, then this flag
	 * shall be ignored by the HWRM.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_EEE_ENABLE \
		UINT32_C(0x10)
	/*
	 * When this bit is set to '1', Energy Efficient Ethernet
	 * (EEE) is requested to be disabled on this link.
	 * If EEE is not supported on this port, then this flag
	 * shall be ignored by the HWRM.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_EEE_DISABLE \
		UINT32_C(0x20)
	/*
	 * When this bit is set to '1' and EEE is enabled on this
	 * link, then TX LPI is requested to be enabled on the link.
	 * If EEE is not supported on this port, then this flag
	 * shall be ignored by the HWRM.
	 * If EEE is disabled on this port, then this flag shall be
	 * ignored by the HWRM.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_EEE_TX_LPI_ENABLE \
		UINT32_C(0x40)
	/*
	 * When this bit is set to '1' and EEE is enabled on this
	 * link, then TX LPI is requested to be disabled on the link.
	 * If EEE is not supported on this port, then this flag
	 * shall be ignored by the HWRM.
	 * If EEE is disabled on this port, then this flag shall be
	 * ignored by the HWRM.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_EEE_TX_LPI_DISABLE \
		UINT32_C(0x80)
	/*
	 * When set to 1, then the HWRM shall enable FEC autonegotitation
	 * on this port if supported.  When enabled, at least one of the
	 * FEC modes must be advertised by enabling the fec_clause_74_enable,
	 * fec_clause_91_enable, fec_rs544_1xn_enable, fec_rs544_ieee_enable,
	 * fec_rs272_1xn_enable, or fec_rs272_ieee_enable flag.  If none
	 * of the FEC mode is currently enabled, the HWRM shall choose
	 * a default advertisement setting.
	 * The default advertisement setting can be queried by calling
	 * hwrm_port_phy_qcfg.  Note that the link speed must be
	 * in autonegotiation mode for FEC autonegotiation to take effect.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC autonegotiation is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_AUTONEG_ENABLE \
		UINT32_C(0x100)
	/*
	 * When set to 1, then the HWRM shall disable FEC autonegotiation
	 * on this port and use forced FEC mode.  In forced FEC mode, one
	 * or more FEC forced settings under the same clause can be set.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC autonegotiation is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_AUTONEG_DISABLE \
		UINT32_C(0x200)
	/*
	 * When set to 1, then the HWRM shall enable FEC CLAUSE 74 (Fire Code)
	 * on this port if supported, by advertising FEC CLAUSE 74 if
	 * FEC autonegotiation is enabled or force enabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC CLAUSE 74 is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_CLAUSE74_ENABLE \
		UINT32_C(0x400)
	/*
	 * When set to 1, then the HWRM shall disable FEC CLAUSE 74 (Fire Code)
	 * on this port if supported, by not advertising FEC CLAUSE 74 if
	 * FEC autonegotiation is enabled or force disabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC CLAUSE 74 is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_CLAUSE74_DISABLE \
		UINT32_C(0x800)
	/*
	 * When set to 1, then the HWRM shall enable FEC CLAUSE 91
	 * (Reed Solomon RS(528,514) for NRZ) on this port if supported,
	 * by advertising FEC RS(528,514) if FEC autonegotiation is enabled
	 * or force enabled otherwise.  In forced FEC mode, this flag
	 * will only take effect if the speed is NRZ.  Additional
	 * RS544 or RS272 flags (also under clause 91) may be set for PAM4
	 * in forced FEC mode.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS(528,514) is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_CLAUSE91_ENABLE \
		UINT32_C(0x1000)
	/*
	 * When set to 1, then the HWRM shall disable FEC CLAUSE 91
	 * (Reed Solomon RS(528,514) for NRZ) on this port if supported, by
	 * not advertising RS(528,514) if FEC autonegotiation is enabled or
	 * force disabled otherwise.  When set to 0, then this flag shall be
	 * ignored.  If FEC RS(528,514) is not supported, then the HWRM
	 * shall ignore this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_CLAUSE91_DISABLE \
		UINT32_C(0x2000)
	/*
	 * When this bit is set to '1', the link shall be forced to
	 * be taken down.
	 *
	 * # When this bit is set to '1", all other
	 * command input settings related to the link speed shall
	 * be ignored.
	 * Once the link state is forced down, it can be
	 * explicitly cleared from that state by setting this flag
	 * to '0'.
	 * # If this flag is set to '0', then the link shall be
	 * cleared from forced down state if the link is in forced
	 * down state.
	 * There may be conditions (e.g. out-of-band or sideband
	 * configuration changes for the link) outside the scope
	 * of the HWRM implementation that may clear forced down
	 * link state.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FORCE_LINK_DWN \
		UINT32_C(0x4000)
	/*
	 * When set to 1, then the HWRM shall enable FEC RS544_1XN
	 * on this port if supported, by advertising FEC RS544_1XN if
	 * FEC autonegotiation is enabled or force enabled otherwise.
	 * In forced mode, this flag will only take effect if the speed is
	 * PAM4.  If this flag and fec_rs544_ieee_enable are set, the
	 * HWRM shall choose one of the RS544 modes.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS544_1XN is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS544_1XN_ENABLE \
		UINT32_C(0x8000)
	/*
	 * When set to 1, then the HWRM shall disable FEC RS544_1XN
	 * on this port if supported, by not advertising FEC RS544_1XN if
	 * FEC autonegotiation is enabled or force disabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS544_1XN  is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS544_1XN_DISABLE \
		UINT32_C(0x10000)
	/*
	 * When set to 1, then the HWRM shall enable FEC RS(544,514)
	 * on this port if supported, by advertising FEC RS(544,514) if
	 * FEC autonegotiation is enabled or force enabled otherwise.
	 * In forced mode, this flag will only take effect if the speed is
	 * PAM4.  If this flag and fec_rs544_1xn_enable are set, the
	 * HWRM shall choose one of the RS544 modes.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS(544,514) is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS544_IEEE_ENABLE \
		UINT32_C(0x20000)
	/*
	 * When set to 1, then the HWRM shall disable FEC RS(544,514)
	 * on this port if supported, by not advertising FEC RS(544,514) if
	 * FEC autonegotiation is enabled or force disabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS(544,514) is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS544_IEEE_DISABLE \
		UINT32_C(0x40000)
	/*
	 * When set to 1, then the HWRM shall enable FEC RS272_1XN
	 * on this port if supported, by advertising FEC RS272_1XN if
	 * FEC autonegotiation is enabled or force enabled otherwise.
	 * In forced mode, this flag will only take effect if the speed is
	 * PAM4.  If this flag and fec_rs272_ieee_enable are set, the
	 * HWRM shall choose one of the RS272 modes.  Note that RS272
	 * and RS544 modes cannot be set at the same time in forced FEC mode.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS272_1XN is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS272_1XN_ENABLE \
		UINT32_C(0x80000)
	/*
	 * When set to 1, then the HWRM shall disable FEC RS272_1XN
	 * on this port if supported, by not advertising FEC RS272_1XN if
	 * FEC autonegotiation is enabled or force disabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS272_1XN is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS272_1XN_DISABLE \
		UINT32_C(0x100000)
	/*
	 * When set to 1, then the HWRM shall enable FEC RS(272,257)
	 * on this port if supported, by advertising FEC RS(272,257) if
	 * FEC autonegotiation is enabled or force enabled otherwise.
	 * In forced mode, this flag will only take effect if the speed is
	 * PAM4.  If this flag and fec_rs272_1xn_enable are set, the
	 * HWRM shall choose one of the RS272 modes.  Note that RS272
	 * and RS544 modes cannot be set at the same time in forced FEC mode.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS(272,257) is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS272_IEEE_ENABLE \
		UINT32_C(0x200000)
	/*
	 * When set to 1, then the HWRM shall disable FEC RS(272,257)
	 * on this port if supported, by not advertising FEC RS(272,257) if
	 * FEC autonegotiation is enabled or force disabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS(272,257) is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS272_IEEE_DISABLE \
		UINT32_C(0x400000)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the auto_mode field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_MODE \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the auto_duplex field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_DUPLEX \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the auto_pause field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_PAUSE \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the auto_link_speed field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_LINK_SPEED \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the auto_link_speed_mask field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_LINK_SPEED_MASK \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the wirespeed field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_WIRESPEED \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the lpbk field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_LPBK \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the preemphasis field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_PREEMPHASIS \
		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the force_pause field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_FORCE_PAUSE \
		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the eee_link_speed_mask field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_EEE_LINK_SPEED_MASK \
		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the tx_lpi_timer field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_TX_LPI_TIMER \
		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the force_pam4_link_speed field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_FORCE_PAM4_LINK_SPEED \
		UINT32_C(0x800)
	/*
	 * This bit must be '1' for the auto_pam4_link_speed_mask field to
	 * be configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_PAM4_LINK_SPEED_MASK \
		UINT32_C(0x1000)
	/* Port ID of port that is to be configured. */
	uint16_t	port_id;
	/*
	 * This is the speed that will be used if the force
	 * bit is '1'.  If unsupported speed is selected, an error
	 * will be generated.
	 */
	uint16_t	force_link_speed;
	/* 100Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_100MB UINT32_C(0x1)
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_1GB   UINT32_C(0xa)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_2GB   UINT32_C(0x14)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_2_5GB UINT32_C(0x19)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_10GB  UINT32_C(0x64)
	/* 20Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_20GB  UINT32_C(0xc8)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_25GB  UINT32_C(0xfa)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_40GB  UINT32_C(0x190)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 10Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_10MB  UINT32_C(0xffff)
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_LAST \
		HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_10MB
	/*
	 * This value is used to identify what autoneg mode is
	 * used when the link speed is not being forced.
	 */
	uint8_t	auto_mode;
	/* Disable autoneg or autoneg disabled. No speeds are selected. */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_NONE         UINT32_C(0x0)
	/* Select all possible speeds for autoneg mode. */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_ALL_SPEEDS   UINT32_C(0x1)
	/*
	 * Select only the auto_link_speed speed for autoneg mode. This mode has
	 * been DEPRECATED. An HWRM client should not use this mode.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_ONE_SPEED    UINT32_C(0x2)
	/*
	 * Select the auto_link_speed or any speed below that speed for autoneg.
	 * This mode has been DEPRECATED. An HWRM client should not use this mode.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_ONE_OR_BELOW UINT32_C(0x3)
	/*
	 * Select the speeds based on the corresponding link speed mask values
	 * that are provided. The included speeds are specified in the
	 * auto_link_speed and auto_pam4_link_speed fields.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_SPEED_MASK   UINT32_C(0x4)
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_LAST \
		HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_SPEED_MASK
	/*
	 * This is the duplex setting that will be used if the autoneg_mode
	 * is "one_speed" or "one_or_below".
	 */
	uint8_t	auto_duplex;
	/* Half Duplex will be requested. */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_HALF UINT32_C(0x0)
	/* Full duplex will be requested. */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_FULL UINT32_C(0x1)
	/* Both Half and Full duplex will be requested. */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_BOTH UINT32_C(0x2)
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_LAST \
		HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_BOTH
	/*
	 * This value is used to configure the pause that will be
	 * used for autonegotiation.
	 * Add text on the usage of auto_pause and force_pause.
	 */
	uint8_t	auto_pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * has been requested. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_PAUSE_TX \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * has been requested. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_PAUSE_RX \
		UINT32_C(0x2)
	/*
	 * When set to 1, the advertisement of pause is enabled.
	 *
	 * # When the auto_mode is not set to none and this flag is
	 * set to 1, then the auto_pause bits on this port are being
	 * advertised and autoneg pause results are being interpreted.
	 * # When the auto_mode is not set to none and this
	 * flag is set to 0, the pause is forced as indicated in
	 * force_pause, and also advertised as auto_pause bits, but
	 * the autoneg results are not interpreted since the pause
	 * configuration is being forced.
	 * # When the auto_mode is set to none and this flag is set to
	 * 1, auto_pause bits should be ignored and should be set to 0.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_PAUSE_AUTONEG_PAUSE \
		UINT32_C(0x4)
	uint8_t	unused_0;
	/*
	 * This is the speed that will be used if the autoneg_mode
	 * is "one_speed" or "one_or_below".  If an unsupported speed
	 * is selected, an error will be generated.
	 */
	uint16_t	auto_link_speed;
	/* 100Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_100MB UINT32_C(0x1)
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_1GB   UINT32_C(0xa)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_2GB   UINT32_C(0x14)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_2_5GB UINT32_C(0x19)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_10GB  UINT32_C(0x64)
	/* 20Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_20GB  UINT32_C(0xc8)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_25GB  UINT32_C(0xfa)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_40GB  UINT32_C(0x190)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 10Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_10MB  UINT32_C(0xffff)
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_LAST \
		HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_10MB
	/*
	 * This is a mask of link speeds that will be used if
	 * autoneg_mode is "mask".  If unsupported speed is enabled
	 * an error will be generated.
	 */
	uint16_t	auto_link_speed_mask;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_100MBHD \
		UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_100MB \
		UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_1GBHD \
		UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_1GB \
		UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_2GB \
		UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_2_5GB \
		UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_10GB \
		UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_20GB \
		UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_25GB \
		UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_40GB \
		UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_50GB \
		UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_100GB \
		UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_10MBHD \
		UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_10MB \
		UINT32_C(0x2000)
	/* This value controls the wirespeed feature. */
	uint8_t	wirespeed;
	/* Wirespeed feature is disabled. */
	#define HWRM_PORT_PHY_CFG_INPUT_WIRESPEED_OFF UINT32_C(0x0)
	/* Wirespeed feature is enabled. */
	#define HWRM_PORT_PHY_CFG_INPUT_WIRESPEED_ON  UINT32_C(0x1)
	#define HWRM_PORT_PHY_CFG_INPUT_WIRESPEED_LAST \
		HWRM_PORT_PHY_CFG_INPUT_WIRESPEED_ON
	/* This value controls the loopback setting for the PHY. */
	uint8_t	lpbk;
	/* No loopback is selected.  Normal operation. */
	#define HWRM_PORT_PHY_CFG_INPUT_LPBK_NONE     UINT32_C(0x0)
	/*
	 * The HW will be configured with local loopback such that
	 * host data is sent back to the host without modification.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_LPBK_LOCAL    UINT32_C(0x1)
	/*
	 * The HW will be configured with remote loopback such that
	 * port logic will send packets back out the transmitter that
	 * are received.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_LPBK_REMOTE   UINT32_C(0x2)
	/*
	 * The HW will be configured with external loopback such that
	 * host data is sent on the transmitter and based on the external
	 * loopback connection the data will be received without modification.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_LPBK_EXTERNAL UINT32_C(0x3)
	#define HWRM_PORT_PHY_CFG_INPUT_LPBK_LAST \
		HWRM_PORT_PHY_CFG_INPUT_LPBK_EXTERNAL
	/*
	 * This value is used to configure the pause that will be
	 * used for force mode.
	 */
	uint8_t	force_pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAUSE_TX     UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAUSE_RX     UINT32_C(0x2)
	uint8_t	unused_1;
	/*
	 * This value controls the pre-emphasis to be used for the
	 * link.  Driver should not set this value (use
	 * enable.preemphasis = 0) unless driver is sure of setting.
	 * Normally HWRM FW will determine proper pre-emphasis.
	 */
	uint32_t	preemphasis;
	/*
	 * Setting for link speed mask that is used to
	 * advertise speeds during autonegotiation when EEE is enabled.
	 * This field is valid only when EEE is enabled.
	 * The speeds specified in this field shall be a subset of
	 * speeds specified in auto_link_speed_mask.
	 * If EEE is enabled,then at least one speed shall be provided
	 * in this mask.
	 */
	uint16_t	eee_link_speed_mask;
	/* Reserved */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_RSVD1 \
		UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_100MB \
		UINT32_C(0x2)
	/* Reserved */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_RSVD2 \
		UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_1GB \
		UINT32_C(0x8)
	/* Reserved */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_RSVD3 \
		UINT32_C(0x10)
	/* Reserved */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_RSVD4 \
		UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_10GB \
		UINT32_C(0x40)
	/*
	 * This is the speed that will be used if the force and force_pam4
	 * bits are '1'.  If unsupported speed is selected, an error
	 * will be generated.
	 */
	uint16_t	force_pam4_link_speed;
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAM4_LINK_SPEED_50GB \
		UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAM4_LINK_SPEED_100GB \
		UINT32_C(0x3e8)
	/* 200Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAM4_LINK_SPEED_200GB \
		UINT32_C(0x7d0)
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAM4_LINK_SPEED_LAST \
		HWRM_PORT_PHY_CFG_INPUT_FORCE_PAM4_LINK_SPEED_200GB
	/*
	 * Requested setting of TX LPI timer in microseconds.
	 * This field is valid only when EEE is enabled and TX LPI is
	 * enabled.
	 */
	uint32_t	tx_lpi_timer;
	#define HWRM_PORT_PHY_CFG_INPUT_TX_LPI_TIMER_MASK UINT32_C(0xffffff)
	#define HWRM_PORT_PHY_CFG_INPUT_TX_LPI_TIMER_SFT 0
	/* This field specifies which PAM4 speeds are enabled for auto mode. */
	uint16_t	auto_link_pam4_speed_mask;
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_PAM4_SPEED_MASK_50G \
		UINT32_C(0x1)
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_PAM4_SPEED_MASK_100G \
		UINT32_C(0x2)
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_PAM4_SPEED_MASK_200G \
		UINT32_C(0x4)
	uint8_t	unused_2[2];
} __rte_packed;

/* hwrm_port_phy_cfg_output (size:128b/16B) */
struct hwrm_port_phy_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* hwrm_port_phy_cfg_cmd_err (size:64b/8B) */
struct hwrm_port_phy_cfg_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_PORT_PHY_CFG_CMD_ERR_CODE_UNKNOWN       UINT32_C(0x0)
	/* Unable to complete operation due to invalid speed */
	#define HWRM_PORT_PHY_CFG_CMD_ERR_CODE_ILLEGAL_SPEED UINT32_C(0x1)
	/*
	 * retry the command since the phy is not ready.
	 * retry count is returned in opaque_0.
	 * This is only valid for the first command and
	 * this value will not change for successive calls.
	 * but if a 0 is returned at any time then this should
	 * be treated as an un recoverable failure,
	 *
	 * retry interval in milli seconds is returned in opaque_1.
	 * This specifies the time that user should wait before
	 * issuing the next port_phy_cfg command.
	 */
	#define HWRM_PORT_PHY_CFG_CMD_ERR_CODE_RETRY         UINT32_C(0x2)
	#define HWRM_PORT_PHY_CFG_CMD_ERR_CODE_LAST \
		HWRM_PORT_PHY_CFG_CMD_ERR_CODE_RETRY
	uint8_t	unused_0[7];
} __rte_packed;

/**********************
 * hwrm_port_phy_qcfg *
 **********************/


/* hwrm_port_phy_qcfg_input (size:192b/24B) */
struct hwrm_port_phy_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is to be queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_port_phy_qcfg_output (size:832b/104B) */
struct hwrm_port_phy_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value indicates the current link status. */
	uint8_t	link;
	/* There is no link or cable detected. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_NO_LINK UINT32_C(0x0)
	/* There is no link, but a cable has been detected. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SIGNAL  UINT32_C(0x1)
	/* There is a link. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_LINK    UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_LINK_LINK
	uint8_t	active_fec_signal_mode;
	/*
	 * This value indicates the current link signaling mode of the
	 * connection.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_MASK \
		UINT32_C(0xf)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_SFT                 0
	/* NRZ signaling */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_NRZ \
		UINT32_C(0x0)
	/* PAM4 signaling */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_PAM4 \
		UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_PAM4
	/* This value indicates the current active FEC mode. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_MASK \
		UINT32_C(0xf0)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_SFT                  4
	/* No active FEC */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_NONE_ACTIVE \
		(UINT32_C(0x0) << 4)
	/* FEC CLAUSE 74 (Fire Code) active, autonegotiated or forced. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_CLAUSE74_ACTIVE \
		(UINT32_C(0x1) << 4)
	/* FEC CLAUSE 91 RS(528,514) active, autonegoatiated or forced. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_CLAUSE91_ACTIVE \
		(UINT32_C(0x2) << 4)
	/* FEC RS544_1XN active, autonegoatiated or forced. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_RS544_1XN_ACTIVE \
		(UINT32_C(0x3) << 4)
	/* FEC RS(544,528) active, autonegoatiated or forced. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_RS544_IEEE_ACTIVE \
		(UINT32_C(0x4) << 4)
	/* FEC RS272_1XN active, autonegotiated or forced. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_RS272_1XN_ACTIVE \
		(UINT32_C(0x5) << 4)
	/* FEC RS(272,257) active, autonegoatiated or forced. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_RS272_IEEE_ACTIVE \
		(UINT32_C(0x6) << 4)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_RS272_IEEE_ACTIVE
	/*
	 * This value indicates the current link speed of the connection.
	 * The signal_mode field indicates if the link is using
	 * NRZ or PAM4 signaling.
	 */
	uint16_t	link_speed;
	/* 100Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_100MB UINT32_C(0x1)
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_1GB   UINT32_C(0xa)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_2GB   UINT32_C(0x14)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_2_5GB UINT32_C(0x19)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_10GB  UINT32_C(0x64)
	/* 20Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_20GB  UINT32_C(0xc8)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_25GB  UINT32_C(0xfa)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_40GB  UINT32_C(0x190)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 200Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_200GB UINT32_C(0x7d0)
	/* 10Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_10MB  UINT32_C(0xffff)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_10MB
	/*
	 * This value is indicates the duplex of the current
	 * configuration.
	 */
	uint8_t	duplex_cfg;
	/* Half Duplex connection. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_CFG_HALF UINT32_C(0x0)
	/* Full duplex connection. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_CFG_FULL UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_CFG_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_CFG_FULL
	/*
	 * This value is used to indicate the current
	 * pause configuration. When autoneg is enabled, this value
	 * represents the autoneg results of pause configuration.
	 */
	uint8_t	pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PAUSE_TX     UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PAUSE_RX     UINT32_C(0x2)
	/*
	 * The supported speeds for the port. This is a bit mask.
	 * For each speed that is supported, the corresponding
	 * bit will be set to '1'.
	 */
	uint16_t	support_speeds;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_100MBHD \
		UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_100MB \
		UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_1GBHD \
		UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_1GB \
		UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_2GB \
		UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_2_5GB \
		UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_10GB \
		UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_20GB \
		UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_25GB \
		UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_40GB \
		UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_50GB \
		UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_100GB \
		UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_10MBHD \
		UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_10MB \
		UINT32_C(0x2000)
	/*
	 * Current setting of forced link speed.
	 * When the link speed is not being forced, this
	 * value shall be set to 0.
	 */
	uint16_t	force_link_speed;
	/* 100Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_100MB UINT32_C(0x1)
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_1GB   UINT32_C(0xa)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_2GB   UINT32_C(0x14)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_2_5GB UINT32_C(0x19)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_10GB  UINT32_C(0x64)
	/* 20Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_20GB  UINT32_C(0xc8)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_25GB  UINT32_C(0xfa)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_40GB \
		UINT32_C(0x190)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_50GB \
		UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_100GB \
		UINT32_C(0x3e8)
	/* 10Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_10MB \
		UINT32_C(0xffff)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_10MB
	/* Current setting of auto negotiation mode. */
	uint8_t	auto_mode;
	/* Disable autoneg or autoneg disabled. No speeds are selected. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_NONE         UINT32_C(0x0)
	/* Select all possible speeds for autoneg mode. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_ALL_SPEEDS   UINT32_C(0x1)
	/*
	 * Select only the auto_link_speed speed for autoneg mode. This mode has
	 * been DEPRECATED. An HWRM client should not use this mode.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_ONE_SPEED    UINT32_C(0x2)
	/*
	 * Select the auto_link_speed or any speed below that speed for autoneg.
	 * This mode has been DEPRECATED. An HWRM client should not use this mode.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_ONE_OR_BELOW UINT32_C(0x3)
	/*
	 * Select the speeds based on the corresponding link speed mask value
	 * that is provided.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_SPEED_MASK   UINT32_C(0x4)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_SPEED_MASK
	/*
	 * Current setting of pause autonegotiation.
	 * Move autoneg_pause flag here.
	 */
	uint8_t	auto_pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * has been requested. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAUSE_TX \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * has been requested. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAUSE_RX \
		UINT32_C(0x2)
	/*
	 * When set to 1, the advertisement of pause is enabled.
	 *
	 * # When the auto_mode is not set to none and this flag is
	 * set to 1, then the auto_pause bits on this port are being
	 * advertised and autoneg pause results are being interpreted.
	 * # When the auto_mode is not set to none and this
	 * flag is set to 0, the pause is forced as indicated in
	 * force_pause, and also advertised as auto_pause bits, but
	 * the autoneg results are not interpreted since the pause
	 * configuration is being forced.
	 * # When the auto_mode is set to none and this flag is set to
	 * 1, auto_pause bits should be ignored and should be set to 0.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAUSE_AUTONEG_PAUSE \
		UINT32_C(0x4)
	/*
	 * Current setting for auto_link_speed. This field is only
	 * valid when auto_mode is set to "one_speed" or "one_or_below".
	 */
	uint16_t	auto_link_speed;
	/* 100Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_100MB UINT32_C(0x1)
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_1GB   UINT32_C(0xa)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_2GB   UINT32_C(0x14)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_2_5GB UINT32_C(0x19)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_10GB  UINT32_C(0x64)
	/* 20Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_20GB  UINT32_C(0xc8)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_25GB  UINT32_C(0xfa)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_40GB  UINT32_C(0x190)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 10Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_10MB \
		UINT32_C(0xffff)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_10MB
	/*
	 * Current setting for auto_link_speed_mask that is used to
	 * advertise speeds during autonegotiation.
	 * This field is only valid when auto_mode is set to "mask".
	 * The speeds specified in this field shall be a subset of
	 * supported speeds on this port.
	 */
	uint16_t	auto_link_speed_mask;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_100MBHD \
		UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_100MB \
		UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_1GBHD \
		UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_1GB \
		UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_2GB \
		UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_2_5GB \
		UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_10GB \
		UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_20GB \
		UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_25GB \
		UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_40GB \
		UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_50GB \
		UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_100GB \
		UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_10MBHD \
		UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_10MB \
		UINT32_C(0x2000)
	/* Current setting for wirespeed. */
	uint8_t	wirespeed;
	/* Wirespeed feature is disabled. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_WIRESPEED_OFF UINT32_C(0x0)
	/* Wirespeed feature is enabled. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_WIRESPEED_ON  UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_WIRESPEED_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_WIRESPEED_ON
	/* Current setting for loopback. */
	uint8_t	lpbk;
	/* No loopback is selected.  Normal operation. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_NONE     UINT32_C(0x0)
	/*
	 * The HW will be configured with local loopback such that
	 * host data is sent back to the host without modification.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_LOCAL    UINT32_C(0x1)
	/*
	 * The HW will be configured with remote loopback such that
	 * port logic will send packets back out the transmitter that
	 * are received.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_REMOTE   UINT32_C(0x2)
	/*
	 * The HW will be configured with external loopback such that
	 * host data is sent on the transmitter and based on the external
	 * loopback connection the data will be received without modification.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_EXTERNAL UINT32_C(0x3)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_EXTERNAL
	/*
	 * Current setting of forced pause.
	 * When the pause configuration is not being forced, then
	 * this value shall be set to 0.
	 */
	uint8_t	force_pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAUSE_TX     UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAUSE_RX     UINT32_C(0x2)
	/*
	 * This value indicates the current status of the optics module on
	 * this port.
	 */
	uint8_t	module_status;
	/* Module is inserted and accepted */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_NONE \
		UINT32_C(0x0)
	/* Module is rejected and transmit side Laser is disabled. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_DISABLETX \
		UINT32_C(0x1)
	/* Module mismatch warning. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_WARNINGMSG \
		UINT32_C(0x2)
	/* Module is rejected and powered down. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_PWRDOWN \
		UINT32_C(0x3)
	/* Module is not inserted. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_NOTINSERTED \
		UINT32_C(0x4)
	/* Module is powered down because of over current fault. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_CURRENTFAULT \
		UINT32_C(0x5)
	/* Module status is not applicable. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_NOTAPPLICABLE \
		UINT32_C(0xff)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_NOTAPPLICABLE
	/* Current setting for preemphasis. */
	uint32_t	preemphasis;
	/* This field represents the major version of the PHY. */
	uint8_t	phy_maj;
	/* This field represents the minor version of the PHY. */
	uint8_t	phy_min;
	/* This field represents the build version of the PHY. */
	uint8_t	phy_bld;
	/* This value represents a PHY type. */
	uint8_t	phy_type;
	/* Unknown */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_UNKNOWN \
		UINT32_C(0x0)
	/* BASE-CR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASECR \
		UINT32_C(0x1)
	/* BASE-KR4 (Deprecated) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASEKR4 \
		UINT32_C(0x2)
	/* BASE-LR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASELR \
		UINT32_C(0x3)
	/* BASE-SR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASESR \
		UINT32_C(0x4)
	/* BASE-KR2 (Deprecated) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASEKR2 \
		UINT32_C(0x5)
	/* BASE-KX */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASEKX \
		UINT32_C(0x6)
	/* BASE-KR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASEKR \
		UINT32_C(0x7)
	/* BASE-T */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASET \
		UINT32_C(0x8)
	/* EEE capable BASE-T */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASETE \
		UINT32_C(0x9)
	/* SGMII connected external PHY */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_SGMIIEXTPHY \
		UINT32_C(0xa)
	/* 25G_BASECR_CA_L */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_25G_BASECR_CA_L \
		UINT32_C(0xb)
	/* 25G_BASECR_CA_S */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_25G_BASECR_CA_S \
		UINT32_C(0xc)
	/* 25G_BASECR_CA_N */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_25G_BASECR_CA_N \
		UINT32_C(0xd)
	/* 25G_BASESR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_25G_BASESR \
		UINT32_C(0xe)
	/* 100G_BASECR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASECR4 \
		UINT32_C(0xf)
	/* 100G_BASESR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASESR4 \
		UINT32_C(0x10)
	/* 100G_BASELR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASELR4 \
		UINT32_C(0x11)
	/* 100G_BASEER4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASEER4 \
		UINT32_C(0x12)
	/* 100G_BASESR10 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASESR10 \
		UINT32_C(0x13)
	/* 40G_BASECR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_BASECR4 \
		UINT32_C(0x14)
	/* 40G_BASESR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_BASESR4 \
		UINT32_C(0x15)
	/* 40G_BASELR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_BASELR4 \
		UINT32_C(0x16)
	/* 40G_BASEER4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_BASEER4 \
		UINT32_C(0x17)
	/* 40G_ACTIVE_CABLE */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_ACTIVE_CABLE \
		UINT32_C(0x18)
	/* 1G_baseT */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_1G_BASET \
		UINT32_C(0x19)
	/* 1G_baseSX */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_1G_BASESX \
		UINT32_C(0x1a)
	/* 1G_baseCX */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_1G_BASECX \
		UINT32_C(0x1b)
	/* 200G_BASECR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASECR4 \
		UINT32_C(0x1c)
	/* 200G_BASESR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASESR4 \
		UINT32_C(0x1d)
	/* 200G_BASELR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASELR4 \
		UINT32_C(0x1e)
	/* 200G_BASEER4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASEER4 \
		UINT32_C(0x1f)
	/* 50G_BASECR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_50G_BASECR \
		UINT32_C(0x20)
	/* 50G_BASESR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_50G_BASESR \
		UINT32_C(0x21)
	/* 50G_BASELR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_50G_BASELR \
		UINT32_C(0x22)
	/* 50G_BASEER */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_50G_BASEER \
		UINT32_C(0x23)
	/* 100G_BASECR2 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASECR2 \
		UINT32_C(0x24)
	/* 100G_BASESR2 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASESR2 \
		UINT32_C(0x25)
	/* 100G_BASELR2 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASELR2 \
		UINT32_C(0x26)
	/* 100G_BASEER2 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASEER2 \
		UINT32_C(0x27)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASEER2
	/* This value represents a media type. */
	uint8_t	media_type;
	/* Unknown */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_UNKNOWN UINT32_C(0x0)
	/* Twisted Pair */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_TP      UINT32_C(0x1)
	/* Direct Attached Copper */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_DAC     UINT32_C(0x2)
	/* Fiber */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_FIBRE   UINT32_C(0x3)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_FIBRE
	/* This value represents a transceiver type. */
	uint8_t	xcvr_pkg_type;
	/* PHY and MAC are in the same package */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_PKG_TYPE_XCVR_INTERNAL \
		UINT32_C(0x1)
	/* PHY and MAC are in different packages */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_PKG_TYPE_XCVR_EXTERNAL \
		UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_PKG_TYPE_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_PKG_TYPE_XCVR_EXTERNAL
	uint8_t	eee_config_phy_addr;
	/* This field represents PHY address. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_ADDR_MASK \
		UINT32_C(0x1f)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_ADDR_SFT               0
	/*
	 * This field represents flags related to EEE configuration.
	 * These EEE configuration flags are valid only when the
	 * auto_mode is not set to none (in other words autonegotiation
	 * is enabled).
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_MASK \
		UINT32_C(0xe0)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_SFT             5
	/*
	 * When set to 1, Energy Efficient Ethernet (EEE) mode is enabled.
	 * Speeds for autoneg with EEE mode enabled
	 * are based on eee_link_speed_mask.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_EEE_ENABLED \
		UINT32_C(0x20)
	/*
	 * This flag is valid only when eee_enabled is set to 1.
	 *
	 * # If eee_enabled is set to 0, then EEE mode is disabled
	 * and this flag shall be ignored.
	 * # If eee_enabled is set to 1 and this flag is set to 1,
	 * then Energy Efficient Ethernet (EEE) mode is enabled
	 * and in use.
	 * # If eee_enabled is set to 1 and this flag is set to 0,
	 * then Energy Efficient Ethernet (EEE) mode is enabled
	 * but is currently not in use.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_EEE_ACTIVE \
		UINT32_C(0x40)
	/*
	 * This flag is valid only when eee_enabled is set to 1.
	 *
	 * # If eee_enabled is set to 0, then EEE mode is disabled
	 * and this flag shall be ignored.
	 * # If eee_enabled is set to 1 and this flag is set to 1,
	 * then Energy Efficient Ethernet (EEE) mode is enabled
	 * and TX LPI is enabled.
	 * # If eee_enabled is set to 1 and this flag is set to 0,
	 * then Energy Efficient Ethernet (EEE) mode is enabled
	 * but TX LPI is disabled.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_EEE_TX_LPI \
		UINT32_C(0x80)
	/*
	 * When set to 1, the parallel detection is used to determine
	 * the speed of the link partner.
	 *
	 * Parallel detection is used when a autonegotiation capable
	 * device is connected to a link partner that is not capable
	 * of autonegotiation.
	 */
	uint8_t	parallel_detect;
	/*
	 * When set to 1, the parallel detection is used to determine
	 * the speed of the link partner.
	 *
	 * Parallel detection is used when a autonegotiation capable
	 * device is connected to a link partner that is not capable
	 * of autonegotiation.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PARALLEL_DETECT     UINT32_C(0x1)
	/*
	 * The advertised speeds for the port by the link partner.
	 * Each advertised speed will be set to '1'.
	 */
	uint16_t	link_partner_adv_speeds;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_100MBHD \
		UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_100MB \
		UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_1GBHD \
		UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_1GB \
		UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_2GB \
		UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_2_5GB \
		UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_10GB \
		UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_20GB \
		UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_25GB \
		UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_40GB \
		UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_50GB \
		UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_100GB \
		UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_10MBHD \
		UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_10MB \
		UINT32_C(0x2000)
	/*
	 * The advertised autoneg for the port by the link partner.
	 * This field is deprecated and should be set to 0.
	 */
	uint8_t	link_partner_adv_auto_mode;
	/* Disable autoneg or autoneg disabled. No speeds are selected. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_NONE \
		UINT32_C(0x0)
	/* Select all possible speeds for autoneg mode. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_ALL_SPEEDS \
		UINT32_C(0x1)
	/*
	 * Select only the auto_link_speed speed for autoneg mode. This mode has
	 * been DEPRECATED. An HWRM client should not use this mode.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_ONE_SPEED \
		UINT32_C(0x2)
	/*
	 * Select the auto_link_speed or any speed below that speed for autoneg.
	 * This mode has been DEPRECATED. An HWRM client should not use this mode.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_ONE_OR_BELOW \
		UINT32_C(0x3)
	/*
	 * Select the speeds based on the corresponding link speed mask value
	 * that is provided.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_SPEED_MASK \
		UINT32_C(0x4)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_SPEED_MASK
	/* The advertised pause settings on the port by the link partner. */
	uint8_t	link_partner_adv_pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_PAUSE_TX \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_PAUSE_RX \
		UINT32_C(0x2)
	/*
	 * Current setting for link speed mask that is used to
	 * advertise speeds during autonegotiation when EEE is enabled.
	 * This field is valid only when eee_enabled flags is set to 1.
	 * The speeds specified in this field shall be a subset of
	 * speeds specified in auto_link_speed_mask.
	 */
	uint16_t	adv_eee_link_speed_mask;
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_RSVD1 \
		UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_100MB \
		UINT32_C(0x2)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_RSVD2 \
		UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_1GB \
		UINT32_C(0x8)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_RSVD3 \
		UINT32_C(0x10)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_RSVD4 \
		UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_10GB \
		UINT32_C(0x40)
	/*
	 * Current setting for link speed mask that is advertised by
	 * the link partner when EEE is enabled.
	 * This field is valid only when eee_enabled flags is set to 1.
	 */
	uint16_t	link_partner_adv_eee_link_speed_mask;
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_RSVD1 \
		UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_100MB \
		UINT32_C(0x2)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_RSVD2 \
		UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_1GB \
		UINT32_C(0x8)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_RSVD3 \
		UINT32_C(0x10)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_RSVD4 \
		UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_10GB \
		UINT32_C(0x40)
	uint32_t	xcvr_identifier_type_tx_lpi_timer;
	/*
	 * Current setting of TX LPI timer in microseconds.
	 * This field is valid only when_eee_enabled flag is set to 1
	 * and tx_lpi_enabled is set to 1.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_TX_LPI_TIMER_MASK \
		UINT32_C(0xffffff)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_TX_LPI_TIMER_SFT             0
	/* This value represents transceiver identifier type. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_MASK \
		UINT32_C(0xff000000)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_SFT     24
	/* Unknown */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_UNKNOWN \
		(UINT32_C(0x0) << 24)
	/* SFP/SFP+/SFP28 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_SFP \
		(UINT32_C(0x3) << 24)
	/* QSFP+ */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_QSFP \
		(UINT32_C(0xc) << 24)
	/* QSFP+ */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_QSFPPLUS \
		(UINT32_C(0xd) << 24)
	/* QSFP28 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_QSFP28 \
		(UINT32_C(0x11) << 24)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_QSFP28
	/*
	 * This value represents the current configuration of
	 * Forward Error Correction (FEC) on the port.
	 */
	uint16_t	fec_cfg;
	/*
	 * When set to 1, then FEC is not supported on this port. If this flag
	 * is set to 1, then all other FEC configuration flags shall be ignored.
	 * When set to 0, then FEC is supported as indicated by other
	 * configuration flags.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_NONE_SUPPORTED \
		UINT32_C(0x1)
	/*
	 * When set to 1, then FEC autonegotiation is supported on this port.
	 * When set to 0, then FEC autonegotiation is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_AUTONEG_SUPPORTED \
		UINT32_C(0x2)
	/*
	 * When set to 1, then FEC autonegotiation is enabled on this port.
	 * When set to 0, then FEC autonegotiation is disabled if supported.
	 * This flag should be ignored if FEC autonegotiation is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_AUTONEG_ENABLED \
		UINT32_C(0x4)
	/*
	 * When set to 1, then FEC CLAUSE 74 (Fire Code) is supported on this port.
	 * When set to 0, then FEC CLAUSE 74 (Fire Code) is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_CLAUSE74_SUPPORTED \
		UINT32_C(0x8)
	/*
	 * When set to 1, then FEC CLAUSE 74 (Fire Code) is enabled on this
	 * port. This means that FEC CLAUSE 74 is either advertised if
	 * FEC autonegotiation is enabled or FEC CLAUSE 74 is force enabled.
	 * When set to 0, then FEC CLAUSE 74 (Fire Code) is disabled if supported.
	 * This flag should be ignored if FEC CLAUSE 74 is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_CLAUSE74_ENABLED \
		UINT32_C(0x10)
	/*
	 * When set to 1, then FEC CLAUSE 91 (Reed Solomon RS(528,514) for
	 * NRZ) is supported on this port.
	 * When set to 0, then FEC RS(528,418) is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_CLAUSE91_SUPPORTED \
		UINT32_C(0x20)
	/*
	 * When set to 1, then FEC CLAUSE 91 (Reed Solomon RS(528,514) for
	 * NRZ) is enabled on this port. This means that FEC RS(528,514) is
	 * either advertised if FEC autonegotiation is enabled or FEC
	 * RS(528,514) is force enabled.  When set to 0, then FEC RS(528,514)
	 * is disabled if supported.
	 * This flag should be ignored if FEC CLAUSE 91 is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_CLAUSE91_ENABLED \
		UINT32_C(0x40)
	/*
	 * When set to 1, then FEC RS544_1XN is supported on this port.
	 * When set to 0, then FEC RS544_1XN is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS544_1XN_SUPPORTED \
		UINT32_C(0x80)
	/*
	 * When set to 1, then RS544_1XN is enabled on this
	 * port. This means that FEC RS544_1XN is either advertised if
	 * FEC autonegotiation is enabled or FEC RS544_1XN is force enabled.
	 * When set to 0, then FEC RS544_1XN is disabled if supported.
	 * This flag should be ignored if FEC RS544_1XN is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS544_1XN_ENABLED \
		UINT32_C(0x100)
	/*
	 * When set to 1, then FEC RS(544,514) is supported on this port.
	 * When set to 0, then FEC RS(544,514) is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS544_IEEE_SUPPORTED \
		UINT32_C(0x200)
	/*
	 * When set to 1, then RS(544,514) is enabled on this
	 * port. This means that FEC RS(544,514) is either advertised if
	 * FEC autonegotiation is enabled or FEC RS(544,514) is force
	 * enabled.  When set to 0, then FEC RS(544,514) is disabled if supported.
	 * This flag should be ignored if FEC RS(544,514) is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS544_IEEE_ENABLED \
		UINT32_C(0x400)
	/*
	 * When set to 1, then FEC RS272_1XN is supported on this port.
	 * When set to 0, then FEC RS272_1XN is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS272_1XN_SUPPORTED \
		UINT32_C(0x800)
	/*
	 * When set to 1, then RS272_1XN is enabled on this
	 * port. This means that FEC RS272_1XN is either advertised if
	 * FEC autonegotiation is enabled or FEC RS272_1XN is force
	 * enabled.  When set to 0, then FEC RS272_1XN is disabled if supported.
	 * This flag should be ignored if FEC RS272_1XN is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS272_1XN_ENABLED \
		UINT32_C(0x1000)
	/*
	 * When set to 1, then FEC RS(272,514) is supported on this port.
	 * When set to 0, then FEC RS(272,514) is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS272_IEEE_SUPPORTED \
		UINT32_C(0x2000)
	/*
	 * When set to 1, then RS(272,257) is enabled on this
	 * port. This means that FEC RS(272,257) is either advertised if
	 * FEC autonegotiation is enabled or FEC RS(272,257) is force
	 * enabled.  When set to 0, then FEC RS(272,257) is disabled if supported.
	 * This flag should be ignored if FEC RS(272,257) is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS272_IEEE_ENABLED \
		UINT32_C(0x4000)
	/*
	 * This value is indicates the duplex of the current
	 * connection state.
	 */
	uint8_t	duplex_state;
	/* Half Duplex connection. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_STATE_HALF UINT32_C(0x0)
	/* Full duplex connection. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_STATE_FULL UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_STATE_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_STATE_FULL
	/* Option flags fields. */
	uint8_t	option_flags;
	/* When this bit is '1', Media auto detect is enabled. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_OPTION_FLAGS_MEDIA_AUTO_DETECT \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', active_fec_signal_mode can be
	 * trusted.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_OPTION_FLAGS_SIGNAL_MODE_KNOWN \
		UINT32_C(0x2)
	/*
	 * Up to 16 bytes of null padded ASCII string representing
	 * PHY vendor.
	 * If the string is set to null, then the vendor name is not
	 * available.
	 */
	char	phy_vendor_name[16];
	/*
	 * Up to 16 bytes of null padded ASCII string that
	 * identifies vendor specific part number of the PHY.
	 * If the string is set to null, then the vendor specific
	 * part number is not available.
	 */
	char	phy_vendor_partnumber[16];
	/*
	 * The supported PAM4 speeds for the port. This is a bit mask.
	 * For each speed that is supported, the corresponding
	 * bit will be set to '1'.
	 */
	uint16_t	support_pam4_speeds;
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_PAM4_SPEEDS_50G \
		UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_PAM4_SPEEDS_100G \
		UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_PAM4_SPEEDS_200G \
		UINT32_C(0x4)
	/*
	 * Current setting of forced PAM4 link speed.
	 * When the link speed is not being forced, this
	 * value shall be set to 0.
	 */
	uint16_t	force_pam4_link_speed;
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAM4_LINK_SPEED_50GB \
		UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAM4_LINK_SPEED_100GB \
		UINT32_C(0x3e8)
	/* 200Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAM4_LINK_SPEED_200GB \
		UINT32_C(0x7d0)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAM4_LINK_SPEED_LAST \
		HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAM4_LINK_SPEED_200GB
	/*
	 * Current setting for auto_pam4_link_speed_mask that is used to
	 * advertise speeds during autonegotiation.
	 * This field is only valid when auto_mode is set to "mask".
	 * The speeds specified in this field shall be a subset of
	 * supported speeds on this port.
	 */
	uint16_t	auto_pam4_link_speed_mask;
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAM4_LINK_SPEED_MASK_50G \
		UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAM4_LINK_SPEED_MASK_100G \
		UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAM4_LINK_SPEED_MASK_200G \
		UINT32_C(0x4)
	/*
	 * The advertised PAM4 speeds for the port by the link partner.
	 * Each advertised speed will be set to '1'.
	 */
	uint8_t	link_partner_pam4_adv_speeds;
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_PAM4_ADV_SPEEDS_50GB \
		UINT32_C(0x1)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_PAM4_ADV_SPEEDS_100GB \
		UINT32_C(0x2)
	/* 200Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_PAM4_ADV_SPEEDS_200GB \
		UINT32_C(0x4)
	/*
	 * This field is used to indicate the reasons for link down.
	 * This field is set to 0, if the link down reason is unknown.
	 */
	uint8_t	link_down_reason;
	/* Remote fault */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_DOWN_REASON_RF     UINT32_C(0x1)
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_port_mac_cfg *
 *********************/


/* hwrm_port_mac_cfg_input (size:448b/56B) */
struct hwrm_port_mac_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * In this field, there are a number of CoS mappings related flags
	 * that are used to configure CoS mappings and their corresponding
	 * priorities in the hardware.
	 * For the priorities of CoS mappings, the HWRM uses the following
	 * priority order (high to low) by default:
	 * # vlan pri
	 * # ip_dscp
	 * # tunnel_vlan_pri
	 * # default cos
	 *
	 * A subset of CoS mappings can be enabled.
	 * If a priority is not specified for an enabled CoS mapping, the
	 * priority will be assigned in the above order for the enabled CoS
	 * mappings. For example, if vlan_pri and ip_dscp CoS mappings are
	 * enabled and their priorities are not specified, the following
	 * priority order (high to low) will be used by the HWRM:
	 * # vlan_pri
	 * # ip_dscp
	 * # default cos
	 *
	 * vlan_pri CoS mapping together with default CoS with lower priority
	 * are enabled by default by the HWRM.
	 */
	uint32_t	flags;
	/*
	 * When this bit is '1', this command will configure
	 * the MAC to match the current link state of the PHY.
	 * If the link is not established on the PHY, then this
	 * bit has no effect.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_MATCH_LINK \
		UINT32_C(0x1)
	/*
	 * When this bit is set to '1', the inner VLAN PRI to CoS mapping
	 * is requested to be enabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_VLAN_PRI2COS_ENABLE \
		UINT32_C(0x2)
	/*
	 * When this bit is set to '1', tunnel VLAN PRI field to
	 * CoS mapping is requested to be enabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_TUNNEL_PRI2COS_ENABLE \
		UINT32_C(0x4)
	/*
	 * When this bit is set to '1', the IP DSCP to CoS mapping is
	 * requested to be enabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_IP_DSCP2COS_ENABLE \
		UINT32_C(0x8)
	/*
	 * When this bit is '1', the HWRM is requested to
	 * enable timestamp capture capability on the receive side
	 * of this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_RX_TS_CAPTURE_ENABLE \
		UINT32_C(0x10)
	/*
	 * When this bit is '1', the HWRM is requested to
	 * disable timestamp capture capability on the receive side
	 * of this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_RX_TS_CAPTURE_DISABLE \
		UINT32_C(0x20)
	/*
	 * When this bit is '1', the HWRM is requested to
	 * enable timestamp capture capability on the transmit side
	 * of this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_TX_TS_CAPTURE_ENABLE \
		UINT32_C(0x40)
	/*
	 * When this bit is '1', the HWRM is requested to
	 * disable timestamp capture capability on the transmit side
	 * of this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_TX_TS_CAPTURE_DISABLE \
		UINT32_C(0x80)
	/*
	 * When this bit is '1', the Out-Of-Box WoL is requested to
	 * be enabled on this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_OOB_WOL_ENABLE \
		UINT32_C(0x100)
	/*
	 * When this bit is '1', the Out-Of-Box WoL is requested to
	 * be disabled on this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_OOB_WOL_DISABLE \
		UINT32_C(0x200)
	/*
	 * When this bit is set to '1', the inner VLAN PRI to CoS mapping
	 * is requested to be disabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_VLAN_PRI2COS_DISABLE \
		UINT32_C(0x400)
	/*
	 * When this bit is set to '1', tunnel VLAN PRI field to
	 * CoS mapping is requested to be disabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_TUNNEL_PRI2COS_DISABLE \
		UINT32_C(0x800)
	/*
	 * When this bit is set to '1', the IP DSCP to CoS mapping is
	 * requested to be disabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_IP_DSCP2COS_DISABLE \
		UINT32_C(0x1000)
	/*
	 * When this bit is set to '1', and the ptp_tx_ts_capture_enable
	 * bit is set, then the device uses one step Tx timestamping.
	 * This bit is temporary and used for experimental purposes.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_ONE_STEP_TX_TS \
		UINT32_C(0x2000)
	/*
	 * When this bit is '1', the controller is requested to enable
	 * timestamp capture capability on all packets (not just PTP)
	 * of the receive side of this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_ALL_RX_TS_CAPTURE_ENABLE \
		UINT32_C(0x4000)
	/*
	 * When this bit is '1', the controller is requested to disable
	 * timestamp capture capability on all packets (not just PTP)
	 * of the receive side of this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_ALL_RX_TS_CAPTURE_DISABLE \
		UINT32_C(0x8000)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the ipg field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_IPG \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the lpbk field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_LPBK \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the vlan_pri2cos_map_pri field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_VLAN_PRI2COS_MAP_PRI \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the tunnel_pri2cos_map_pri field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_TUNNEL_PRI2COS_MAP_PRI \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the dscp2cos_map_pri field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_DSCP2COS_MAP_PRI \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the rx_ts_capture_ptp_msg_type field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_RX_TS_CAPTURE_PTP_MSG_TYPE \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the tx_ts_capture_ptp_msg_type field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_TX_TS_CAPTURE_PTP_MSG_TYPE \
		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the cos_field_cfg field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_COS_FIELD_CFG \
		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the ptp_freq_adj_ppb field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_PPB \
		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the ptp_adj_phase field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_PTP_ADJ_PHASE \
		UINT32_C(0x400)
	/* Port ID of port that is to be configured. */
	uint16_t	port_id;
	/*
	 * This value is used to configure the minimum IPG that will
	 * be sent between packets by this port.
	 */
	uint8_t	ipg;
	/* This value controls the loopback setting for the MAC. */
	uint8_t	lpbk;
	/* No loopback is selected.  Normal operation. */
	#define HWRM_PORT_MAC_CFG_INPUT_LPBK_NONE   UINT32_C(0x0)
	/*
	 * The HW will be configured with local loopback such that
	 * host data is sent back to the host without modification.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_LPBK_LOCAL  UINT32_C(0x1)
	/*
	 * The HW will be configured with remote loopback such that
	 * port logic will send packets back out the transmitter that
	 * are received.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_LPBK_REMOTE UINT32_C(0x2)
	#define HWRM_PORT_MAC_CFG_INPUT_LPBK_LAST \
		HWRM_PORT_MAC_CFG_INPUT_LPBK_REMOTE
	/*
	 * This value controls the priority setting of VLAN PRI to CoS
	 * mapping based on VLAN Tags of inner packet headers of
	 * tunneled packets or packet headers of non-tunneled packets.
	 *
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being specified.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 */
	uint8_t	vlan_pri2cos_map_pri;
	/* Reserved field. */
	uint8_t	reserved1;
	/*
	 * This value controls the priority setting of VLAN PRI to CoS
	 * mapping based on VLAN Tags of tunneled header.
	 * This mapping only applies when tunneled headers
	 * are present.
	 *
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being specified.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 */
	uint8_t	tunnel_pri2cos_map_pri;
	/*
	 * This value controls the priority setting of IP DSCP to CoS
	 * mapping based on inner IP header of tunneled packets or
	 * IP header of non-tunneled packets.
	 *
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being specified.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 */
	uint8_t	dscp2pri_map_pri;
	/*
	 * This is a 16-bit bit mask that is used to request a
	 * specific configuration of time stamp capture of PTP messages
	 * on the receive side of this port.
	 * This field shall be ignored if the ptp_rx_ts_capture_enable
	 * flag is not set in this command.
	 * Otherwise, if bit 'i' is set, then the HWRM is being
	 * requested to configure the receive side of the port to
	 * capture the time stamp of every received PTP message
	 * with messageType field value set to i.
	 */
	uint16_t	rx_ts_capture_ptp_msg_type;
	/*
	 * This is a 16-bit bit mask that is used to request a
	 * specific configuration of time stamp capture of PTP messages
	 * on the transmit side of this port.
	 * This field shall be ignored if the ptp_tx_ts_capture_enable
	 * flag is not set in this command.
	 * Otherwise, if bit 'i' is set, then the HWRM is being
	 * requested to configure the transmit side of the port to
	 * capture the time stamp of every transmitted PTP message
	 * with messageType field value set to i.
	 */
	uint16_t	tx_ts_capture_ptp_msg_type;
	/* Configuration of CoS fields. */
	uint8_t	cos_field_cfg;
	/* Reserved */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_RSVD1 \
		UINT32_C(0x1)
	/*
	 * This field is used to specify selection of VLAN PRI value
	 * based on whether one or two VLAN Tags are present in
	 * the inner packet headers of tunneled packets or
	 * non-tunneled packets.
	 * This field is valid only if inner VLAN PRI to CoS mapping
	 * is enabled.
	 * If VLAN PRI to CoS mapping is not enabled, then this
	 * field shall be ignored.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_MASK \
		UINT32_C(0x6)
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_SFT \
		1
	/*
	 * Select inner VLAN PRI when 1 or 2 VLAN Tags are
	 * present in the inner packet headers
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_INNERMOST \
		(UINT32_C(0x0) << 1)
	/*
	 * Select outer VLAN Tag PRI when 2 VLAN Tags are
	 * present in the inner packet headers.
	 * No VLAN PRI shall be selected for this configuration
	 * if only one VLAN Tag is present in the inner
	 * packet headers.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_OUTER \
		(UINT32_C(0x1) << 1)
	/*
	 * Select outermost VLAN PRI when 1 or 2 VLAN Tags
	 * are present in the inner packet headers
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_OUTERMOST \
		(UINT32_C(0x2) << 1)
	/* Unspecified */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_UNSPECIFIED \
		(UINT32_C(0x3) << 1)
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_LAST \
		HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_UNSPECIFIED
	/*
	 * This field is used to specify selection of tunnel VLAN
	 * PRI value based on whether one or two VLAN Tags are
	 * present in tunnel headers.
	 * This field is valid only if tunnel VLAN PRI to CoS mapping
	 * is enabled.
	 * If tunnel VLAN PRI to CoS mapping is not enabled, then this
	 * field shall be ignored.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_MASK \
		UINT32_C(0x18)
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_SFT \
		3
	/*
	 * Select inner VLAN PRI when 1 or 2 VLAN Tags are
	 * present in the tunnel packet headers
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_INNERMOST \
		(UINT32_C(0x0) << 3)
	/*
	 * Select outer VLAN Tag PRI when 2 VLAN Tags are
	 * present in the tunnel packet headers.
	 * No tunnel VLAN PRI shall be selected for this
	 * configuration if only one VLAN Tag is present in
	 * the tunnel packet headers.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_OUTER \
		(UINT32_C(0x1) << 3)
	/*
	 * Select outermost VLAN PRI when 1 or 2 VLAN Tags
	 * are present in the tunnel packet headers
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_OUTERMOST \
		(UINT32_C(0x2) << 3)
	/* Unspecified */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_UNSPECIFIED \
		(UINT32_C(0x3) << 3)
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_LAST \
		HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_UNSPECIFIED
	/*
	 * This field shall be used to provide default CoS value
	 * that has been configured on this port.
	 * This field is valid only if default CoS mapping
	 * is enabled.
	 * If default CoS mapping is not enabled, then this
	 * field shall be ignored.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_DEFAULT_COS_MASK \
		UINT32_C(0xe0)
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_DEFAULT_COS_SFT \
		5
	uint8_t	unused_0[3];
	/*
	 * This signed field specifies by how much to adjust the frequency
	 * of sync timer updates (measured in parts per billion).
	 */
	int32_t	ptp_freq_adj_ppb;
	uint8_t	unused_1[4];
	/*
	 * This unsigned field specifies the phase offset to be applied
	 * to the PHC (PTP Hardware Clock). This field is specified in
	 * nanoseconds.
	 */
	int64_t	ptp_adj_phase;
} __rte_packed;

/* hwrm_port_mac_cfg_output (size:128b/16B) */
struct hwrm_port_mac_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is the configured maximum length of Ethernet packet
	 * payload that is allowed to be received on the port.
	 * This value does not include the number of bytes used by
	 * Ethernet header and trailer (CRC).
	 */
	uint16_t	mru;
	/*
	 * This is the configured maximum length of Ethernet packet
	 * payload that is allowed to be transmitted on the port.
	 * This value does not include the number of bytes used by
	 * Ethernet header and trailer (CRC).
	 */
	uint16_t	mtu;
	/* Current configuration of the IPG value. */
	uint8_t	ipg;
	/* Current value of the loopback value. */
	uint8_t	lpbk;
	/* No loopback is selected.  Normal operation. */
	#define HWRM_PORT_MAC_CFG_OUTPUT_LPBK_NONE   UINT32_C(0x0)
	/*
	 * The HW will be configured with local loopback such that
	 * host data is sent back to the host without modification.
	 */
	#define HWRM_PORT_MAC_CFG_OUTPUT_LPBK_LOCAL  UINT32_C(0x1)
	/*
	 * The HW will be configured with remote loopback such that
	 * port logic will send packets back out the transmitter that
	 * are received.
	 */
	#define HWRM_PORT_MAC_CFG_OUTPUT_LPBK_REMOTE UINT32_C(0x2)
	#define HWRM_PORT_MAC_CFG_OUTPUT_LPBK_LAST \
		HWRM_PORT_MAC_CFG_OUTPUT_LPBK_REMOTE
	uint8_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_port_mac_qcfg *
 **********************/


/* hwrm_port_mac_qcfg_input (size:192b/24B) */
struct hwrm_port_mac_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is to be configured. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_port_mac_qcfg_output (size:256b/32B) */
struct hwrm_port_mac_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is the configured maximum length of Ethernet packet
	 * payload that is allowed to be received on the port.
	 * This value does not include the number of bytes used by the
	 * Ethernet header and trailer (CRC).
	 */
	uint16_t	mru;
	/*
	 * This is the configured maximum length of Ethernet packet
	 * payload that is allowed to be transmitted on the port.
	 * This value does not include the number of bytes used by the
	 * Ethernet header and trailer (CRC).
	 */
	uint16_t	mtu;
	/*
	 * The minimum IPG that will
	 * be sent between packets by this port.
	 */
	uint8_t	ipg;
	/* The loopback setting for the MAC. */
	uint8_t	lpbk;
	/* No loopback is selected.  Normal operation. */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_NONE   UINT32_C(0x0)
	/*
	 * The HW will be configured with local loopback such that
	 * host data is sent back to the host without modification.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_LOCAL  UINT32_C(0x1)
	/*
	 * The HW will be configured with remote loopback such that
	 * port logic will send packets back out the transmitter that
	 * are received.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_REMOTE UINT32_C(0x2)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_LAST \
		HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_REMOTE
	/*
	 * Priority setting for VLAN PRI to CoS mapping.
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being used.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 * # If the corresponding CoS mapping is not enabled, then this
	 * field should be ignored.
	 * # This value indicates the normalized priority value retained
	 * in the HWRM.
	 */
	uint8_t	vlan_pri2cos_map_pri;
	/*
	 * In this field, a number of CoS mappings related flags
	 * are used to indicate configured CoS mappings.
	 */
	uint8_t	flags;
	/*
	 * When this bit is set to '1', the inner VLAN PRI to CoS mapping
	 * is enabled.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_VLAN_PRI2COS_ENABLE \
		UINT32_C(0x1)
	/*
	 * When this bit is set to '1', tunnel VLAN PRI field to
	 * CoS mapping is enabled.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_TUNNEL_PRI2COS_ENABLE \
		UINT32_C(0x2)
	/*
	 * When this bit is set to '1', the IP DSCP to CoS mapping is
	 * enabled.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_IP_DSCP2COS_ENABLE \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', the Out-Of-Box WoL is enabled on this
	 * port.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_OOB_WOL_ENABLE \
		UINT32_C(0x8)
	/* When this bit is '1', PTP is enabled for RX on this port. */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_PTP_RX_TS_CAPTURE_ENABLE \
		UINT32_C(0x10)
	/* When this bit is '1', PTP is enabled for TX on this port. */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_PTP_TX_TS_CAPTURE_ENABLE \
		UINT32_C(0x20)
	/*
	 * Priority setting for tunnel VLAN PRI to CoS mapping.
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being used.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 * # If the corresponding CoS mapping is not enabled, then this
	 * field should be ignored.
	 * # This value indicates the normalized priority value retained
	 * in the HWRM.
	 */
	uint8_t	tunnel_pri2cos_map_pri;
	/*
	 * Priority setting for DSCP to PRI mapping.
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being used.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 * # If the corresponding CoS mapping is not enabled, then this
	 * field should be ignored.
	 * # This value indicates the normalized priority value retained
	 * in the HWRM.
	 */
	uint8_t	dscp2pri_map_pri;
	/*
	 * This is a 16-bit bit mask that represents the
	 * current configuration of time stamp capture of PTP messages
	 * on the receive side of this port.
	 * If bit 'i' is set, then the receive side of the port
	 * is configured to capture the time stamp of every
	 * received PTP message with messageType field value set
	 * to i.
	 * If all bits are set to 0 (i.e. field value set 0),
	 * then the receive side of the port is not configured
	 * to capture timestamp for PTP messages.
	 * If all bits are set to 1, then the receive side of the
	 * port is configured to capture timestamp for all PTP
	 * messages.
	 */
	uint16_t	rx_ts_capture_ptp_msg_type;
	/*
	 * This is a 16-bit bit mask that represents the
	 * current configuration of time stamp capture of PTP messages
	 * on the transmit side of this port.
	 * If bit 'i' is set, then the transmit side of the port
	 * is configured to capture the time stamp of every
	 * received PTP message with messageType field value set
	 * to i.
	 * If all bits are set to 0 (i.e. field value set 0),
	 * then the transmit side of the port is not configured
	 * to capture timestamp for PTP messages.
	 * If all bits are set to 1, then the transmit side of the
	 * port is configured to capture timestamp for all PTP
	 * messages.
	 */
	uint16_t	tx_ts_capture_ptp_msg_type;
	/* Configuration of CoS fields. */
	uint8_t	cos_field_cfg;
	/* Reserved */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_RSVD \
		UINT32_C(0x1)
	/*
	 * This field is used for selecting VLAN PRI value
	 * based on whether one or two VLAN Tags are present in
	 * the inner packet headers of tunneled packets or
	 * non-tunneled packets.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_MASK \
		UINT32_C(0x6)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_SFT \
		1
	/*
	 * Select inner VLAN PRI when 1 or 2 VLAN Tags are
	 * present in the inner packet headers
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_INNERMOST \
		(UINT32_C(0x0) << 1)
	/*
	 * Select outer VLAN Tag PRI when 2 VLAN Tags are
	 * present in the inner packet headers.
	 * No VLAN PRI is selected for this configuration
	 * if only one VLAN Tag is present in the inner
	 * packet headers.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_OUTER \
		(UINT32_C(0x1) << 1)
	/*
	 * Select outermost VLAN PRI when 1 or 2 VLAN Tags
	 * are present in the inner packet headers
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_OUTERMOST \
		(UINT32_C(0x2) << 1)
	/* Unspecified */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_UNSPECIFIED \
		(UINT32_C(0x3) << 1)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_LAST \
		HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_UNSPECIFIED
	/*
	 * This field is used for selecting tunnel VLAN PRI value
	 * based on whether one or two VLAN Tags are present in
	 * the tunnel headers of tunneled packets. This selection
	 * does not apply to non-tunneled packets.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_MASK \
		UINT32_C(0x18)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_SFT \
		3
	/*
	 * Select inner VLAN PRI when 1 or 2 VLAN Tags are
	 * present in the tunnel packet headers
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_INNERMOST \
		(UINT32_C(0x0) << 3)
	/*
	 * Select outer VLAN Tag PRI when 2 VLAN Tags are
	 * present in the tunnel packet headers.
	 * No VLAN PRI is selected for this configuration
	 * if only one VLAN Tag is present in the tunnel
	 * packet headers.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_OUTER \
		(UINT32_C(0x1) << 3)
	/*
	 * Select outermost VLAN PRI when 1 or 2 VLAN Tags
	 * are present in the tunnel packet headers
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_OUTERMOST \
		(UINT32_C(0x2) << 3)
	/* Unspecified */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_UNSPECIFIED \
		(UINT32_C(0x3) << 3)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_LAST \
		HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_UNSPECIFIED
	/*
	 * This field is used to provide default CoS value that
	 * has been configured on this port.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_DEFAULT_COS_MASK \
		UINT32_C(0xe0)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_DEFAULT_COS_SFT \
		5
	uint8_t	unused_1;
	uint16_t	port_svif_info;
	/*
	 * This field specifies the source virtual interface of the port being
	 * queried. Drivers can use this to program port svif field in the
	 * L2 context table
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_PORT_SVIF_INFO_PORT_SVIF_MASK \
		UINT32_C(0x7fff)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_PORT_SVIF_INFO_PORT_SVIF_SFT       0
	/* This field specifies whether port_svif is valid or not */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_PORT_SVIF_INFO_PORT_SVIF_VALID \
		UINT32_C(0x8000)
	uint8_t	unused_2[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_port_mac_ptp_qcfg *
 **************************/


/* hwrm_port_mac_ptp_qcfg_input (size:192b/24B) */
struct hwrm_port_mac_ptp_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_port_mac_ptp_qcfg_output (size:704b/88B) */
struct hwrm_port_mac_ptp_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * In this field, a number of PTP related flags
	 * are used to indicate configured PTP capabilities.
	 */
	uint8_t	flags;
	/*
	 * When this bit is set to '1', the PTP related registers are
	 * directly accessible by the host.
	 */
	#define HWRM_PORT_MAC_PTP_QCFG_OUTPUT_FLAGS_DIRECT_ACCESS \
		UINT32_C(0x1)
	/*
	 * When this bit is set to '1', the device supports one-step
	 * Tx timestamping.
	 */
	#define HWRM_PORT_MAC_PTP_QCFG_OUTPUT_FLAGS_ONE_STEP_TX_TS \
		UINT32_C(0x4)
	/*
	 * When this bit is set to '1', the PTP information is accessible
	 * via HWRM commands.
	 */
	#define HWRM_PORT_MAC_PTP_QCFG_OUTPUT_FLAGS_HWRM_ACCESS \
		UINT32_C(0x8)
	/*
	 * When this bit is set to '1', two specific registers for current
	 * time (ts_ref_clock_reg_lower and ts_ref_clock_reg_upper) are
	 * directly accessible by the host.
	 */
	#define HWRM_PORT_MAC_PTP_QCFG_OUTPUT_FLAGS_PARTIAL_DIRECT_ACCESS_REF_CLOCK \
		UINT32_C(0x10)
	/*
	 * When this bit is set to '1', it indicates that driver has
	 * configured 64bit RTC.
	 */
	#define HWRM_PORT_MAC_PTP_QCFG_OUTPUT_FLAGS_RTC_CONFIGURED \
		UINT32_C(0x20)
	uint8_t	unused_0[3];
	/*
	 * Offset of the PTP register for the lower 32 bits of timestamp
	 * for RX.
	 */
	uint32_t	rx_ts_reg_off_lower;
	/*
	 * Offset of the PTP register for the upper 32 bits of timestamp
	 * for RX.
	 */
	uint32_t	rx_ts_reg_off_upper;
	/* Offset of the PTP register for the sequence ID for RX. */
	uint32_t	rx_ts_reg_off_seq_id;
	/* Offset of the first PTP source ID for RX. */
	uint32_t	rx_ts_reg_off_src_id_0;
	/* Offset of the second PTP source ID for RX. */
	uint32_t	rx_ts_reg_off_src_id_1;
	/* Offset of the third PTP source ID for RX. */
	uint32_t	rx_ts_reg_off_src_id_2;
	/* Offset of the domain ID for RX. */
	uint32_t	rx_ts_reg_off_domain_id;
	/* Offset of the PTP FIFO register for RX. */
	uint32_t	rx_ts_reg_off_fifo;
	/* Offset of the PTP advance FIFO register for RX. */
	uint32_t	rx_ts_reg_off_fifo_adv;
	/* PTP timestamp granularity for RX. */
	uint32_t	rx_ts_reg_off_granularity;
	/*
	 * Offset of the PTP register for the lower 32 bits of timestamp
	 * for TX.
	 */
	uint32_t	tx_ts_reg_off_lower;
	/*
	 * Offset of the PTP register for the upper 32 bits of timestamp
	 * for TX.
	 */
	uint32_t	tx_ts_reg_off_upper;
	/* Offset of the PTP register for the sequence ID for TX. */
	uint32_t	tx_ts_reg_off_seq_id;
	/* Offset of the PTP FIFO register for TX. */
	uint32_t	tx_ts_reg_off_fifo;
	/* PTP timestamp granularity for TX. */
	uint32_t	tx_ts_reg_off_granularity;
	/* Offset of register to get lower 32 bits of current time. */
	uint32_t	ts_ref_clock_reg_lower;
	/* Offset of register to get upper 32 bits of current time. */
	uint32_t	ts_ref_clock_reg_upper;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* Port Tx Statistics Format */
/* tx_port_stats (size:3264b/408B) */
struct tx_port_stats {
	/* Total Number of 64 Bytes frames transmitted */
	uint64_t	tx_64b_frames;
	/* Total Number of 65-127 Bytes frames transmitted */
	uint64_t	tx_65b_127b_frames;
	/* Total Number of 128-255 Bytes frames transmitted */
	uint64_t	tx_128b_255b_frames;
	/* Total Number of 256-511 Bytes frames transmitted */
	uint64_t	tx_256b_511b_frames;
	/* Total Number of 512-1023 Bytes frames transmitted */
	uint64_t	tx_512b_1023b_frames;
	/* Total Number of 1024-1518 Bytes frames transmitted */
	uint64_t	tx_1024b_1518b_frames;
	/*
	 * Total Number of each good VLAN (excludes FCS errors)
	 * frame transmitted which is 1519 to 1522 bytes in length
	 * inclusive (excluding framing bits but including FCS bytes).
	 */
	uint64_t	tx_good_vlan_frames;
	/* Total Number of 1519-2047 Bytes frames transmitted */
	uint64_t	tx_1519b_2047b_frames;
	/* Total Number of 2048-4095 Bytes frames transmitted */
	uint64_t	tx_2048b_4095b_frames;
	/* Total Number of 4096-9216 Bytes frames transmitted */
	uint64_t	tx_4096b_9216b_frames;
	/* Total Number of 9217-16383 Bytes frames transmitted */
	uint64_t	tx_9217b_16383b_frames;
	/* Total Number of good frames transmitted */
	uint64_t	tx_good_frames;
	/* Total Number of frames transmitted */
	uint64_t	tx_total_frames;
	/* Total number of unicast frames transmitted */
	uint64_t	tx_ucast_frames;
	/* Total number of multicast frames transmitted */
	uint64_t	tx_mcast_frames;
	/* Total number of broadcast frames transmitted */
	uint64_t	tx_bcast_frames;
	/* Total number of PAUSE control frames transmitted */
	uint64_t	tx_pause_frames;
	/*
	 * Total number of PFC/per-priority PAUSE
	 * control frames transmitted
	 */
	uint64_t	tx_pfc_frames;
	/* Total number of jabber frames transmitted */
	uint64_t	tx_jabber_frames;
	/* Total number of frames transmitted with FCS error */
	uint64_t	tx_fcs_err_frames;
	/* Total number of control frames transmitted */
	uint64_t	tx_control_frames;
	/* Total number of over-sized frames transmitted */
	uint64_t	tx_oversz_frames;
	/* Total number of frames with single deferral */
	uint64_t	tx_single_dfrl_frames;
	/* Total number of frames with multiple deferrals */
	uint64_t	tx_multi_dfrl_frames;
	/* Total number of frames with single collision */
	uint64_t	tx_single_coll_frames;
	/* Total number of frames with multiple collisions */
	uint64_t	tx_multi_coll_frames;
	/* Total number of frames with late collisions */
	uint64_t	tx_late_coll_frames;
	/* Total number of frames with excessive collisions */
	uint64_t	tx_excessive_coll_frames;
	/* Total number of fragmented frames transmitted */
	uint64_t	tx_frag_frames;
	/* Total number of transmit errors */
	uint64_t	tx_err;
	/* Total number of single VLAN tagged frames transmitted */
	uint64_t	tx_tagged_frames;
	/* Total number of double VLAN tagged frames transmitted */
	uint64_t	tx_dbl_tagged_frames;
	/* Total number of runt frames transmitted */
	uint64_t	tx_runt_frames;
	/* Total number of TX FIFO under runs */
	uint64_t	tx_fifo_underruns;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 0 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri0;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 1 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri1;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 2 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri2;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 3 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri3;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 4 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri4;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 5 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri5;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 6 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri6;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 7 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri7;
	/* Total number of EEE LPI Events on TX */
	uint64_t	tx_eee_lpi_events;
	/* EEE LPI Duration Counter on TX */
	uint64_t	tx_eee_lpi_duration;
	/*
	 * Total number of Link Level Flow Control (LLFC) messages
	 * transmitted
	 */
	uint64_t	tx_llfc_logical_msgs;
	/* Total number of HCFC messages transmitted */
	uint64_t	tx_hcfc_msgs;
	/* Total number of TX collisions */
	uint64_t	tx_total_collisions;
	/* Total number of transmitted bytes */
	uint64_t	tx_bytes;
	/* Total number of end-to-end HOL frames */
	uint64_t	tx_xthol_frames;
	/* Total Tx Drops per Port reported by STATS block */
	uint64_t	tx_stat_discard;
	/* Total Tx Error Drops per Port reported by STATS block */
	uint64_t	tx_stat_error;
} __rte_packed;

/* Port Rx Statistics Format */
/* rx_port_stats (size:4224b/528B) */
struct rx_port_stats {
	/* Total Number of 64 Bytes frames received */
	uint64_t	rx_64b_frames;
	/* Total Number of 65-127 Bytes frames received */
	uint64_t	rx_65b_127b_frames;
	/* Total Number of 128-255 Bytes frames received */
	uint64_t	rx_128b_255b_frames;
	/* Total Number of 256-511 Bytes frames received */
	uint64_t	rx_256b_511b_frames;
	/* Total Number of 512-1023 Bytes frames received */
	uint64_t	rx_512b_1023b_frames;
	/* Total Number of 1024-1518 Bytes frames received */
	uint64_t	rx_1024b_1518b_frames;
	/*
	 * Total Number of each good VLAN (excludes FCS errors)
	 * frame received which is 1519 to 1522 bytes in length
	 * inclusive (excluding framing bits but including FCS bytes).
	 */
	uint64_t	rx_good_vlan_frames;
	/* Total Number of 1519-2047 Bytes frames received */
	uint64_t	rx_1519b_2047b_frames;
	/* Total Number of 2048-4095 Bytes frames received */
	uint64_t	rx_2048b_4095b_frames;
	/* Total Number of 4096-9216 Bytes frames received */
	uint64_t	rx_4096b_9216b_frames;
	/* Total Number of 9217-16383 Bytes frames received */
	uint64_t	rx_9217b_16383b_frames;
	/* Total number of frames received */
	uint64_t	rx_total_frames;
	/* Total number of unicast frames received */
	uint64_t	rx_ucast_frames;
	/* Total number of multicast frames received */
	uint64_t	rx_mcast_frames;
	/* Total number of broadcast frames received */
	uint64_t	rx_bcast_frames;
	/* Total number of received frames with FCS error */
	uint64_t	rx_fcs_err_frames;
	/* Total number of control frames received */
	uint64_t	rx_ctrl_frames;
	/* Total number of PAUSE frames received */
	uint64_t	rx_pause_frames;
	/* Total number of PFC frames received */
	uint64_t	rx_pfc_frames;
	/*
	 * Total number of frames received with an unsupported
	 * opcode
	 */
	uint64_t	rx_unsupported_opcode_frames;
	/*
	 * Total number of frames received with an unsupported
	 * DA for pause and PFC
	 */
	uint64_t	rx_unsupported_da_pausepfc_frames;
	/* Total number of frames received with an unsupported SA */
	uint64_t	rx_wrong_sa_frames;
	/* Total number of received packets with alignment error */
	uint64_t	rx_align_err_frames;
	/* Total number of received frames with out-of-range length */
	uint64_t	rx_oor_len_frames;
	/* Total number of received frames with error termination */
	uint64_t	rx_code_err_frames;
	/*
	 * Total number of received frames with a false carrier is
	 * detected during idle, as defined by RX_ER samples active
	 * and RXD is 0xE. The event is reported along with the
	 * statistics generated on the next received frame. Only
	 * one false carrier condition can be detected and logged
	 * between frames.
	 *
	 * Carrier event, valid for 10M/100M speed modes only.
	 */
	uint64_t	rx_false_carrier_frames;
	/* Total number of over-sized frames received */
	uint64_t	rx_ovrsz_frames;
	/* Total number of jabber packets received */
	uint64_t	rx_jbr_frames;
	/* Total number of received frames with MTU error */
	uint64_t	rx_mtu_err_frames;
	/* Total number of received frames with CRC match */
	uint64_t	rx_match_crc_frames;
	/* Total number of frames received promiscuously */
	uint64_t	rx_promiscuous_frames;
	/*
	 * Total number of received frames with one or two VLAN
	 * tags
	 */
	uint64_t	rx_tagged_frames;
	/* Total number of received frames with two VLAN tags */
	uint64_t	rx_double_tagged_frames;
	/* Total number of truncated frames received */
	uint64_t	rx_trunc_frames;
	/* Total number of good frames (without errors) received */
	uint64_t	rx_good_frames;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 0
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri0;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 1
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri1;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 2
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri2;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 3
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri3;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 4
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri4;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 5
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri5;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 6
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri6;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 7
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri7;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 0
	 */
	uint64_t	rx_pfc_ena_frames_pri0;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 1
	 */
	uint64_t	rx_pfc_ena_frames_pri1;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 2
	 */
	uint64_t	rx_pfc_ena_frames_pri2;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 3
	 */
	uint64_t	rx_pfc_ena_frames_pri3;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 4
	 */
	uint64_t	rx_pfc_ena_frames_pri4;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 5
	 */
	uint64_t	rx_pfc_ena_frames_pri5;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 6
	 */
	uint64_t	rx_pfc_ena_frames_pri6;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 7
	 */
	uint64_t	rx_pfc_ena_frames_pri7;
	/* Total Number of frames received with SCH CRC error */
	uint64_t	rx_sch_crc_err_frames;
	/* Total Number of under-sized frames received */
	uint64_t	rx_undrsz_frames;
	/* Total Number of fragmented frames received */
	uint64_t	rx_frag_frames;
	/* Total number of RX EEE LPI Events */
	uint64_t	rx_eee_lpi_events;
	/* EEE LPI Duration Counter on RX */
	uint64_t	rx_eee_lpi_duration;
	/*
	 * Total number of physical type Link Level Flow Control
	 * (LLFC) messages received
	 */
	uint64_t	rx_llfc_physical_msgs;
	/*
	 * Total number of logical type Link Level Flow Control
	 * (LLFC) messages received
	 */
	uint64_t	rx_llfc_logical_msgs;
	/*
	 * Total number of logical type Link Level Flow Control
	 * (LLFC) messages received with CRC error
	 */
	uint64_t	rx_llfc_msgs_with_crc_err;
	/* Total number of HCFC messages received */
	uint64_t	rx_hcfc_msgs;
	/* Total number of HCFC messages received with CRC error */
	uint64_t	rx_hcfc_msgs_with_crc_err;
	/* Total number of received bytes */
	uint64_t	rx_bytes;
	/* Total number of bytes received in runt frames */
	uint64_t	rx_runt_bytes;
	/* Total number of runt frames received */
	uint64_t	rx_runt_frames;
	/* Total Rx Discards per Port reported by STATS block */
	uint64_t	rx_stat_discard;
	uint64_t	rx_stat_err;
} __rte_packed;

/********************
 * hwrm_port_qstats *
 ********************/


/* hwrm_port_qstats_input (size:320b/40B) */
struct hwrm_port_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	uint8_t	flags;
	/*
	 * This bit is set to 1 when request is for a counter mask,
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_PORT_QSTATS_INPUT_FLAGS_COUNTER_MASK     UINT32_C(0x1)
	uint8_t	unused_0[5];
	/*
	 * This is the host address where
	 * Tx port statistics will be stored
	 */
	uint64_t	tx_stat_host_addr;
	/*
	 * This is the host address where
	 * Rx port statistics will be stored
	 */
	uint64_t	rx_stat_host_addr;
} __rte_packed;

/* hwrm_port_qstats_output (size:128b/16B) */
struct hwrm_port_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The size of TX port statistics block in bytes. */
	uint16_t	tx_stat_size;
	/* The size of RX port statistics block in bytes. */
	uint16_t	rx_stat_size;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* Port Tx Statistics extended Format */
/* tx_port_stats_ext (size:2048b/256B) */
struct tx_port_stats_ext {
	/* Total number of tx bytes count on cos queue 0 */
	uint64_t	tx_bytes_cos0;
	/* Total number of tx bytes count on cos queue 1 */
	uint64_t	tx_bytes_cos1;
	/* Total number of tx bytes count on cos queue 2 */
	uint64_t	tx_bytes_cos2;
	/* Total number of tx bytes count on cos queue 3 */
	uint64_t	tx_bytes_cos3;
	/* Total number of tx bytes count on cos queue 4 */
	uint64_t	tx_bytes_cos4;
	/* Total number of tx bytes count on cos queue 5 */
	uint64_t	tx_bytes_cos5;
	/* Total number of tx bytes count on cos queue 6 */
	uint64_t	tx_bytes_cos6;
	/* Total number of tx bytes count on cos queue 7 */
	uint64_t	tx_bytes_cos7;
	/* Total number of tx packets count on cos queue 0 */
	uint64_t	tx_packets_cos0;
	/* Total number of tx packets count on cos queue 1 */
	uint64_t	tx_packets_cos1;
	/* Total number of tx packets count on cos queue 2 */
	uint64_t	tx_packets_cos2;
	/* Total number of tx packets count on cos queue 3 */
	uint64_t	tx_packets_cos3;
	/* Total number of tx packets count on cos queue 4 */
	uint64_t	tx_packets_cos4;
	/* Total number of tx packets count on cos queue 5 */
	uint64_t	tx_packets_cos5;
	/* Total number of tx packets count on cos queue 6 */
	uint64_t	tx_packets_cos6;
	/* Total number of tx packets count on cos queue 7 */
	uint64_t	tx_packets_cos7;
	/* time duration between transmitting aXON -> XOFF and a subsequent XOFF -> XON for priority 0 */
	uint64_t	pfc_pri0_tx_duration_us;
	/* Number of times, aXON -> XOFF and XOFF -> XONtransitions occur for priority 0 */
	uint64_t	pfc_pri0_tx_transitions;
	/* time duration between transmitting aXON -> XOFF and a subsequent XOFF -> XON for priority 1 */
	uint64_t	pfc_pri1_tx_duration_us;
	/* Number of times, aXON -> XOFF and XOFF -> XONtransitions occur for priority 1 */
	uint64_t	pfc_pri1_tx_transitions;
	/* time duration between transmitting aXON -> XOFF and a subsequent XOFF -> XON for priority 2 */
	uint64_t	pfc_pri2_tx_duration_us;
	/* Number of times, aXON -> XOFF and XOFF -> XONtransitions occur for priority 2 */
	uint64_t	pfc_pri2_tx_transitions;
	/* time duration between transmitting aXON -> XOFF and a subsequent XOFF -> XON for priority 3 */
	uint64_t	pfc_pri3_tx_duration_us;
	/* Number of times, aXON -> XOFF and XOFF -> XONtransitions occur for priority 3 */
	uint64_t	pfc_pri3_tx_transitions;
	/* time duration between transmitting aXON -> XOFF and a subsequent XOFF -> XON for priority 4 */
	uint64_t	pfc_pri4_tx_duration_us;
	/* Number of times, aXON -> XOFF and XOFF -> XONtransitions occur for priority 4 */
	uint64_t	pfc_pri4_tx_transitions;
	/* time duration between transmitting aXON -> XOFF and a subsequent XOFF -> XON for priority 5 */
	uint64_t	pfc_pri5_tx_duration_us;
	/* Number of times, aXON -> XOFF and XOFF -> XONtransitions occur for priority 5 */
	uint64_t	pfc_pri5_tx_transitions;
	/* time duration between transmitting aXON -> XOFF and a subsequent XOFF -> XON for priority 6 */
	uint64_t	pfc_pri6_tx_duration_us;
	/* Number of times, aXON -> XOFF and XOFF -> XONtransitions occur for priority 6 */
	uint64_t	pfc_pri6_tx_transitions;
	/* time duration between transmitting aXON -> XOFF and a subsequent XOFF -> XON for priority 7 */
	uint64_t	pfc_pri7_tx_duration_us;
	/* Number of times, aXON -> XOFF and XOFF -> XONtransitions occur for priority 7 */
	uint64_t	pfc_pri7_tx_transitions;
} __rte_packed;

/* Port Rx Statistics extended Format */
/* rx_port_stats_ext (size:3776b/472B) */
struct rx_port_stats_ext {
	/* Number of times link state changed to down */
	uint64_t	link_down_events;
	/* Number of times the idle rings with pause bit are found */
	uint64_t	continuous_pause_events;
	/* Number of times the active rings pause bit resumed back */
	uint64_t	resume_pause_events;
	/* Number of times, the ROCE cos queue PFC is disabled to avoid pause flood/burst */
	uint64_t	continuous_roce_pause_events;
	/* Number of times, the ROCE cos queue PFC is enabled back */
	uint64_t	resume_roce_pause_events;
	/* Total number of rx bytes count on cos queue 0 */
	uint64_t	rx_bytes_cos0;
	/* Total number of rx bytes count on cos queue 1 */
	uint64_t	rx_bytes_cos1;
	/* Total number of rx bytes count on cos queue 2 */
	uint64_t	rx_bytes_cos2;
	/* Total number of rx bytes count on cos queue 3 */
	uint64_t	rx_bytes_cos3;
	/* Total number of rx bytes count on cos queue 4 */
	uint64_t	rx_bytes_cos4;
	/* Total number of rx bytes count on cos queue 5 */
	uint64_t	rx_bytes_cos5;
	/* Total number of rx bytes count on cos queue 6 */
	uint64_t	rx_bytes_cos6;
	/* Total number of rx bytes count on cos queue 7 */
	uint64_t	rx_bytes_cos7;
	/* Total number of rx packets count on cos queue 0 */
	uint64_t	rx_packets_cos0;
	/* Total number of rx packets count on cos queue 1 */
	uint64_t	rx_packets_cos1;
	/* Total number of rx packets count on cos queue 2 */
	uint64_t	rx_packets_cos2;
	/* Total number of rx packets count on cos queue 3 */
	uint64_t	rx_packets_cos3;
	/* Total number of rx packets count on cos queue 4 */
	uint64_t	rx_packets_cos4;
	/* Total number of rx packets count on cos queue 5 */
	uint64_t	rx_packets_cos5;
	/* Total number of rx packets count on cos queue 6 */
	uint64_t	rx_packets_cos6;
	/* Total number of rx packets count on cos queue 7 */
	uint64_t	rx_packets_cos7;
	/* time duration receiving aXON -> XOFF and a subsequent XOFF -> XON for priority 0 */
	uint64_t	pfc_pri0_rx_duration_us;
	/* Number of times, aXON -> XOFF and XOFF -> XONtransitions occur for priority 0 */
	uint64_t	pfc_pri0_rx_transitions;
	/* time duration receiving aXON -> XOFF and a subsequent XOFF -> XON for priority 1 */
	uint64_t	pfc_pri1_rx_duration_us;
	/* Number of times, aXON -> XOFF and XOFF -> XONtransitions occur for priority 1 */
	uint64_t	pfc_pri1_rx_transitions;
	/* time duration receiving aXON -> XOFF and a subsequent XOFF -> XON for priority 2 */
	uint64_t	pfc_pri2_rx_duration_us;
	/* Number of times, aXON -> XOFF and XOFF -> XONtransitions occur for priority 2 */
	uint64_t	pfc_pri2_rx_transitions;
	/* time duration receiving aXON -> XOFF and a subsequent XOFF -> XON for priority 3 */
	uint64_t	pfc_pri3_rx_duration_us;
	/* Number of times, aXON -> XOFF and XOFF -> XONtransitions occur for priority 3 */
	uint64_t	pfc_pri3_rx_transitions;
	/* time duration receiving aXON -> XOFF and a subsequent XOFF -> XON for priority 4 */
	uint64_t	pfc_pri4_rx_duration_us;
	/* Number of times, aXON -> XOFF and XOFF -> XONtransitions occur for priority 4 */
	uint64_t	pfc_pri4_rx_transitions;
	/* time duration receiving aXON -> XOFF and a subsequent XOFF -> XON for priority 5 */
	uint64_t	pfc_pri5_rx_duration_us;
	/* Number of times, aXON -> XOFF and XOFF -> XONtransitions occur for priority 5 */
	uint64_t	pfc_pri5_rx_transitions;
	/* time duration receiving aXON -> XOFF and a subsequent XOFF -> XON for priority 6 */
	uint64_t	pfc_pri6_rx_duration_us;
	/* Number of times, aXON -> XOFF and XOFF -> XONtransitions occur for priority 6 */
	uint64_t	pfc_pri6_rx_transitions;
	/* time duration receiving aXON -> XOFF and a subsequent XOFF -> XON for priority 7 */
	uint64_t	pfc_pri7_rx_duration_us;
	/* Number of times, aXON -> XOFF and XOFF -> XONtransitions occur for priority 7 */
	uint64_t	pfc_pri7_rx_transitions;
	/* Total number of received bits */
	uint64_t	rx_bits;
	/* The number of events where the port receive buffer was over 85% full */
	uint64_t	rx_buffer_passed_threshold;
	/*
	 * The number of symbol errors that wasn't corrected by FEC correction
	 * algorithm
	 */
	uint64_t	rx_pcs_symbol_err;
	/* The number of corrected bits on the port according to active FEC */
	uint64_t	rx_corrected_bits;
	/* Total number of rx discard bytes count on cos queue 0 */
	uint64_t	rx_discard_bytes_cos0;
	/* Total number of rx discard bytes count on cos queue 1 */
	uint64_t	rx_discard_bytes_cos1;
	/* Total number of rx discard bytes count on cos queue 2 */
	uint64_t	rx_discard_bytes_cos2;
	/* Total number of rx discard bytes count on cos queue 3 */
	uint64_t	rx_discard_bytes_cos3;
	/* Total number of rx discard bytes count on cos queue 4 */
	uint64_t	rx_discard_bytes_cos4;
	/* Total number of rx discard bytes count on cos queue 5 */
	uint64_t	rx_discard_bytes_cos5;
	/* Total number of rx discard bytes count on cos queue 6 */
	uint64_t	rx_discard_bytes_cos6;
	/* Total number of rx discard bytes count on cos queue 7 */
	uint64_t	rx_discard_bytes_cos7;
	/* Total number of rx discard packets count on cos queue 0 */
	uint64_t	rx_discard_packets_cos0;
	/* Total number of rx discard packets count on cos queue 1 */
	uint64_t	rx_discard_packets_cos1;
	/* Total number of rx discard packets count on cos queue 2 */
	uint64_t	rx_discard_packets_cos2;
	/* Total number of rx discard packets count on cos queue 3 */
	uint64_t	rx_discard_packets_cos3;
	/* Total number of rx discard packets count on cos queue 4 */
	uint64_t	rx_discard_packets_cos4;
	/* Total number of rx discard packets count on cos queue 5 */
	uint64_t	rx_discard_packets_cos5;
	/* Total number of rx discard packets count on cos queue 6 */
	uint64_t	rx_discard_packets_cos6;
	/* Total number of rx discard packets count on cos queue 7 */
	uint64_t	rx_discard_packets_cos7;
	/* Total number of FEC blocks corrected by the FEC function in the PHY */
	uint64_t	rx_fec_corrected_blocks;
	/*
	 * Total number of FEC blocks determined to be uncorrectable by the
	 * FEC function in the PHY
	 */
	uint64_t	rx_fec_uncorrectable_blocks;
} __rte_packed;

/*
 * Port Rx Statistics extended PFC WatchDog Format.
 * StormDetect and StormRevert event determination is based
 * on an integration period and a percentage threshold.
 * StormDetect event - when percentage of XOFF frames received
 * within an integration period exceeds the configured threshold.
 * StormRevert event - when percentage of XON frames received
 * within an integration period exceeds the configured threshold.
 * Actual number of XOFF/XON frames for the events to be triggered
 * depends on both configured integration period and sampling rate.
 * The statistics in this structure represent counts of specified
 * events from the moment the feature (PFC WatchDog) is enabled via
 * hwrm_queue_pfc_enable_cfg call.
 */
/* rx_port_stats_ext_pfc_wd (size:5120b/640B) */
struct rx_port_stats_ext_pfc_wd {
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri0;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri1;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri2;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri3;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri4;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri5;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri6;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri7;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri0;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri1;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri2;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri3;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri4;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri5;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri6;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri7;
	/*
	 * Total number of packets received during PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri0;
	/*
	 * Total number of packets received during PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri1;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri2;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri3;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri4;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri5;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri6;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri7;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri0;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri1;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri2;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri3;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri4;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri5;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri6;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri7;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri0;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri1;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri2;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri3;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri4;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri5;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri6;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri7;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri0;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri1;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri2;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri3;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri4;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri5;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri6;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri7;
	/*
	 * Number of packets received during last PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri0;
	/*
	 * Number of packets received during last PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri1;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri2;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri3;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri4;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri5;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri6;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri7;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri0;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri1;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri2;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri3;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri4;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri5;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri6;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri7;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri0;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri1;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri2;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri3;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri4;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri5;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri6;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri7;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri0;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri1;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri2;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri3;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri4;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri5;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri6;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri7;
} __rte_packed;

/************************
 * hwrm_port_qstats_ext *
 ************************/


/* hwrm_port_qstats_ext_input (size:320b/40B) */
struct hwrm_port_qstats_ext_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	/*
	 * The size of TX port extended
	 * statistics block in bytes.
	 */
	uint16_t	tx_stat_size;
	/*
	 * The size of RX port extended
	 * statistics block in bytes
	 */
	uint16_t	rx_stat_size;
	uint8_t	flags;
	/*
	 * This bit is set to 1 when request is for the counter mask,
	 * representing width of each of the stats counters, rather than
	 * counters themselves.
	 */
	#define HWRM_PORT_QSTATS_EXT_INPUT_FLAGS_COUNTER_MASK     UINT32_C(0x1)
	uint8_t	unused_0;
	/*
	 * This is the host address where
	 * Tx port statistics will be stored
	 */
	uint64_t	tx_stat_host_addr;
	/*
	 * This is the host address where
	 * Rx port statistics will be stored
	 */
	uint64_t	rx_stat_host_addr;
} __rte_packed;

/* hwrm_port_qstats_ext_output (size:128b/16B) */
struct hwrm_port_qstats_ext_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The size of TX port statistics block in bytes. */
	uint16_t	tx_stat_size;
	/* The size of RX port statistics block in bytes. */
	uint16_t	rx_stat_size;
	/* Total number of active cos queues available. */
	uint16_t	total_active_cos_queues;
	uint8_t	flags;
	/*
	 * If set to 1, then this field indicates that clear
	 * roce specific counters is supported.
	 */
	#define HWRM_PORT_QSTATS_EXT_OUTPUT_FLAGS_CLEAR_ROCE_COUNTERS_SUPPORTED \
		UINT32_C(0x1)
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************************
 * hwrm_port_qstats_ext_pfc_wd *
 *******************************/


/* hwrm_port_qstats_ext_pfc_wd_input (size:256b/32B) */
struct hwrm_port_qstats_ext_pfc_wd_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	/*
	 * The size of rx_port_stats_ext_pfc_wd
	 * block in bytes
	 */
	uint16_t	pfc_wd_stat_size;
	uint8_t	unused_0[4];
	/*
	 * This is the host address where
	 * rx_port_stats_ext_pfc_wd will be stored
	 */
	uint64_t	pfc_wd_stat_host_addr;
} __rte_packed;

/* hwrm_port_qstats_ext_pfc_wd_output (size:128b/16B) */
struct hwrm_port_qstats_ext_pfc_wd_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The size of rx_port_stats_ext_pfc_wd
	 * statistics block in bytes.
	 */
	uint16_t	pfc_wd_stat_size;
	uint8_t	flags;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
	uint8_t	unused_0[4];
} __rte_packed;

/*************************
 * hwrm_port_lpbk_qstats *
 *************************/


/* hwrm_port_lpbk_qstats_input (size:128b/16B) */
struct hwrm_port_lpbk_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_port_lpbk_qstats_output (size:768b/96B) */
struct hwrm_port_lpbk_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of transmitted unicast frames */
	uint64_t	lpbk_ucast_frames;
	/* Number of transmitted multicast frames */
	uint64_t	lpbk_mcast_frames;
	/* Number of transmitted broadcast frames */
	uint64_t	lpbk_bcast_frames;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	lpbk_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	lpbk_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	lpbk_bcast_bytes;
	/* Total Tx Drops for loopback traffic reported by STATS block */
	uint64_t	tx_stat_discard;
	/* Total Tx Error Drops for loopback traffic reported by STATS block */
	uint64_t	tx_stat_error;
	/* Total Rx Drops for loopback traffic reported by STATS block */
	uint64_t	rx_stat_discard;
	/* Total Rx Error Drops for loopback traffic reported by STATS block */
	uint64_t	rx_stat_error;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_port_ecn_qstats *
 ************************/


/* hwrm_port_ecn_qstats_input (size:256b/32B) */
struct hwrm_port_ecn_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port that is being queried. Unused if NIC is in
	 * multi-host mode.
	 */
	uint16_t	port_id;
	/*
	 * Size of the DMA buffer the caller has allocated for the firmware to
	 * write into.
	 */
	uint16_t	ecn_stat_buf_size;
	uint8_t	flags;
	/*
	 * This bit is set to 1 when request is for a counter mask,
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_PORT_ECN_QSTATS_INPUT_FLAGS_COUNTER_MASK     UINT32_C(0x1)
	uint8_t	unused_0[3];
	/*
	 * This is the host address where
	 * ECN port statistics will be stored
	 */
	uint64_t	ecn_stat_host_addr;
} __rte_packed;

/* hwrm_port_ecn_qstats_output (size:128b/16B) */
struct hwrm_port_ecn_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of bytes of stats the firmware wrote to the DMA buffer. */
	uint16_t	ecn_stat_buf_size;
	/*
	 * Bitmask that indicates which CoS queues have ECN marking enabled.
	 * Bit i corresponds to CoS queue i.
	 */
	uint8_t	mark_en;
	uint8_t	unused_0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* ECN mark statistics format */
/* port_stats_ecn (size:512b/64B) */
struct port_stats_ecn {
	/*
	 * Number of packets marked in CoS queue 0.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos0;
	/*
	 * Number of packets marked in CoS queue 1.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos1;
	/*
	 * Number of packets marked in CoS queue 2.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos2;
	/*
	 * Number of packets marked in CoS queue 3.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos3;
	/*
	 * Number of packets marked in CoS queue 4.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos4;
	/*
	 * Number of packets marked in CoS queue 5.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos5;
	/*
	 * Number of packets marked in CoS queue 6.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos6;
	/*
	 * Number of packets marked in CoS queue 7.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos7;
} __rte_packed;

/***********************
 * hwrm_port_clr_stats *
 ***********************/


/* hwrm_port_clr_stats_input (size:192b/24B) */
struct hwrm_port_clr_stats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	uint8_t	flags;
	/*
	 * If set to 1, then this field indicates clear the following RoCE
	 * specific counters.
	 * RoCE associated TX/RX cos counters
	 * CNP associated TX/RX cos counters
	 * RoCE/CNP specific TX/RX flow counters
	 * Firmware will determine the RoCE/CNP cos queue based on qos profile.
	 * This flag is honored only when RoCE is enabled on that port.
	 */
	#define HWRM_PORT_CLR_STATS_INPUT_FLAGS_ROCE_COUNTERS     UINT32_C(0x1)
	uint8_t	unused_0[5];
} __rte_packed;

/* hwrm_port_clr_stats_output (size:128b/16B) */
struct hwrm_port_clr_stats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_port_phy_qcaps *
 ***********************/


/* hwrm_port_phy_qcaps_input (size:192b/24B) */
struct hwrm_port_phy_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_port_phy_qcaps_output (size:256b/32B) */
struct hwrm_port_phy_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* PHY capability flags */
	uint8_t	flags;
	/*
	 * If set to 1, then this field indicates that the
	 * link is capable of supporting EEE.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_EEE_SUPPORTED \
		UINT32_C(0x1)
	/*
	 * If set to 1, then this field indicates that the
	 * PHY is capable of supporting external loopback.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_EXTERNAL_LPBK_SUPPORTED \
		UINT32_C(0x2)
	/*
	 * If set to 1, then this field indicates that the
	 * PHY is capable of supporting loopback in autoneg mode.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_AUTONEG_LPBK_SUPPORTED \
		UINT32_C(0x4)
	/*
	 * Indicates if the configuration of shared PHY settings is supported.
	 * In cases where a physical port is shared by multiple functions
	 * (e.g. NPAR, multihost, etc), the configuration of PHY
	 * settings may not be allowed. Callers to HWRM_PORT_PHY_CFG will
	 * get an HWRM_ERR_CODE_RESOURCE_ACCESS_DENIED error in this case.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_SHARED_PHY_CFG_SUPPORTED \
		UINT32_C(0x8)
	/*
	 * If set to 1, it indicates that the port counters and extended
	 * port counters will not reset when the firmware shuts down or
	 * resets the PHY.  These counters will only be reset during power
	 * cycle or by calling HWRM_PORT_CLR_STATS.
	 * If set to 0, the state of the counters is unspecified when
	 * firmware shuts down or resets the PHY.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_CUMULATIVE_COUNTERS_ON_RESET \
		UINT32_C(0x10)
	/*
	 * If set to 1, then this field indicates that the
	 * local loopback is not supported on this controller.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_LOCAL_LPBK_NOT_SUPPORTED \
		UINT32_C(0x20)
	/*
	 * If set to 1, then this field indicates that the
	 * PHY/Link down policy during PF shutdown is totally
	 * controlled by the firmware. It can shutdown the link
	 * even when there are active VFs associated with the PF.
	 * Host PF driver can send HWRM_PHY_CFG command to bring
	 * down the PHY even when the port is shared between VFs
	 * and PFs.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_FW_MANAGED_LINK_DOWN \
		UINT32_C(0x40)
	/*
	 * If set to 1, this field indicates that the FCS may
	 * be disabled for a given packet via the transmit
	 * buffer descriptor.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_NO_FCS \
		UINT32_C(0x80)
	/* Number of front panel ports for this device. */
	uint8_t	port_cnt;
	/* Not supported or unknown */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_UNKNOWN UINT32_C(0x0)
	/* single port device */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_1       UINT32_C(0x1)
	/* 2-port device */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_2       UINT32_C(0x2)
	/* 3-port device */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_3       UINT32_C(0x3)
	/* 4-port device */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_4       UINT32_C(0x4)
	/* 12-port device */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_12      UINT32_C(0xc)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_LAST \
		HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_12
	/*
	 * This is a bit mask to indicate what speeds are supported
	 * as forced speeds on this link.
	 * For each speed that can be forced on this link, the
	 * corresponding mask bit shall be set to '1'.
	 */
	uint16_t	supported_speeds_force_mode;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_100MBHD \
		UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_100MB \
		UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_1GBHD \
		UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_1GB \
		UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_2GB \
		UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_2_5GB \
		UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_10GB \
		UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_20GB \
		UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_25GB \
		UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_40GB \
		UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_50GB \
		UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_100GB \
		UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_10MBHD \
		UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_10MB \
		UINT32_C(0x2000)
	/*
	 * This is a bit mask to indicate what speeds are supported
	 * for autonegotiation on this link.
	 * For each speed that can be autonegotiated on this link, the
	 * corresponding mask bit shall be set to '1'.
	 */
	uint16_t	supported_speeds_auto_mode;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_100MBHD \
		UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_100MB \
		UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_1GBHD \
		UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_1GB \
		UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_2GB \
		UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_2_5GB \
		UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_10GB \
		UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_20GB \
		UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_25GB \
		UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_40GB \
		UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_50GB \
		UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_100GB \
		UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_10MBHD \
		UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_10MB \
		UINT32_C(0x2000)
	/*
	 * This is a bit mask to indicate what speeds are supported
	 * for EEE on this link.
	 * For each speed that can be autonegotiated when EEE is enabled
	 * on this link, the corresponding mask bit shall be set to '1'.
	 * This field is only valid when the eee_supported is set to '1'.
	 */
	uint16_t	supported_speeds_eee_mode;
	/* Reserved */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_RSVD1 \
		UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_100MB \
		UINT32_C(0x2)
	/* Reserved */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_RSVD2 \
		UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_1GB \
		UINT32_C(0x8)
	/* Reserved */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_RSVD3 \
		UINT32_C(0x10)
	/* Reserved */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_RSVD4 \
		UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_10GB \
		UINT32_C(0x40)
	uint32_t	tx_lpi_timer_low;
	/*
	 * The lowest value of TX LPI timer that can be set on this link
	 * when EEE is enabled. This value is in microseconds.
	 * This field is valid only when_eee_supported is set to '1'.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_TX_LPI_TIMER_LOW_MASK \
		UINT32_C(0xffffff)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_TX_LPI_TIMER_LOW_SFT 0
	/*
	 * Reserved field. The HWRM shall set this field to 0.
	 * An HWRM client shall ignore this field.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_RSVD2_MASK \
		UINT32_C(0xff000000)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_RSVD2_SFT            24
	uint32_t	valid_tx_lpi_timer_high;
	/*
	 * The highest value of TX LPI timer that can be set on this link
	 * when EEE is enabled. This value is in microseconds.
	 * This field is valid only when_eee_supported is set to '1'.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_TX_LPI_TIMER_HIGH_MASK \
		UINT32_C(0xffffff)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_TX_LPI_TIMER_HIGH_SFT 0
	/*
	 * Reserved field. The HWRM shall set this field to 0.
	 * An HWRM client shall ignore this field.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_RSVD_MASK \
		UINT32_C(0xff000000)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_RSVD_SFT              24
	/*
	 * This field is used to advertise which PAM4 speeds are supported
	 * in auto mode.
	 */
	uint16_t	supported_pam4_speeds_auto_mode;
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_AUTO_MODE_50G \
		UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_AUTO_MODE_100G \
		UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_AUTO_MODE_200G \
		UINT32_C(0x4)
	/*
	 * This field is used to advertise which PAM4 speeds are supported
	 * in forced mode.
	 */
	uint16_t	supported_pam4_speeds_force_mode;
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_FORCE_MODE_50G \
		UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_FORCE_MODE_100G \
		UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_FORCE_MODE_200G \
		UINT32_C(0x4)
	/* More PHY capability flags */
	uint16_t	flags2;
	/*
	 * If set to 1, then this field indicates that
	 * 802.3x flow control is not supported.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS2_PAUSE_UNSUPPORTED \
		UINT32_C(0x1)
	/*
	 * If set to 1, then this field indicates that
	 * priority-based flow control is not supported.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS2_PFC_UNSUPPORTED \
		UINT32_C(0x2)
	/*
	 * If set to 1, then this field indicates that
	 * bank based addressing is supported in firmware.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS2_BANK_ADDR_SUPPORTED \
		UINT32_C(0x4)
	/*
	 * Number of internal ports for this device. This field allows the FW
	 * to advertise how many internal ports are present. Manufacturing
	 * tools uses this to determine how many internal ports should have
	 * the PRBS test run on them. This field always return 0 unless NVM
	 * option "HPTN_MODE" is set to 1.
	 */
	uint8_t	internal_port_cnt;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/****************************
 * hwrm_port_phy_mdio_write *
 ****************************/


/* hwrm_port_phy_mdio_write_input (size:320b/40B) */
struct hwrm_port_phy_mdio_write_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Reserved for future use. */
	uint32_t	unused_0[2];
	/* Port ID of port. */
	uint16_t	port_id;
	/* If phy_address is 0xFF, port_id will be used to derive phy_addr. */
	uint8_t	phy_addr;
	/* 8-bit device address. */
	uint8_t	dev_addr;
	/* 16-bit register address. */
	uint16_t	reg_addr;
	/* 16-bit register data. */
	uint16_t	reg_data;
	/*
	 * When this bit is set to 1 a Clause 45 mdio access is done.
	 * when this bit is set to 0 a Clause 22 mdio access is done.
	 */
	uint8_t	cl45_mdio;
	/*  */
	uint8_t	unused_1[7];
} __rte_packed;

/* hwrm_port_phy_mdio_write_output (size:128b/16B) */
struct hwrm_port_phy_mdio_write_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_port_phy_mdio_read *
 ***************************/


/* hwrm_port_phy_mdio_read_input (size:256b/32B) */
struct hwrm_port_phy_mdio_read_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Reserved for future use. */
	uint32_t	unused_0[2];
	/* Port ID of port. */
	uint16_t	port_id;
	/* If phy_address is 0xFF, port_id will be used to derive phy_addr. */
	uint8_t	phy_addr;
	/* 8-bit device address. */
	uint8_t	dev_addr;
	/* 16-bit register address. */
	uint16_t	reg_addr;
	/*
	 * When this bit is set to 1 a Clause 45 mdio access is done.
	 * when this bit is set to 0 a Clause 22 mdio access is done.
	 */
	uint8_t	cl45_mdio;
	/*  */
	uint8_t	unused_1;
} __rte_packed;

/* hwrm_port_phy_mdio_read_output (size:128b/16B) */
struct hwrm_port_phy_mdio_read_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* 16-bit register data. */
	uint16_t	reg_data;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_port_led_cfg *
 *********************/


/* hwrm_port_led_cfg_input (size:512b/64B) */
struct hwrm_port_led_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the led0_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_ID \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the led0_state field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_STATE \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the led0_color field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_COLOR \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the led0_blink_on field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_BLINK_ON \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the led0_blink_off field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_BLINK_OFF \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the led0_group_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_GROUP_ID \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the led1_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_ID \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the led1_state field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_STATE \
		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the led1_color field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_COLOR \
		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the led1_blink_on field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_BLINK_ON \
		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the led1_blink_off field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_BLINK_OFF \
		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the led1_group_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_GROUP_ID \
		UINT32_C(0x800)
	/*
	 * This bit must be '1' for the led2_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_ID \
		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the led2_state field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_STATE \
		UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the led2_color field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_COLOR \
		UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the led2_blink_on field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_BLINK_ON \
		UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the led2_blink_off field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_BLINK_OFF \
		UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the led2_group_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_GROUP_ID \
		UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the led3_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_ID \
		UINT32_C(0x40000)
	/*
	 * This bit must be '1' for the led3_state field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_STATE \
		UINT32_C(0x80000)
	/*
	 * This bit must be '1' for the led3_color field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_COLOR \
		UINT32_C(0x100000)
	/*
	 * This bit must be '1' for the led3_blink_on field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_BLINK_ON \
		UINT32_C(0x200000)
	/*
	 * This bit must be '1' for the led3_blink_off field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_BLINK_OFF \
		UINT32_C(0x400000)
	/*
	 * This bit must be '1' for the led3_group_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_GROUP_ID \
		UINT32_C(0x800000)
	/* Port ID of port whose LEDs are configured. */
	uint16_t	port_id;
	/*
	 * The number of LEDs that are being configured.
	 * Up to 4 LEDs can be configured with this command.
	 */
	uint8_t	num_leds;
	/* Reserved field. */
	uint8_t	rsvd;
	/* An identifier for the LED #0. */
	uint8_t	led0_id;
	/* The requested state of the LED #0. */
	uint8_t	led0_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_OFF      UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_ON       UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_BLINK    UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_LAST \
		HWRM_PORT_LED_CFG_INPUT_LED0_STATE_BLINKALT
	/* The requested color of LED #0. */
	uint8_t	led0_color;
	/* Default */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_DEFAULT    UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_AMBER      UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_GREEN      UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_LAST \
		HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_GREENAMBER
	uint8_t	unused_0;
	/*
	 * If the LED #0 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led0_blink_on;
	/*
	 * If the LED #0 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led0_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #0 belongs
	 * to.
	 * If set to 0, then the LED #0 shall not be grouped and
	 * shall be treated as an individual resource.
	 * For all other non-zero values of this field, LED #0 shall
	 * be grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led0_group_id;
	/* Reserved field. */
	uint8_t	rsvd0;
	/* An identifier for the LED #1. */
	uint8_t	led1_id;
	/* The requested state of the LED #1. */
	uint8_t	led1_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_OFF      UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_ON       UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_BLINK    UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_LAST \
		HWRM_PORT_LED_CFG_INPUT_LED1_STATE_BLINKALT
	/* The requested color of LED #1. */
	uint8_t	led1_color;
	/* Default */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_DEFAULT    UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_AMBER      UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_GREEN      UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_LAST \
		HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_GREENAMBER
	uint8_t	unused_1;
	/*
	 * If the LED #1 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led1_blink_on;
	/*
	 * If the LED #1 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led1_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #1 belongs
	 * to.
	 * If set to 0, then the LED #1 shall not be grouped and
	 * shall be treated as an individual resource.
	 * For all other non-zero values of this field, LED #1 shall
	 * be grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led1_group_id;
	/* Reserved field. */
	uint8_t	rsvd1;
	/* An identifier for the LED #2. */
	uint8_t	led2_id;
	/* The requested state of the LED #2. */
	uint8_t	led2_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_OFF      UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_ON       UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_BLINK    UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_LAST \
		HWRM_PORT_LED_CFG_INPUT_LED2_STATE_BLINKALT
	/* The requested color of LED #2. */
	uint8_t	led2_color;
	/* Default */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_DEFAULT    UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_AMBER      UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_GREEN      UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_LAST \
		HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_GREENAMBER
	uint8_t	unused_2;
	/*
	 * If the LED #2 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led2_blink_on;
	/*
	 * If the LED #2 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led2_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #2 belongs
	 * to.
	 * If set to 0, then the LED #2 shall not be grouped and
	 * shall be treated as an individual resource.
	 * For all other non-zero values of this field, LED #2 shall
	 * be grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led2_group_id;
	/* Reserved field. */
	uint8_t	rsvd2;
	/* An identifier for the LED #3. */
	uint8_t	led3_id;
	/* The requested state of the LED #3. */
	uint8_t	led3_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_OFF      UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_ON       UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_BLINK    UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_LAST \
		HWRM_PORT_LED_CFG_INPUT_LED3_STATE_BLINKALT
	/* The requested color of LED #3. */
	uint8_t	led3_color;
	/* Default */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_DEFAULT    UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_AMBER      UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_GREEN      UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_LAST \
		HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_GREENAMBER
	uint8_t	unused_3;
	/*
	 * If the LED #3 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led3_blink_on;
	/*
	 * If the LED #3 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led3_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #3 belongs
	 * to.
	 * If set to 0, then the LED #3 shall not be grouped and
	 * shall be treated as an individual resource.
	 * For all other non-zero values of this field, LED #3 shall
	 * be grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led3_group_id;
	/* Reserved field. */
	uint8_t	rsvd3;
} __rte_packed;

/* hwrm_port_led_cfg_output (size:128b/16B) */
struct hwrm_port_led_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_port_led_qcfg *
 **********************/


/* hwrm_port_led_qcfg_input (size:192b/24B) */
struct hwrm_port_led_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port whose LED configuration is being queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_port_led_qcfg_output (size:448b/56B) */
struct hwrm_port_led_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The number of LEDs that are configured on this port.
	 * Up to 4 LEDs can be returned in the response.
	 */
	uint8_t	num_leds;
	/* An identifier for the LED #0. */
	uint8_t	led0_id;
	/* The type of LED #0. */
	uint8_t	led0_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_SPEED    UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_LAST \
		HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_INVALID
	/* The current state of the LED #0. */
	uint8_t	led0_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_OFF      UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_ON       UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_BLINK    UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_LAST \
		HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_BLINKALT
	/* The color of LED #0. */
	uint8_t	led0_color;
	/* Default */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_DEFAULT    UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_AMBER      UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_GREEN      UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_LAST \
		HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_GREENAMBER
	uint8_t	unused_0;
	/*
	 * If the LED #0 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led0_blink_on;
	/*
	 * If the LED #0 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led0_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #0 belongs
	 * to.
	 * If set to 0, then the LED #0 is not grouped.
	 * For all other non-zero values of this field, LED #0 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led0_group_id;
	/* An identifier for the LED #1. */
	uint8_t	led1_id;
	/* The type of LED #1. */
	uint8_t	led1_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_SPEED    UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_LAST \
		HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_INVALID
	/* The current state of the LED #1. */
	uint8_t	led1_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_OFF      UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_ON       UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_BLINK    UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_LAST \
		HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_BLINKALT
	/* The color of LED #1. */
	uint8_t	led1_color;
	/* Default */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_DEFAULT    UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_AMBER      UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_GREEN      UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_LAST \
		HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_GREENAMBER
	uint8_t	unused_1;
	/*
	 * If the LED #1 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led1_blink_on;
	/*
	 * If the LED #1 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led1_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #1 belongs
	 * to.
	 * If set to 0, then the LED #1 is not grouped.
	 * For all other non-zero values of this field, LED #1 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led1_group_id;
	/* An identifier for the LED #2. */
	uint8_t	led2_id;
	/* The type of LED #2. */
	uint8_t	led2_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_SPEED    UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_LAST \
		HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_INVALID
	/* The current state of the LED #2. */
	uint8_t	led2_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_OFF      UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_ON       UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_BLINK    UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_LAST \
		HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_BLINKALT
	/* The color of LED #2. */
	uint8_t	led2_color;
	/* Default */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_DEFAULT    UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_AMBER      UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_GREEN      UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_LAST \
		HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_GREENAMBER
	uint8_t	unused_2;
	/*
	 * If the LED #2 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led2_blink_on;
	/*
	 * If the LED #2 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led2_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #2 belongs
	 * to.
	 * If set to 0, then the LED #2 is not grouped.
	 * For all other non-zero values of this field, LED #2 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led2_group_id;
	/* An identifier for the LED #3. */
	uint8_t	led3_id;
	/* The type of LED #3. */
	uint8_t	led3_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_SPEED    UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_LAST \
		HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_INVALID
	/* The current state of the LED #3. */
	uint8_t	led3_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_OFF      UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_ON       UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_BLINK    UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_LAST \
		HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_BLINKALT
	/* The color of LED #3. */
	uint8_t	led3_color;
	/* Default */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_DEFAULT    UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_AMBER      UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_GREEN      UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_LAST \
		HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_GREENAMBER
	uint8_t	unused_3;
	/*
	 * If the LED #3 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led3_blink_on;
	/*
	 * If the LED #3 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led3_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #3 belongs
	 * to.
	 * If set to 0, then the LED #3 is not grouped.
	 * For all other non-zero values of this field, LED #3 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led3_group_id;
	uint8_t	unused_4[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_port_led_qcaps *
 ***********************/


/* hwrm_port_led_qcaps_input (size:192b/24B) */
struct hwrm_port_led_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port whose LED configuration is being queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_port_led_qcaps_output (size:384b/48B) */
struct hwrm_port_led_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The number of LEDs that are configured on this port.
	 * Up to 4 LEDs can be returned in the response.
	 */
	uint8_t	num_leds;
	/* Reserved for future use. */
	uint8_t	unused[3];
	/* An identifier for the LED #0. */
	uint8_t	led0_id;
	/* The type of LED #0. */
	uint8_t	led0_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_SPEED    UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_LAST \
		HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_INVALID
	/*
	 * An identifier for the group of LEDs that LED #0 belongs
	 * to.
	 * If set to 0, then the LED #0 cannot be grouped.
	 * For all other non-zero values of this field, LED #0 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led0_group_id;
	uint8_t	unused_0;
	/* The states supported by LED #0. */
	uint16_t	led0_state_caps;
	/*
	 * If set to 1, this LED is enabled.
	 * If set to 0, this LED is disabled.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_ENABLED \
		UINT32_C(0x1)
	/*
	 * If set to 1, off state is supported on this LED.
	 * If set to 0, off state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_OFF_SUPPORTED \
		UINT32_C(0x2)
	/*
	 * If set to 1, on state is supported on this LED.
	 * If set to 0, on state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_ON_SUPPORTED \
		UINT32_C(0x4)
	/*
	 * If set to 1, blink state is supported on this LED.
	 * If set to 0, blink state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_BLINK_SUPPORTED \
		UINT32_C(0x8)
	/*
	 * If set to 1, blink_alt state is supported on this LED.
	 * If set to 0, blink_alt state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_BLINK_ALT_SUPPORTED \
		UINT32_C(0x10)
	/* The colors supported by LED #0. */
	uint16_t	led0_color_caps;
	/* reserved. */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_COLOR_CAPS_RSVD \
		UINT32_C(0x1)
	/*
	 * If set to 1, Amber color is supported on this LED.
	 * If set to 0, Amber color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_COLOR_CAPS_AMBER_SUPPORTED \
		UINT32_C(0x2)
	/*
	 * If set to 1, Green color is supported on this LED.
	 * If set to 0, Green color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_COLOR_CAPS_GREEN_SUPPORTED \
		UINT32_C(0x4)
	/* An identifier for the LED #1. */
	uint8_t	led1_id;
	/* The type of LED #1. */
	uint8_t	led1_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_SPEED    UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_LAST \
		HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_INVALID
	/*
	 * An identifier for the group of LEDs that LED #1 belongs
	 * to.
	 * If set to 0, then the LED #0 cannot be grouped.
	 * For all other non-zero values of this field, LED #0 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led1_group_id;
	uint8_t	unused_1;
	/* The states supported by LED #1. */
	uint16_t	led1_state_caps;
	/*
	 * If set to 1, this LED is enabled.
	 * If set to 0, this LED is disabled.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_ENABLED \
		UINT32_C(0x1)
	/*
	 * If set to 1, off state is supported on this LED.
	 * If set to 0, off state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_OFF_SUPPORTED \
		UINT32_C(0x2)
	/*
	 * If set to 1, on state is supported on this LED.
	 * If set to 0, on state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_ON_SUPPORTED \
		UINT32_C(0x4)
	/*
	 * If set to 1, blink state is supported on this LED.
	 * If set to 0, blink state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_BLINK_SUPPORTED \
		UINT32_C(0x8)
	/*
	 * If set to 1, blink_alt state is supported on this LED.
	 * If set to 0, blink_alt state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_BLINK_ALT_SUPPORTED \
		UINT32_C(0x10)
	/* The colors supported by LED #1. */
	uint16_t	led1_color_caps;
	/* reserved. */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_COLOR_CAPS_RSVD \
		UINT32_C(0x1)
	/*
	 * If set to 1, Amber color is supported on this LED.
	 * If set to 0, Amber color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_COLOR_CAPS_AMBER_SUPPORTED \
		UINT32_C(0x2)
	/*
	 * If set to 1, Green color is supported on this LED.
	 * If set to 0, Green color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_COLOR_CAPS_GREEN_SUPPORTED \
		UINT32_C(0x4)
	/* An identifier for the LED #2. */
	uint8_t	led2_id;
	/* The type of LED #2. */
	uint8_t	led2_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_SPEED    UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_LAST \
		HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_INVALID
	/*
	 * An identifier for the group of LEDs that LED #0 belongs
	 * to.
	 * If set to 0, then the LED #0 cannot be grouped.
	 * For all other non-zero values of this field, LED #0 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led2_group_id;
	uint8_t	unused_2;
	/* The states supported by LED #2. */
	uint16_t	led2_state_caps;
	/*
	 * If set to 1, this LED is enabled.
	 * If set to 0, this LED is disabled.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_ENABLED \
		UINT32_C(0x1)
	/*
	 * If set to 1, off state is supported on this LED.
	 * If set to 0, off state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_OFF_SUPPORTED \
		UINT32_C(0x2)
	/*
	 * If set to 1, on state is supported on this LED.
	 * If set to 0, on state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_ON_SUPPORTED \
		UINT32_C(0x4)
	/*
	 * If set to 1, blink state is supported on this LED.
	 * If set to 0, blink state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_BLINK_SUPPORTED \
		UINT32_C(0x8)
	/*
	 * If set to 1, blink_alt state is supported on this LED.
	 * If set to 0, blink_alt state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_BLINK_ALT_SUPPORTED \
		UINT32_C(0x10)
	/* The colors supported by LED #2. */
	uint16_t	led2_color_caps;
	/* reserved. */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_COLOR_CAPS_RSVD \
		UINT32_C(0x1)
	/*
	 * If set to 1, Amber color is supported on this LED.
	 * If set to 0, Amber color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_COLOR_CAPS_AMBER_SUPPORTED \
		UINT32_C(0x2)
	/*
	 * If set to 1, Green color is supported on this LED.
	 * If set to 0, Green color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_COLOR_CAPS_GREEN_SUPPORTED \
		UINT32_C(0x4)
	/* An identifier for the LED #3. */
	uint8_t	led3_id;
	/* The type of LED #3. */
	uint8_t	led3_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_SPEED    UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_LAST \
		HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_INVALID
	/*
	 * An identifier for the group of LEDs that LED #3 belongs
	 * to.
	 * If set to 0, then the LED #0 cannot be grouped.
	 * For all other non-zero values of this field, LED #0 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led3_group_id;
	uint8_t	unused_3;
	/* The states supported by LED #3. */
	uint16_t	led3_state_caps;
	/*
	 * If set to 1, this LED is enabled.
	 * If set to 0, this LED is disabled.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_ENABLED \
		UINT32_C(0x1)
	/*
	 * If set to 1, off state is supported on this LED.
	 * If set to 0, off state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_OFF_SUPPORTED \
		UINT32_C(0x2)
	/*
	 * If set to 1, on state is supported on this LED.
	 * If set to 0, on state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_ON_SUPPORTED \
		UINT32_C(0x4)
	/*
	 * If set to 1, blink state is supported on this LED.
	 * If set to 0, blink state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_BLINK_SUPPORTED \
		UINT32_C(0x8)
	/*
	 * If set to 1, blink_alt state is supported on this LED.
	 * If set to 0, blink_alt state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_BLINK_ALT_SUPPORTED \
		UINT32_C(0x10)
	/* The colors supported by LED #3. */
	uint16_t	led3_color_caps;
	/* reserved. */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_COLOR_CAPS_RSVD \
		UINT32_C(0x1)
	/*
	 * If set to 1, Amber color is supported on this LED.
	 * If set to 0, Amber color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_COLOR_CAPS_AMBER_SUPPORTED \
		UINT32_C(0x2)
	/*
	 * If set to 1, Green color is supported on this LED.
	 * If set to 0, Green color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_COLOR_CAPS_GREEN_SUPPORTED \
		UINT32_C(0x4)
	uint8_t	unused_4[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_port_prbs_test *
 ***********************/


/* hwrm_port_prbs_test_input (size:384b/48B) */
struct hwrm_port_prbs_test_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Host address data is to DMA'd to. */
	uint64_t	resp_data_addr;
	/*
	 * Size of the buffer pointed to by resp_data_addr. The firmware may
	 * use this entire buffer or less than the entire buffer, but never more.
	 */
	uint16_t	data_len;
	uint16_t	flags;
	/*
	 * If set, the port_id field should be interpreted as an internal
	 * port. The internal port id range is returned in port_phy_qcaps
	 * response internal_port_cnt field.
	 */
	#define HWRM_PORT_PRBS_TEST_INPUT_FLAGS_INTERNAL     UINT32_C(0x1)
	uint32_t	unused_1;
	/* Port ID of port where PRBS test to be run. */
	uint16_t	port_id;
	/* Polynomial selection for PRBS test. */
	uint16_t	poly;
	/* PRBS7 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS7   UINT32_C(0x0)
	/* PRBS9 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS9   UINT32_C(0x1)
	/* PRBS11 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS11  UINT32_C(0x2)
	/* PRBS15 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS15  UINT32_C(0x3)
	/* PRBS23 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS23  UINT32_C(0x4)
	/* PRBS31 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS31  UINT32_C(0x5)
	/* PRBS58 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS58  UINT32_C(0x6)
	/* PRBS49 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS49  UINT32_C(0x7)
	/* PRBS10 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS10  UINT32_C(0x8)
	/* PRBS20 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS20  UINT32_C(0x9)
	/* PRBS13 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS13  UINT32_C(0xa)
	/* Invalid */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_INVALID UINT32_C(0xff)
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_LAST \
		HWRM_PORT_PRBS_TEST_INPUT_POLY_INVALID
	/*
	 * Configuration bits for PRBS test.
	 * Use enable bit to start/stop test.
	 * Use tx/rx lane map bits to run test on specific lanes,
	 * if set to 0 test will be run on all lanes.
	 */
	uint16_t	prbs_config;
	/*
	 * Set 0 to stop test currently in progress
	 * Set 1 to start test with configuration provided.
	 */
	#define HWRM_PORT_PRBS_TEST_INPUT_PRBS_CONFIG_START_STOP \
		UINT32_C(0x1)
	/*
	 * If set to 1, tx_lane_map bitmap should have lane bits set.
	 * If set to 0, test will be run on all lanes for this port.
	 */
	#define HWRM_PORT_PRBS_TEST_INPUT_PRBS_CONFIG_TX_LANE_MAP_VALID \
		UINT32_C(0x2)
	/*
	 * If set to 1, rx_lane_map bitmap should have lane bits set.
	 * If set to 0, test will be run on all lanes for this port.
	 */
	#define HWRM_PORT_PRBS_TEST_INPUT_PRBS_CONFIG_RX_LANE_MAP_VALID \
		UINT32_C(0x4)
	/* If set to 1, FEC stat t-code 0-7 registers are enabled. */
	#define HWRM_PORT_PRBS_TEST_INPUT_PRBS_CONFIG_FEC_STAT_T0_T7 \
		UINT32_C(0x8)
	/*
	 * If set to 1, FEC stat t-code 8-15 registers are enabled.
	 * If fec_stat_t0_t7 is set, fec_stat_t8_t15 field will be ignored.
	 */
	#define HWRM_PORT_PRBS_TEST_INPUT_PRBS_CONFIG_FEC_STAT_T8_T15 \
		UINT32_C(0x10)
	/* Duration in seconds to run the PRBS test. */
	uint16_t	timeout;
	/*
	 * If tx_lane_map_valid is set to 1, this field is a bitmap
	 * of tx lanes to run PRBS test. bit0 = lane0,
	 * bit1 = lane1 ..bit31 = lane31
	 */
	uint32_t	tx_lane_map;
	/*
	 * If rx_lane_map_valid is set to 1, this field is a bitmap
	 * of rx lanes to run PRBS test. bit0 = lane0,
	 * bit1 = lane1 ..bit31 = lane31
	 */
	uint32_t	rx_lane_map;
} __rte_packed;

/* hwrm_port_prbs_test_output (size:128b/16B) */
struct hwrm_port_prbs_test_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Total length of stored data. */
	uint16_t	total_data_len;
	/* This field is used in Output records to indicate the output format */
	uint8_t	ber_format;
	/* BER_FORMAT_PRBS */
	#define HWRM_PORT_PRBS_TEST_OUTPUT_BER_FORMAT_PRBS UINT32_C(0x0)
	/* BER_FORMAT_FEC */
	#define HWRM_PORT_PRBS_TEST_OUTPUT_BER_FORMAT_FEC  UINT32_C(0x1)
	#define HWRM_PORT_PRBS_TEST_OUTPUT_BER_FORMAT_LAST \
		HWRM_PORT_PRBS_TEST_OUTPUT_BER_FORMAT_FEC
	uint8_t	unused_0;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_port_dsc_dump *
 **********************/


/* hwrm_port_dsc_dump_input (size:320b/40B) */
struct hwrm_port_dsc_dump_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Host address where response diagnostic data is returned. */
	uint64_t	resp_data_addr;
	/*
	 * Size of the buffer pointed to by resp_data_addr. The firmware
	 * may use this entire buffer or less than the entire buffer, but
	 * never more.
	 */
	uint16_t	data_len;
	uint16_t	unused_0;
	uint32_t	unused_1;
	/* Port ID of port where dsc dump to be collected. */
	uint16_t	port_id;
	/* Diag level specified by the user */
	uint16_t	diag_level;
	/* SRDS_DIAG_LANE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_LANE \
		UINT32_C(0x0)
	/* SRDS_DIAG_CORE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_CORE \
		UINT32_C(0x1)
	/* SRDS_DIAG_EVENT */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_EVENT \
		UINT32_C(0x2)
	/* SRDS_DIAG_EYE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_EYE \
		UINT32_C(0x3)
	/* SRDS_DIAG_REG_CORE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_REG_CORE \
		UINT32_C(0x4)
	/* SRDS_DIAG_REG_LANE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_REG_LANE \
		UINT32_C(0x5)
	/* SRDS_DIAG_UC_CORE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_UC_CORE \
		UINT32_C(0x6)
	/* SRDS_DIAG_UC_LANE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_UC_LANE \
		UINT32_C(0x7)
	/* SRDS_DIAG_LANE_DEBUG */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_LANE_DEBUG \
		UINT32_C(0x8)
	/* SRDS_DIAG_BER_VERT */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_BER_VERT \
		UINT32_C(0x9)
	/* SRDS_DIAG_BER_HORZ */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_BER_HORZ \
		UINT32_C(0xa)
	/* SRDS_DIAG_EVENT_SAFE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_EVENT_SAFE \
		UINT32_C(0xb)
	/* SRDS_DIAG_TIMESTAMP */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_TIMESTAMP \
		UINT32_C(0xc)
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_LAST \
		HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_TIMESTAMP
	/*
	 * This field is a lane number
	 * on which to collect the dsc dump
	 */
	uint16_t	lane_number;
	/*
	 * Configuration bits.
	 * Use enable bit to start dsc dump or retrieve dump
	 */
	uint16_t	dsc_dump_config;
	/*
	 * Set 0 to retrieve the dsc dump
	 * Set 1 to start the dsc dump
	 */
	#define HWRM_PORT_DSC_DUMP_INPUT_DSC_DUMP_CONFIG_START_RETRIEVE \
		UINT32_C(0x1)
} __rte_packed;

/* hwrm_port_dsc_dump_output (size:128b/16B) */
struct hwrm_port_dsc_dump_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Total length of stored data. */
	uint16_t	total_data_len;
	uint16_t	unused_0;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************************
 * hwrm_port_sfp_sideband_cfg *
 ******************************/


/* hwrm_port_sfp_sideband_cfg_input (size:256b/32B) */
struct hwrm_port_sfp_sideband_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is to be queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
	/*
	 * This bitfield is used to specify which bits from the 'flags'
	 * fields are being configured by the caller.
	 */
	uint32_t	enables;
	/* This bit must be '1' for rs0 to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_RS0 \
		UINT32_C(0x1)
	/* This bit must be '1' for rs1 to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_RS1 \
		UINT32_C(0x2)
	/* This bit must be '1' for tx_disable to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_TX_DIS \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for mod_sel to be configured.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_MOD_SEL \
		UINT32_C(0x8)
	/* This bit must be '1' for reset_l to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_RESET_L \
		UINT32_C(0x10)
	/* This bit must be '1' for lp_mode to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_LP_MODE \
		UINT32_C(0x20)
	/* This bit must be '1' for pwr_disable to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_PWR_DIS \
		UINT32_C(0x40)
	/*
	 * Only bits that have corresponding bits in the 'enables'
	 * bitfield are processed by the firmware, all other bits
	 * of 'flags' are ignored.
	 */
	uint32_t	flags;
	/*
	 * This bit along with rs1 configures the current speed of the dual
	 * rate module. If these pins are GNDed then the speed can be changed
	 * by directly writing to EEPROM.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_RS0 \
		UINT32_C(0x1)
	/*
	 * This bit along with rs0 configures the current speed of the dual
	 * rate module. If these pins are GNDed then the speed can be changed
	 * by directly writing to EEPROM.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_RS1 \
		UINT32_C(0x2)
	/*
	 * When this bit is set to '1', tx_disable is set.
	 * On a 1G BASE-T module, if this bit is set,
	 * module PHY registers will not be accessible.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_TX_DIS \
		UINT32_C(0x4)
	/*
	 * When this bit is set to '1', this module is selected.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_MOD_SEL \
		UINT32_C(0x8)
	/*
	 * If reset_l is set to 0, Module will be taken out of reset
	 * and other signals will be set to their requested state once
	 * the module is out of reset.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_RESET_L \
		UINT32_C(0x10)
	/*
	 * When this bit is set to '1', the module will be configured
	 * in low power mode.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_LP_MODE \
		UINT32_C(0x20)
	/* When this bit is set to '1', the module will be powered down. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_PWR_DIS \
		UINT32_C(0x40)
} __rte_packed;

/* hwrm_port_sfp_sideband_cfg_output (size:128b/16B) */
struct hwrm_port_sfp_sideband_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************************
 * hwrm_port_sfp_sideband_qcfg *
 *******************************/


/* hwrm_port_sfp_sideband_qcfg_input (size:192b/24B) */
struct hwrm_port_sfp_sideband_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is to be queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_port_sfp_sideband_qcfg_output (size:192b/24B) */
struct hwrm_port_sfp_sideband_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Bitmask indicating which sideband signals are valid.
	 * This is based on the board and nvm cfg that is present on the board.
	 */
	uint32_t	supported_mask;
	uint32_t	sideband_signals;
	/* When this bit is set to '1', the Module is absent. */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_MOD_ABS \
		UINT32_C(0x1)
	/*
	 * When this bit is set to '1', there is no valid signal on RX.
	 * This signal is a filtered version of Signal Detect.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_RX_LOS \
		UINT32_C(0x2)
	/*
	 * This bit along with rs1 indicates the current speed of the dual
	 * rate module.If these pins are grounded then the speed can be
	 * changed by directly writing to EEPROM.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_RS0 \
		UINT32_C(0x4)
	/*
	 * This bit along with rs0 indicates the current speed of the dual
	 * rate module.If these pins are grounded then the speed can be
	 * changed by directly writing to EEPROM.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_RS1 \
		UINT32_C(0x8)
	/*
	 * When this bit is set to '1', tx_disable is set.
	 * On a 1G BASE-T module, if this bit is set, module PHY
	 * registers will not be accessible.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_TX_DIS \
		UINT32_C(0x10)
	/* When this bit is set to '1', tx_fault is set. */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_TX_FAULT \
		UINT32_C(0x20)
	/*
	 * When this bit is set to '1', module is selected.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_MOD_SEL \
		UINT32_C(0x40)
	/*
	 * When this bit is set to '0', the module is held in reset.
	 * if reset_l is set to 1,first module is taken out of reset
	 * and other signals will be set to their requested state.
	 * Valid only on QSFP modules.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_RESET_L \
		UINT32_C(0x80)
	/*
	 * When this bit is set to '1', the module is in low power mode.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_LP_MODE \
		UINT32_C(0x100)
	/* When this bit is set to '1', module is in power down state. */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_PWR_DIS \
		UINT32_C(0x200)
	uint8_t	unused[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************************
 * hwrm_port_phy_mdio_bus_acquire *
 **********************************/


/* hwrm_port_phy_mdio_bus_acquire_input (size:192b/24B) */
struct hwrm_port_phy_mdio_bus_acquire_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of the port. */
	uint16_t	port_id;
	/*
	 * client_id of the client requesting BUS access.
	 * Any value from 0x10 to 0xFFFF can be used.
	 * Client should make sure that the returned client_id
	 * in response matches the client_id in request.
	 * 0-0xF are reserved for internal use.
	 */
	uint16_t	client_id;
	/*
	 * Timeout in milli seconds, MDIO BUS will be released automatically
	 * after this time, if another mdio acquire command is not received
	 * within the timeout window from the same client.
	 * A 0xFFFF will hold the bus until this bus is released.
	 */
	uint16_t	mdio_bus_timeout;
	uint8_t	unused_0[2];
} __rte_packed;

/* hwrm_port_phy_mdio_bus_acquire_output (size:128b/16B) */
struct hwrm_port_phy_mdio_bus_acquire_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint16_t	unused_0;
	/*
	 * client_id of the module holding the BUS.
	 * 0-0xF are reserved for internal use.
	 */
	uint16_t	client_id;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************************
 * hwrm_port_phy_mdio_bus_release *
 **********************************/


/* hwrm_port_phy_mdio_bus_release_input (size:192b/24B) */
struct hwrm_port_phy_mdio_bus_release_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of the port. */
	uint16_t	port_id;
	/*
	 * client_id of the client requesting BUS release.
	 * A client should not release any other clients BUS.
	 */
	uint16_t	client_id;
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_port_phy_mdio_bus_release_output (size:128b/16B) */
struct hwrm_port_phy_mdio_bus_release_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint16_t	unused_0;
	/* The BUS is released if client_id matches the client_id in request. */
	uint16_t	clients_id;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_port_tx_fir_cfg *
 ************************/


/* hwrm_port_tx_fir_cfg_input (size:320b/40B) */
struct hwrm_port_tx_fir_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Modulation types of TX FIR: NRZ, PAM4. */
	uint8_t	mod_type;
	/* For NRZ */
	#define HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_NRZ  UINT32_C(0x0)
	/* For PAM4 */
	#define HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_PAM4 UINT32_C(0x1)
	#define HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_LAST \
		HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_PAM4
	/* The lane mask of the lane TX FIR will be configured. */
	uint8_t	lane_mask;
	uint8_t	unused_0[2];
	/* Value1 of TX FIR, required for NRZ or PAM4. */
	uint32_t	txfir_val_1;
	/* Value2 of TX FIR, required for NRZ or PAM4. */
	uint32_t	txfir_val_2;
	/* Value3 of TX FIR, required for PAM4. */
	uint32_t	txfir_val_3;
	/* Value4 of TX FIR, required for PAM4. */
	uint32_t	txfir_val_4;
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_port_tx_fir_cfg_output (size:128b/16B) */
struct hwrm_port_tx_fir_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_port_tx_fir_qcfg *
 *************************/


/* hwrm_port_tx_fir_qcfg_input (size:192b/24B) */
struct hwrm_port_tx_fir_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Modulation types of TX FIR: NRZ, PAM4. */
	uint8_t	mod_type;
	/* For NRZ */
	#define HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_NRZ  UINT32_C(0x0)
	/* For PAM4 */
	#define HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_PAM4 UINT32_C(0x1)
	#define HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_LAST \
		HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_PAM4
	/* The ID of the lane TX FIR will be queried. */
	uint8_t	lane_id;
	uint8_t	unused[6];
} __rte_packed;

/* hwrm_port_tx_fir_qcfg_output (size:256b/32B) */
struct hwrm_port_tx_fir_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Value1 of TX FIR, required for NRZ or PAM4. */
	uint32_t	txfir_val_1;
	/* Value2 of TX FIR, required for NRZ or PAM4. */
	uint32_t	txfir_val_2;
	/* Value3 of TX FIR, required for PAM4. */
	uint32_t	txfir_val_3;
	/* Value4 of TX FIR, required for PAM4. */
	uint32_t	txfir_val_4;
	uint8_t	unused[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_port_ep_tx_cfg *
 ***********************/


/* hwrm_port_ep_tx_cfg_input (size:256b/32B) */
struct hwrm_port_ep_tx_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	enables;
	/* When this bit is '1', the value in the ep0_min_bw field is valid. */
	#define HWRM_PORT_EP_TX_CFG_INPUT_ENABLES_EP0_MIN_BW     UINT32_C(0x1)
	/* When this bit is '1', the value in the ep0_max_bw field is valid. */
	#define HWRM_PORT_EP_TX_CFG_INPUT_ENABLES_EP0_MAX_BW     UINT32_C(0x2)
	/* When this bit is '1', the value in the ep1_min_bw field is valid. */
	#define HWRM_PORT_EP_TX_CFG_INPUT_ENABLES_EP1_MIN_BW     UINT32_C(0x4)
	/* When this bit is '1', the value in the ep1_max_bw field is valid. */
	#define HWRM_PORT_EP_TX_CFG_INPUT_ENABLES_EP1_MAX_BW     UINT32_C(0x8)
	/* When this bit is '1', the value in the ep2_min_bw field is valid. */
	#define HWRM_PORT_EP_TX_CFG_INPUT_ENABLES_EP2_MIN_BW     UINT32_C(0x10)
	/* When this bit is '1', the value in the ep2_max_bw field is valid. */
	#define HWRM_PORT_EP_TX_CFG_INPUT_ENABLES_EP2_MAX_BW     UINT32_C(0x20)
	/* When this bit is '1', the value in the ep3_min_bw field is valid. */
	#define HWRM_PORT_EP_TX_CFG_INPUT_ENABLES_EP3_MIN_BW     UINT32_C(0x40)
	/* When this bit is '1', the value in the ep3_max_bw field is valid. */
	#define HWRM_PORT_EP_TX_CFG_INPUT_ENABLES_EP3_MAX_BW     UINT32_C(0x80)
	/* A port index, from 0 to the number of front panel ports, minus 1. */
	uint8_t	port_id;
	uint8_t	unused;
	/*
	 * Specifies a minimum guaranteed bandwidth, as a percentage of the
	 * port bandwidth, for the set of PFs and VFs on PCIe endpoint 0 for
	 * the specified port. The range is 0 to 100. A value of 0 indicates no
	 * minimum rate. The endpoint's min_bw must be less than or equal to
	 * max_bw. The sum of all configured minimum bandwidths for a port must
	 * be less than or equal to 100.
	 */
	uint8_t	ep0_min_bw;
	/*
	 * Specifies the maximum portion of the port's bandwidth that the set
	 * of PFs and VFs on PCIe endpoint 0 may use. The value is a percentage
	 * of the link bandwidth, from 0 to 100. A value of 0 indicates no
	 * maximum rate.
	 */
	uint8_t	ep0_max_bw;
	/*
	 * Specifies a minimum guaranteed bandwidth, as a percentage of the
	 * port bandwidth, for the set of PFs and VFs on PCIe endpoint 1 for
	 * the specified port. The range is 0 to 100. A value of 0 indicates no
	 * minimum rate. The endpoint's min_bw must be less than or equal to
	 * max_bw. The sum of all configured minimum bandwidths for a port must
	 * be less than or equal to 100.
	 */
	uint8_t	ep1_min_bw;
	/*
	 * Specifies the maximum portion of the port's bandwidth that the set
	 * of PFs and VFs on PCIe endpoint 1 may use. The value is a percentage
	 * of the link bandwidth, from 0 to 100. A value of 0 indicates no
	 * maximum rate.
	 */
	uint8_t	ep1_max_bw;
	/*
	 * Specifies a minimum guaranteed bandwidth, as a percentage of the
	 * port bandwidth, for the set of PFs and VFs on PCIe endpoint 2 for
	 * the specified port. The range is 0 to 100. A value of 0 indicates no
	 * minimum rate. The endpoint's min_bw must be less than or equal to
	 * max_bw. The sum of all configured minimum bandwidths for a port must
	 * be less than or equal to 100.
	 */
	uint8_t	ep2_min_bw;
	/*
	 * Specifies the maximum portion of the port's bandwidth that the set of
	 * PFs and VFs on PCIe endpoint 2 may use. The value is a percentage of
	 * the link bandwidth, from 0 to 100. A value of 0 indicates no
	 * maximum rate.
	 */
	uint8_t	ep2_max_bw;
	/*
	 * Specifies a minimum guaranteed bandwidth, as a percentage of the
	 * port bandwidth, for the set of PFs and VFs on PCIe endpoint 3 for
	 * the specified port. The range is 0 to 100. A value of 0 indicates no
	 * minimum rate. The endpoint's min_bw must be less than or equal to
	 * max_bw. The sum of all configured minimum bandwidths for a port must
	 * be less than or equal to 100.
	 */
	uint8_t	ep3_min_bw;
	/*
	 * Specifies the maximum portion of the port's bandwidth that the set
	 * of PFs and VFs on PCIe endpoint 3 may use. The value is a percentage
	 * of the link bandwidth, from 0 to 100. A value of 0 indicates no
	 * maximum rate.
	 */
	uint8_t	ep3_max_bw;
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_port_ep_tx_cfg_output (size:128b/16B) */
struct hwrm_port_ep_tx_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* hwrm_port_ep_tx_cfg_cmd_err (size:64b/8B) */
struct hwrm_port_ep_tx_cfg_cmd_err {
	/*
	 * command specific error codes for the cmd_err field in
	 * hwrm_err_output
	 */
	uint8_t	code;
	/* Unknown error. */
	#define HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_UNKNOWN \
		UINT32_C(0x0)
	/* The port ID is invalid */
	#define HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_PORT_ID_INVALID \
		UINT32_C(0x1)
	/* One of the PCIe endpoints configured is not active. */
	#define HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_EP_INACTIVE \
		UINT32_C(0x2)
	/* A minimum bandwidth is out of range. */
	#define HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_MIN_BW_RANGE \
		UINT32_C(0x3)
	/*
	 * One endpoint's minimum bandwidth is more than its maximum
	 * bandwidth.
	 */
	#define HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_MIN_MORE_THAN_MAX \
		UINT32_C(0x4)
	/* The sum of the minimum bandwidths on the port is more than 100%. */
	#define HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_MIN_BW_SUM \
		UINT32_C(0x5)
	/*
	 * The NIC does not support enforcement of a minimum guaranteed
	 * bandwidth for an endpoint.
	 */
	#define HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_MIN_BW_UNSUPPORTED \
		UINT32_C(0x6)
	#define HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_LAST \
		HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_MIN_BW_UNSUPPORTED
	uint8_t	unused_0[7];
} __rte_packed;

/************************
 * hwrm_port_ep_tx_qcfg *
 ************************/


/* hwrm_port_ep_tx_qcfg_input (size:192b/24B) */
struct hwrm_port_ep_tx_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The port whose endpoint rate limits are queried. */
	uint8_t	port_id;
	uint8_t	unused[7];
} __rte_packed;

/* hwrm_port_ep_tx_qcfg_output (size:192b/24B) */
struct hwrm_port_ep_tx_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Specifies a minimum guaranteed bandwidth, as a percentage of the
	 * port bandwidth, for the set of PFs and VFs on PCIe endpoint 0 for
	 * the specified port. The range is 0 to 100. A value of 0 indicates no
	 * minimum rate. The endpoint's min_bw must be less than or equal to
	 * max_bw. The sum of all configured minimum bandwidths for a port must
	 * be less than or equal to 100.
	 */
	uint8_t	ep0_min_bw;
	/*
	 * Specifies the maximum portion of the port's bandwidth that the set
	 * of PFs and VFs on PCIe endpoint 0 may use. The value is a percentage
	 * of the link bandwidth, from 0 to 100. A value of 0 indicates no
	 * maximum rate.
	 */
	uint8_t	ep0_max_bw;
	/*
	 * Specifies a minimum guaranteed bandwidth, as a percentage of the
	 * port bandwidth, for the set of PFs and VFs on PCIe endpoint 1 for
	 * the specified port. The range is 0 to 100. A value of 0 indicates no
	 * minimum rate. The endpoint's min_bw must be less than or equal to
	 * max_bw. The sum of all configured minimum bandwidths for a port must
	 * be less than or equal to 100.
	 */
	uint8_t	ep1_min_bw;
	/*
	 * Specifies the maximum portion of the port's bandwidth that the set
	 * of PFs and VFs on PCIe endpoint 1 may use. The value is a percentage
	 * of the link bandwidth, from 0 to 100. A value of 0 indicates no
	 * maximum rate.
	 */
	uint8_t	ep1_max_bw;
	/*
	 * Specifies a minimum guaranteed bandwidth, as a percentage of the
	 * port bandwidth, for the set of PFs and VFs on PCIe endpoint 2 for
	 * the specified port. The range is 0 to 100. A value of 0 indicates no
	 * minimum rate. The endpoint's min_bw must be less than or equal to
	 * max_bw. The sum of all configured minimum bandwidths for a port must
	 * be less than or equal to 100.
	 */
	uint8_t	ep2_min_bw;
	/*
	 * Specifies the maximum portion of the port's bandwidth that the set
	 * of PFs and VFs on PCIe endpoint 2 may use. The value is a percentage
	 * of the link bandwidth, from 0 to 100. A value of 0 indicates no
	 * maximum rate.
	 */
	uint8_t	ep2_max_bw;
	/*
	 * Specifies a minimum guaranteed bandwidth, as a percentage of the
	 * port bandwidth, for the set of PFs and VFs on PCIe endpoint 3 for
	 * the specified port. The range is 0 to 100. A value of 0 indicates no
	 * minimum rate. The endpoint's min_bw must be less than or equal to
	 * max_bw. The sum of all configured minimum bandwidths for a port must
	 * be less than or equal to 100.
	 */
	uint8_t	ep3_min_bw;
	/*
	 * Specifies the maximum portion of the port's bandwidth that the set
	 * of PFs and VFs on PCIe endpoint 3 may use. The value is a percentage
	 * of the link bandwidth, from 0 to 100. A value of 0 indicates no
	 * maximum rate.
	 */
	uint8_t	ep3_max_bw;
	uint8_t	unused_0[7];
	/*
	 * This field is used in output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************
 * hwrm_port_cfg *
 *****************/


/* hwrm_port_cfg_input (size:256b/32B) */
struct hwrm_port_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the tx_rate_limit field to
	 * be configured.
	 */
	#define HWRM_PORT_CFG_INPUT_ENABLES_TX_RATE_LIMIT     UINT32_C(0x1)
	/* Port ID of port that is to be configured. */
	uint16_t	port_id;
	uint16_t	unused_0;
	/*
	 * Requested setting of TX rate limit in Mbps.
	 * tx_rate_limit = 0 will cancel the rate limit if any.
	 * This field is valid only when tx_rate_limit bit in 'enables'
	 * field is '1'.
	 */
	uint32_t	tx_rate_limit;
} __rte_packed;

/* hwrm_port_cfg_output (size:128b/16B) */
struct hwrm_port_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************
 * hwrm_port_qcfg *
 ******************/


/* hwrm_port_qcfg_input (size:192b/24B) */
struct hwrm_port_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is to be queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_port_qcfg_output (size:192b/24B) */
struct hwrm_port_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	supported;
	/*
	 * If set to '1', then this bit indicates that TX rate limit
	 * could be configured via hwrm_port_cfg command.
	 */
	#define HWRM_PORT_QCFG_OUTPUT_SUPPORTED_TX_RATE_LIMIT     UINT32_C(0x1)
	uint32_t	enabled;
	/*
	 * If set to '1', then this bit indicates that TX rate limit
	 * is enabled and could be found in tx_rate_limit field.
	 */
	#define HWRM_PORT_QCFG_OUTPUT_ENABLED_TX_RATE_LIMIT     UINT32_C(0x1)
	/*
	 * Current setting of TX rate limit in Mbps.
	 * This field is valid only when tx_rate_limit bit in 'enabled'
	 * field is '1'.
	 */
	uint32_t	tx_rate_limit;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_queue_qportcfg *
 ***********************/


/* hwrm_queue_qportcfg_input (size:192b/24B) */
struct hwrm_queue_qportcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH     UINT32_C(0x1)
	/* tx path */
	#define HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH_TX    UINT32_C(0x0)
	/* rx path */
	#define HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH_RX    UINT32_C(0x1)
	#define HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH_LAST \
		HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH_RX
	/*
	 * Port ID of port for which the queue configuration is being
	 * queried. This field is only required when sent by IPC.
	 */
	uint16_t	port_id;
	/*
	 * Drivers will set this capability when it can use
	 * queue_idx_service_profile to map the queues to application.
	 */
	uint8_t	drv_qmap_cap;
	/* disabled */
	#define HWRM_QUEUE_QPORTCFG_INPUT_DRV_QMAP_CAP_DISABLED UINT32_C(0x0)
	/* enabled */
	#define HWRM_QUEUE_QPORTCFG_INPUT_DRV_QMAP_CAP_ENABLED  UINT32_C(0x1)
	#define HWRM_QUEUE_QPORTCFG_INPUT_DRV_QMAP_CAP_LAST \
		HWRM_QUEUE_QPORTCFG_INPUT_DRV_QMAP_CAP_ENABLED
	uint8_t	unused_0;
} __rte_packed;

/* hwrm_queue_qportcfg_output (size:1344b/168B) */
struct hwrm_queue_qportcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The maximum number of queues that can be configured on this
	 * port.
	 * Valid values range from 1 through 8.
	 */
	uint8_t	max_configurable_queues;
	/*
	 * The maximum number of lossless queues that can be configured
	 * on this port.
	 * Valid values range from 0 through 8.
	 */
	uint8_t	max_configurable_lossless_queues;
	/*
	 * Bitmask indicating which queues can be configured by the
	 * hwrm_queue_cfg command.
	 *
	 * Each bit represents a specific queue where bit 0 represents
	 * queue 0 and bit 7 represents queue 7.
	 * # A value of 0 indicates that the queue is not configurable
	 * by the hwrm_queue_cfg command.
	 * # A value of 1 indicates that the queue is configurable.
	 * # A hwrm_queue_cfg command shall return error when trying to
	 * configure a queue not configurable.
	 */
	uint8_t	queue_cfg_allowed;
	/* Information about queue configuration. */
	uint8_t	queue_cfg_info;
	/*
	 * If this flag is set to '1', then the queues are
	 * configured asymmetrically on TX and RX sides.
	 * If this flag is set to '0', then the queues are
	 * configured symmetrically on TX and RX sides. For
	 * symmetric configuration, the queue configuration
	 * including queue ids and service profiles on the
	 * TX side is the same as the corresponding queue
	 * configuration on the RX side.
	 */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_CFG_INFO_ASYM_CFG \
		UINT32_C(0x1)
	/*
	 * If this flag is set to '1', then service_profile will carry
	 * either lossy/lossless type and the new service_profile_type
	 * field will be used to determine if the queue is for L2/ROCE/CNP.
	 */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_CFG_INFO_USE_PROFILE_TYPE \
		UINT32_C(0x2)
	/*
	 * Bitmask indicating which queues can be configured by the
	 * hwrm_queue_pfcenable_cfg command.
	 *
	 * Each bit represents a specific priority where bit 0 represents
	 * priority 0 and bit 7 represents priority 7.
	 * # A value of 0 indicates that the priority is not configurable by
	 * the hwrm_queue_pfcenable_cfg command.
	 * # A value of 1 indicates that the priority is configurable.
	 * # A hwrm_queue_pfcenable_cfg command shall return error when
	 * trying to configure a priority that is not configurable.
	 */
	uint8_t	queue_pfcenable_cfg_allowed;
	/*
	 * Bitmask indicating which queues can be configured by the
	 * hwrm_queue_pri2cos_cfg command.
	 *
	 * Each bit represents a specific queue where bit 0 represents
	 * queue 0 and bit 7 represents queue 7.
	 * # A value of 0 indicates that the queue is not configurable
	 * by the hwrm_queue_pri2cos_cfg command.
	 * # A value of 1 indicates that the queue is configurable.
	 * # A hwrm_queue_pri2cos_cfg command shall return error when
	 * trying to configure a queue that is not configurable.
	 */
	uint8_t	queue_pri2cos_cfg_allowed;
	/*
	 * Bitmask indicating which queues can be configured by the
	 * hwrm_queue_pri2cos_cfg command.
	 *
	 * Each bit represents a specific queue where bit 0 represents
	 * queue 0 and bit 7 represents queue 7.
	 * # A value of 0 indicates that the queue is not configurable
	 * by the hwrm_queue_pri2cos_cfg command.
	 * # A value of 1 indicates that the queue is configurable.
	 * # A hwrm_queue_pri2cos_cfg command shall return error when
	 * trying to configure a queue not configurable.
	 */
	uint8_t	queue_cos2bw_cfg_allowed;
	/*
	 * ID of CoS Queue 0.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id0;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id0_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSY \
		UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSLESS \
		UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSLESS_ROCE \
		UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSY_ROCE_CNP \
		UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSLESS_NIC \
		UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_UNKNOWN \
		UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LAST \
		HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 1.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id1;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id1_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSY \
		UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSLESS \
		UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSLESS_ROCE \
		UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSY_ROCE_CNP \
		UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSLESS_NIC \
		UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_UNKNOWN \
		UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LAST \
		HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 2.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id2;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id2_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSY \
		UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSLESS \
		UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSLESS_ROCE \
		UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSY_ROCE_CNP \
		UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSLESS_NIC \
		UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_UNKNOWN \
		UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LAST \
		HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 3.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id3;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id3_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSY \
		UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSLESS \
		UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSLESS_ROCE \
		UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSY_ROCE_CNP \
		UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSLESS_NIC \
		UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_UNKNOWN \
		UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LAST \
		HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 4.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id4;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id4_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSY \
		UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSLESS \
		UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSLESS_ROCE \
		UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSY_ROCE_CNP \
		UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSLESS_NIC \
		UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_UNKNOWN \
		UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LAST \
		HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 5.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id5;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id5_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSY \
		UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSLESS \
		UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSLESS_ROCE \
		UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSY_ROCE_CNP \
		UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSLESS_NIC \
		UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_UNKNOWN \
		UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LAST \
		HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 6.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id6;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id6_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSY \
		UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSLESS \
		UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSLESS_ROCE \
		UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSY_ROCE_CNP \
		UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSLESS_NIC \
		UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_UNKNOWN \
		UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LAST \
		HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 7.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id7;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id7_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSY \
		UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSLESS \
		UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSLESS_ROCE \
		UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSY_ROCE_CNP \
		UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSLESS_NIC \
		UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_UNKNOWN \
		UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LAST \
		HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_UNKNOWN
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id0_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_TYPE_ROCE \
		UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_TYPE_NIC \
		UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_TYPE_CNP \
		UINT32_C(0x4)
	/*
	 * Up to 16 bytes of null padded ASCII string describing this queue.
	 * The queue name includes a CoS queue index and, in some cases, text
	 * that distinguishes the queue from other queues in the group.
	 */
	char	qid0_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid1_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid2_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid3_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid4_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid5_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid6_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid7_name[16];
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id1_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_TYPE_ROCE \
		UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_TYPE_NIC \
		UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_TYPE_CNP \
		UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id2_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_TYPE_ROCE \
		UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_TYPE_NIC \
		UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_TYPE_CNP \
		UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id3_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_TYPE_ROCE \
		UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_TYPE_NIC \
		UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_TYPE_CNP \
		UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id4_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_TYPE_ROCE \
		UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_TYPE_NIC \
		UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_TYPE_CNP \
		UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id5_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_TYPE_ROCE \
		UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_TYPE_NIC \
		UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_TYPE_CNP \
		UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id6_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_TYPE_ROCE \
		UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_TYPE_NIC \
		UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_TYPE_CNP \
		UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id7_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_TYPE_ROCE \
		UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_TYPE_NIC \
		UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_TYPE_CNP \
		UINT32_C(0x4)
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************
 * hwrm_queue_qcfg *
 *******************/


/* hwrm_queue_qcfg_input (size:192b/24B) */
struct hwrm_queue_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH     UINT32_C(0x1)
	/* tx path */
	#define HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH_TX    UINT32_C(0x0)
	/* rx path */
	#define HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH_RX    UINT32_C(0x1)
	#define HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH_LAST \
		HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH_RX
	/* Queue ID of the queue. */
	uint32_t	queue_id;
} __rte_packed;

/* hwrm_queue_qcfg_output (size:128b/16B) */
struct hwrm_queue_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This value is the estimate packet length used in the
	 * TX arbiter.
	 */
	uint32_t	queue_len;
	/* This value is applicable to CoS queues only. */
	uint8_t	service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_LOSSY    UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_LOSSLESS UINT32_C(0x1)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_UNKNOWN  UINT32_C(0xff)
	#define HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_LAST \
		HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_UNKNOWN
	/* Information about queue configuration. */
	uint8_t	queue_cfg_info;
	/*
	 * If this flag is set to '1', then the queue is
	 * configured asymmetrically on TX and RX sides.
	 * If this flag is set to '0', then this queue is
	 * configured symmetrically on TX and RX sides.
	 */
	#define HWRM_QUEUE_QCFG_OUTPUT_QUEUE_CFG_INFO_ASYM_CFG \
		UINT32_C(0x1)
	uint8_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************
 * hwrm_queue_cfg *
 ******************/


/* hwrm_queue_cfg_input (size:320b/40B) */
struct hwrm_queue_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX, or both directions applicable to the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_MASK UINT32_C(0x3)
	#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_SFT  0
	/* tx path */
	#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_TX     UINT32_C(0x0)
	/* rx path */
	#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_RX     UINT32_C(0x1)
	/* Bi-directional (Symmetrically applicable to TX and RX paths) */
	#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_BIDIR  UINT32_C(0x2)
	#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_LAST \
		HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_BIDIR
	uint32_t	enables;
	/*
	 * This bit must be '1' for the dflt_len field to be
	 * configured.
	 */
	#define HWRM_QUEUE_CFG_INPUT_ENABLES_DFLT_LEN            UINT32_C(0x1)
	/*
	 * This bit must be '1' for the service_profile field to be
	 * configured.
	 */
	#define HWRM_QUEUE_CFG_INPUT_ENABLES_SERVICE_PROFILE     UINT32_C(0x2)
	/* Queue ID of queue that is to be configured by this function. */
	uint32_t	queue_id;
	/*
	 * This value is a the estimate packet length used in the
	 * TX arbiter.
	 * Set to 0xFF... (All Fs) to not adjust this value.
	 */
	uint32_t	dflt_len;
	/* This value is applicable to CoS queues only. */
	uint8_t	service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_LOSSY    UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_LOSSLESS UINT32_C(0x1)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_UNKNOWN  UINT32_C(0xff)
	#define HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_LAST \
		HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_UNKNOWN
	uint8_t	unused_0[7];
} __rte_packed;

/* hwrm_queue_cfg_output (size:128b/16B) */
struct hwrm_queue_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************************
 * hwrm_queue_pfcenable_qcfg *
 *****************************/


/* hwrm_queue_pfcenable_qcfg_input (size:192b/24B) */
struct hwrm_queue_pfcenable_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_queue_pfcenable_qcfg_output (size:128b/16B) */
struct hwrm_queue_pfcenable_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/* If set to 1, then PFC is enabled on PRI 0. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI0_PFC_ENABLED \
		UINT32_C(0x1)
	/* If set to 1, then PFC is enabled on PRI 1. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI1_PFC_ENABLED \
		UINT32_C(0x2)
	/* If set to 1, then PFC is enabled on PRI 2. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI2_PFC_ENABLED \
		UINT32_C(0x4)
	/* If set to 1, then PFC is enabled on PRI 3. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI3_PFC_ENABLED \
		UINT32_C(0x8)
	/* If set to 1, then PFC is enabled on PRI 4. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI4_PFC_ENABLED \
		UINT32_C(0x10)
	/* If set to 1, then PFC is enabled on PRI 5. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI5_PFC_ENABLED \
		UINT32_C(0x20)
	/* If set to 1, then PFC is enabled on PRI 6. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI6_PFC_ENABLED \
		UINT32_C(0x40)
	/* If set to 1, then PFC is enabled on PRI 7. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI7_PFC_ENABLED \
		UINT32_C(0x80)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI0. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI0_PFC_WATCHDOG_ENABLED \
		UINT32_C(0x100)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI1. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI1_PFC_WATCHDOG_ENABLED \
		UINT32_C(0x200)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI2. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI2_PFC_WATCHDOG_ENABLED \
		UINT32_C(0x400)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI3. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI3_PFC_WATCHDOG_ENABLED \
		UINT32_C(0x800)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI4. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI4_PFC_WATCHDOG_ENABLED \
		UINT32_C(0x1000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI5. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI5_PFC_WATCHDOG_ENABLED \
		UINT32_C(0x2000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI6. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI6_PFC_WATCHDOG_ENABLED \
		UINT32_C(0x4000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI7. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI7_PFC_WATCHDOG_ENABLED \
		UINT32_C(0x8000)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/****************************
 * hwrm_queue_pfcenable_cfg *
 ****************************/


/* hwrm_queue_pfcenable_cfg_input (size:192b/24B) */
struct hwrm_queue_pfcenable_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* If set to 1, then PFC is requested to be enabled on PRI 0. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI0_PFC_ENABLED \
		UINT32_C(0x1)
	/* If set to 1, then PFC is requested to be enabled on PRI 1. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI1_PFC_ENABLED \
		UINT32_C(0x2)
	/* If set to 1, then PFC is requested to be enabled on PRI 2. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI2_PFC_ENABLED \
		UINT32_C(0x4)
	/* If set to 1, then PFC is requested to be enabled on PRI 3. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI3_PFC_ENABLED \
		UINT32_C(0x8)
	/* If set to 1, then PFC is requested to be enabled on PRI 4. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI4_PFC_ENABLED \
		UINT32_C(0x10)
	/* If set to 1, then PFC is requested to be enabled on PRI 5. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI5_PFC_ENABLED \
		UINT32_C(0x20)
	/* If set to 1, then PFC is requested to be enabled on PRI 6. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI6_PFC_ENABLED \
		UINT32_C(0x40)
	/* If set to 1, then PFC is requested to be enabled on PRI 7. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI7_PFC_ENABLED \
		UINT32_C(0x80)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI0. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI0_PFC_WATCHDOG_ENABLED \
		UINT32_C(0x100)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI1. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI1_PFC_WATCHDOG_ENABLED \
		UINT32_C(0x200)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI2. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI2_PFC_WATCHDOG_ENABLED \
		UINT32_C(0x400)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI3. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI3_PFC_WATCHDOG_ENABLED \
		UINT32_C(0x800)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI4. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI4_PFC_WATCHDOG_ENABLED \
		UINT32_C(0x1000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI5. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI5_PFC_WATCHDOG_ENABLED \
		UINT32_C(0x2000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI6. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI6_PFC_WATCHDOG_ENABLED \
		UINT32_C(0x4000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI7. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI7_PFC_WATCHDOG_ENABLED \
		UINT32_C(0x8000)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint16_t	port_id;
	uint8_t	unused_0[2];
} __rte_packed;

/* hwrm_queue_pfcenable_cfg_output (size:128b/16B) */
struct hwrm_queue_pfcenable_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_queue_pri2cos_qcfg *
 ***************************/


/* hwrm_queue_pri2cos_qcfg_input (size:192b/24B) */
struct hwrm_queue_pri2cos_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH      UINT32_C(0x1)
	/* tx path */
	#define HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH_TX     UINT32_C(0x0)
	/* rx path */
	#define HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH_RX     UINT32_C(0x1)
	#define HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH_LAST \
		HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH_RX
	/*
	 * When this bit is set to '0', the query is
	 * for PRI from tunnel headers.
	 * When this bit is set to '1', the query is
	 * for PRI from inner packet headers.
	 */
	#define HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_IVLAN     UINT32_C(0x2)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[3];
} __rte_packed;

/* hwrm_queue_pri2cos_qcfg_output (size:192b/24B) */
struct hwrm_queue_pri2cos_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * CoS Queue assigned to priority 0. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri0_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 1. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri1_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 2. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri2_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 3. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri3_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 4. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri4_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 5. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri5_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 6. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri6_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 7. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri7_cos_queue_id;
	/* Information about queue configuration. */
	uint8_t	queue_cfg_info;
	/*
	 * If this flag is set to '1', then the PRI to CoS
	 * configuration is asymmetric on TX and RX sides.
	 * If this flag is set to '0', then PRI to CoS configuration
	 * is symmetric on TX and RX sides.
	 */
	#define HWRM_QUEUE_PRI2COS_QCFG_OUTPUT_QUEUE_CFG_INFO_ASYM_CFG \
		UINT32_C(0x1)
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_queue_pri2cos_cfg *
 **************************/


/* hwrm_queue_pri2cos_cfg_input (size:320b/40B) */
struct hwrm_queue_pri2cos_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX, or both directions applicable to the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_MASK UINT32_C(0x3)
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_SFT  0
	/* tx path */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_TX     UINT32_C(0x0)
	/* rx path */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_RX     UINT32_C(0x1)
	/* Bi-directional (Symmetrically applicable to TX and RX paths) */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_BIDIR  UINT32_C(0x2)
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_LAST \
		HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_BIDIR
	/*
	 * When this bit is set to '0', the mapping is requested
	 * for PRI from tunnel headers.
	 * When this bit is set to '1', the mapping is requested
	 * for PRI from inner packet headers.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_IVLAN     UINT32_C(0x4)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the pri0_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI0_COS_QUEUE_ID \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the pri1_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI1_COS_QUEUE_ID \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the pri2_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI2_COS_QUEUE_ID \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the pri3_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI3_COS_QUEUE_ID \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the pri4_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI4_COS_QUEUE_ID \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the pri5_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI5_COS_QUEUE_ID \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the pri6_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI6_COS_QUEUE_ID \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the pri7_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI7_COS_QUEUE_ID \
		UINT32_C(0x80)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint8_t	port_id;
	/*
	 * CoS Queue assigned to priority 0. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri0_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 1. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri1_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 2  This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri2_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 3. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri3_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 4. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri4_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 5. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri5_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 6. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri6_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 7. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri7_cos_queue_id;
	uint8_t	unused_0[7];
} __rte_packed;

/* hwrm_queue_pri2cos_cfg_output (size:128b/16B) */
struct hwrm_queue_pri2cos_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_queue_cos2bw_qcfg *
 **************************/


/* hwrm_queue_cos2bw_qcfg_input (size:192b/24B) */
struct hwrm_queue_cos2bw_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure TC BW assignment on this port.
	 */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_queue_cos2bw_qcfg_output (size:896b/112B) */
struct hwrm_queue_cos2bw_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* ID of CoS Queue 0. */
	uint8_t	queue_id0;
	uint8_t	unused_0;
	uint16_t	unused_1;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id0_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id0_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id0_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_TSA_ASSIGN_SP \
		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_TSA_ASSIGN_ETS \
		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_TSA_ASSIGN_RESERVED_FIRST \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_TSA_ASSIGN_RESERVED_LAST \
		UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id0_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id0_bw_weight;
	/* ID of CoS Queue 1. */
	uint8_t	queue_id1;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id1_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id1_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id1_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_TSA_ASSIGN_SP \
		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_TSA_ASSIGN_ETS \
		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_TSA_ASSIGN_RESERVED_FIRST \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_TSA_ASSIGN_RESERVED_LAST \
		UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id1_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id1_bw_weight;
	/* ID of CoS Queue 2. */
	uint8_t	queue_id2;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id2_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id2_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id2_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_TSA_ASSIGN_SP \
		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_TSA_ASSIGN_ETS \
		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_TSA_ASSIGN_RESERVED_FIRST \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_TSA_ASSIGN_RESERVED_LAST \
		UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id2_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id2_bw_weight;
	/* ID of CoS Queue 3. */
	uint8_t	queue_id3;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id3_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id3_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id3_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_TSA_ASSIGN_SP \
		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_TSA_ASSIGN_ETS \
		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_TSA_ASSIGN_RESERVED_FIRST \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_TSA_ASSIGN_RESERVED_LAST \
		UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id3_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id3_bw_weight;
	/* ID of CoS Queue 4. */
	uint8_t	queue_id4;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id4_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id4_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id4_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_TSA_ASSIGN_SP \
		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_TSA_ASSIGN_ETS \
		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_TSA_ASSIGN_RESERVED_FIRST \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_TSA_ASSIGN_RESERVED_LAST \
		UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id4_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id4_bw_weight;
	/* ID of CoS Queue 5. */
	uint8_t	queue_id5;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id5_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id5_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id5_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_TSA_ASSIGN_SP \
		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_TSA_ASSIGN_ETS \
		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_TSA_ASSIGN_RESERVED_FIRST \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_TSA_ASSIGN_RESERVED_LAST \
		UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id5_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id5_bw_weight;
	/* ID of CoS Queue 6. */
	uint8_t	queue_id6;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id6_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id6_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id6_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_TSA_ASSIGN_SP \
		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_TSA_ASSIGN_ETS \
		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_TSA_ASSIGN_RESERVED_FIRST \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_TSA_ASSIGN_RESERVED_LAST \
		UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id6_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id6_bw_weight;
	/* ID of CoS Queue 7. */
	uint8_t	queue_id7;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id7_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id7_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id7_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_TSA_ASSIGN_SP \
		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_TSA_ASSIGN_ETS \
		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_TSA_ASSIGN_RESERVED_FIRST \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_TSA_ASSIGN_RESERVED_LAST \
		UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id7_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id7_bw_weight;
	uint8_t	unused_2[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_queue_cos2bw_cfg *
 *************************/


/* hwrm_queue_cos2bw_cfg_input (size:1024b/128B) */
struct hwrm_queue_cos2bw_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	uint32_t	enables;
	/*
	 * If this bit is set to 1, then all queue_id0 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID0_VALID \
		UINT32_C(0x1)
	/*
	 * If this bit is set to 1, then all queue_id1 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID1_VALID \
		UINT32_C(0x2)
	/*
	 * If this bit is set to 1, then all queue_id2 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID2_VALID \
		UINT32_C(0x4)
	/*
	 * If this bit is set to 1, then all queue_id3 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID3_VALID \
		UINT32_C(0x8)
	/*
	 * If this bit is set to 1, then all queue_id4 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID4_VALID \
		UINT32_C(0x10)
	/*
	 * If this bit is set to 1, then all queue_id5 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID5_VALID \
		UINT32_C(0x20)
	/*
	 * If this bit is set to 1, then all queue_id6 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID6_VALID \
		UINT32_C(0x40)
	/*
	 * If this bit is set to 1, then all queue_id7 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID7_VALID \
		UINT32_C(0x80)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure TC BW assignment on this port.
	 */
	uint16_t	port_id;
	/* ID of CoS Queue 0. */
	uint8_t	queue_id0;
	uint8_t	unused_0;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id0_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id0_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id0_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_TSA_ASSIGN_SP \
		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_TSA_ASSIGN_ETS \
		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_TSA_ASSIGN_RESERVED_FIRST \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_TSA_ASSIGN_RESERVED_LAST \
		UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id0_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id0_bw_weight;
	/* ID of CoS Queue 1. */
	uint8_t	queue_id1;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id1_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id1_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id1_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_TSA_ASSIGN_SP \
		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_TSA_ASSIGN_ETS \
		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_TSA_ASSIGN_RESERVED_FIRST \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_TSA_ASSIGN_RESERVED_LAST \
		UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id1_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id1_bw_weight;
	/* ID of CoS Queue 2. */
	uint8_t	queue_id2;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id2_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id2_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id2_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_TSA_ASSIGN_SP \
		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_TSA_ASSIGN_ETS \
		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_TSA_ASSIGN_RESERVED_FIRST \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_TSA_ASSIGN_RESERVED_LAST \
		UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id2_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id2_bw_weight;
	/* ID of CoS Queue 3. */
	uint8_t	queue_id3;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id3_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id3_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id3_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_TSA_ASSIGN_SP \
		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_TSA_ASSIGN_ETS \
		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_TSA_ASSIGN_RESERVED_FIRST \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_TSA_ASSIGN_RESERVED_LAST \
		UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id3_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id3_bw_weight;
	/* ID of CoS Queue 4. */
	uint8_t	queue_id4;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id4_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id4_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id4_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_TSA_ASSIGN_SP \
		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_TSA_ASSIGN_ETS \
		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_TSA_ASSIGN_RESERVED_FIRST \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_TSA_ASSIGN_RESERVED_LAST \
		UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id4_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id4_bw_weight;
	/* ID of CoS Queue 5. */
	uint8_t	queue_id5;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id5_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id5_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id5_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_TSA_ASSIGN_SP \
		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_TSA_ASSIGN_ETS \
		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_TSA_ASSIGN_RESERVED_FIRST \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_TSA_ASSIGN_RESERVED_LAST \
		UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id5_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id5_bw_weight;
	/* ID of CoS Queue 6. */
	uint8_t	queue_id6;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id6_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id6_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id6_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_TSA_ASSIGN_SP \
		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_TSA_ASSIGN_ETS \
		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_TSA_ASSIGN_RESERVED_FIRST \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_TSA_ASSIGN_RESERVED_LAST \
		UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id6_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id6_bw_weight;
	/* ID of CoS Queue 7. */
	uint8_t	queue_id7;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id7_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id7_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id7_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_TSA_ASSIGN_SP \
		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_TSA_ASSIGN_ETS \
		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_TSA_ASSIGN_RESERVED_FIRST \
		UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_TSA_ASSIGN_RESERVED_LAST \
		UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id7_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id7_bw_weight;
	uint8_t	unused_1[5];
} __rte_packed;

/* hwrm_queue_cos2bw_cfg_output (size:128b/16B) */
struct hwrm_queue_cos2bw_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_queue_dscp_qcaps *
 *************************/


/* hwrm_queue_dscp_qcaps_input (size:192b/24B) */
struct hwrm_queue_dscp_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} __rte_packed;

/* hwrm_queue_dscp_qcaps_output (size:128b/16B) */
struct hwrm_queue_dscp_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The number of bits provided by the hardware for the DSCP value. */
	uint8_t	num_dscp_bits;
	uint8_t	unused_0;
	/* Max number of DSCP-MASK-PRI entries supported. */
	uint16_t	max_entries;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/****************************
 * hwrm_queue_dscp2pri_qcfg *
 ****************************/


/* hwrm_queue_dscp2pri_qcfg_input (size:256b/32B) */
struct hwrm_queue_dscp2pri_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where the 24-bits DSCP-MASK-PRI
	 * tuple(s) will be copied to.
	 */
	uint64_t	dest_data_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0;
	/* Size of the buffer pointed to by dest_data_addr. */
	uint16_t	dest_data_buffer_size;
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_queue_dscp2pri_qcfg_output (size:128b/16B) */
struct hwrm_queue_dscp2pri_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * A count of the number of DSCP-MASK-PRI tuple(s) pointed to
	 * by the dest_data_addr.
	 */
	uint16_t	entry_cnt;
	/*
	 * This is the default PRI which un-initialized DSCP values are
	 * mapped to.
	 */
	uint8_t	default_pri;
	uint8_t	unused_0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_queue_dscp2pri_cfg *
 ***************************/


/* hwrm_queue_dscp2pri_cfg_input (size:320b/40B) */
struct hwrm_queue_dscp2pri_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where the 24-bits DSCP-MASK-PRI tuple
	 * will be copied from. A non-zero mask "adds" a tuple, while
	 * a mask equal to 0 triggers the firmware to remove a tuple.
	 * Only tuples with unique DSCP values are stored. On chips
	 * prior to Thor a mask can be 0 - 0x3f, while on Thor it can
	 * be 0 or 0x3f.
	 */
	uint64_t	src_data_addr;
	uint32_t	flags;
	/* use_hw_default_pri is 1 b */
	#define HWRM_QUEUE_DSCP2PRI_CFG_INPUT_FLAGS_USE_HW_DEFAULT_PRI \
		UINT32_C(0x1)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the default_pri field to be
	 * configured.
	 */
	#define HWRM_QUEUE_DSCP2PRI_CFG_INPUT_ENABLES_DEFAULT_PRI \
		UINT32_C(0x1)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint8_t	port_id;
	/*
	 * This is the default PRI which un-initialized DSCP values will be
	 * mapped to.
	 */
	uint8_t	default_pri;
	/*
	 * A count of the number of DSCP-MASK-PRI tuple(s) in the data pointed
	 * to by src_data_addr.
	 */
	uint16_t	entry_cnt;
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_queue_dscp2pri_cfg_output (size:128b/16B) */
struct hwrm_queue_dscp2pri_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_queue_mpls_qcaps *
 *************************/


/* hwrm_queue_mpls_qcaps_input (size:192b/24B) */
struct hwrm_queue_mpls_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure MPLS TC(EXP) to pri mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} __rte_packed;

/* hwrm_queue_mpls_qcaps_output (size:128b/16B) */
struct hwrm_queue_mpls_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Bitmask indicating which queues can be configured by the
	 * hwrm_queue_mplstc2pri_cfg command.
	 *
	 * Each bit represents a specific pri where bit 0 represents
	 * pri 0 and bit 7 represents pri 7.
	 * # A value of 0 indicates that the pri is not configurable
	 * by the hwrm_queue_mplstc2pri_cfg command.
	 * # A value of 1 indicates that the pri is configurable.
	 * # A hwrm_queue_mplstc2pri_cfg command shall return error when
	 * trying to configure a pri that is not configurable.
	 */
	uint8_t	queue_mplstc2pri_cfg_allowed;
	/*
	 * This is the default PRI which un-initialized MPLS values will be
	 * mapped to.
	 */
	uint8_t	hw_default_pri;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************************
 * hwrm_queue_mplstc2pri_qcfg *
 ******************************/


/* hwrm_queue_mplstc2pri_qcfg_input (size:192b/24B) */
struct hwrm_queue_mplstc2pri_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure MPLS TC(EXP) to pri mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} __rte_packed;

/* hwrm_queue_mplstc2pri_qcfg_output (size:192b/24B) */
struct hwrm_queue_mplstc2pri_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * pri assigned to MPLS TC(EXP) 0. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 0.
	 */
	uint8_t	tc0_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 1. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 1.
	 */
	uint8_t	tc1_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 2. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 2.
	 */
	uint8_t	tc2_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 3. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 3.
	 */
	uint8_t	tc3_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 4. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 4.
	 */
	uint8_t	tc4_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 5. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 5.
	 */
	uint8_t	tc5_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 6. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 6.
	 */
	uint8_t	tc6_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 7. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 7.
	 */
	uint8_t	tc7_pri_queue_id;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************************
 * hwrm_queue_mplstc2pri_cfg *
 *****************************/


/* hwrm_queue_mplstc2pri_cfg_input (size:256b/32B) */
struct hwrm_queue_mplstc2pri_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the mplstc0_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC0_PRI_QUEUE_ID \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the mplstc1_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC1_PRI_QUEUE_ID \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the mplstc2_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC2_PRI_QUEUE_ID \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the mplstc3_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC3_PRI_QUEUE_ID \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the mplstc4_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC4_PRI_QUEUE_ID \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the mplstc5_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC5_PRI_QUEUE_ID \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the mplstc6_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC6_PRI_QUEUE_ID \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the mplstc7_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC7_PRI_QUEUE_ID \
		UINT32_C(0x80)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure MPLS TC(EXP)to pri mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[3];
	/*
	 * pri assigned to MPLS TC(EXP) 0. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc0_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 1. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc1_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 2  This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc2_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 3. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc3_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 4. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc4_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 5. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc5_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 6. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc6_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 7. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc7_pri_queue_id;
} __rte_packed;

/* hwrm_queue_mplstc2pri_cfg_output (size:128b/16B) */
struct hwrm_queue_mplstc2pri_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/****************************
 * hwrm_queue_vlanpri_qcaps *
 ****************************/


/* hwrm_queue_vlanpri_qcaps_input (size:192b/24B) */
struct hwrm_queue_vlanpri_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure VLAN priority to user priority mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} __rte_packed;

/* hwrm_queue_vlanpri_qcaps_output (size:128b/16B) */
struct hwrm_queue_vlanpri_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is the default user priority which all VLAN priority values
	 * are mapped to if there is no VLAN priority to user priority mapping.
	 */
	uint8_t	hw_default_pri;
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************************
 * hwrm_queue_vlanpri2pri_qcfg *
 *******************************/


/* hwrm_queue_vlanpri2pri_qcfg_input (size:192b/24B) */
struct hwrm_queue_vlanpri2pri_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure VLAN priority to user priority mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} __rte_packed;

/* hwrm_queue_vlanpri2pri_qcfg_output (size:192b/24B) */
struct hwrm_queue_vlanpri2pri_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * User priority assigned to VLAN priority 0. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri0_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 1. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri1_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 2. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri2_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 3. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri3_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 4. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri4_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 5. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri5_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 6. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri6_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 7. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri7_user_pri_id;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************************
 * hwrm_queue_vlanpri2pri_cfg *
 ******************************/


/* hwrm_queue_vlanpri2pri_cfg_input (size:256b/32B) */
struct hwrm_queue_vlanpri2pri_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vlanpri0_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI0_USER_PRI_ID \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the vlanpri1_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI1_USER_PRI_ID \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the vlanpri2_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI2_USER_PRI_ID \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the vlanpri3_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI3_USER_PRI_ID \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the vlanpri4_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI4_USER_PRI_ID \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the vlanpri5_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI5_USER_PRI_ID \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the vlanpri6_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI6_USER_PRI_ID \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the vlanpri7_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI7_USER_PRI_ID \
		UINT32_C(0x80)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure VLAN priority to user priority mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[3];
	/*
	 * User priority assigned to VLAN priority 0. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri0_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 1. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri1_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 2. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri2_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 3. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri3_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 4. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri4_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 5. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri5_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 6. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri6_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 7. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri7_user_pri_id;
} __rte_packed;

/* hwrm_queue_vlanpri2pri_cfg_output (size:128b/16B) */
struct hwrm_queue_vlanpri2pri_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_queue_global_cfg *
 *************************/


/* hwrm_queue_global_cfg_input (size:192b/24B) */
struct hwrm_queue_global_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Configuration mode for rx cos queues, configuring whether they
	 * use one shared buffer pool (across ports or PCIe endpoints) or
	 * independent per port or per endpoint buffer pools.
	 */
	uint8_t	mode;
	/* One shared buffer pool to be used by all RX CoS queues */
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_MODE_SHARED      UINT32_C(0x0)
	/*
	 * Each port or PCIe endpoint to use an independent buffer pool
	 * for its RX CoS queues
	 */
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_MODE_INDEPENDENT UINT32_C(0x1)
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_MODE_LAST \
		HWRM_QUEUE_GLOBAL_CFG_INPUT_MODE_INDEPENDENT
	uint8_t	unused_0;
	uint16_t	enables;
	/* This bit must be '1' when the mode field is configured. */
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_ENABLES_MODE          UINT32_C(0x1)
	/*
	 * This bit must be '1' when the maximum bandwidth for queue group 0
	 * (g0_max_bw) is configured.
	 */
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_ENABLES_G0_MAX_BW     UINT32_C(0x2)
	/*
	 * This bit must be '1' when the maximum bandwidth for queue group 1
	 * (g1_max_bw) is configured.
	 */
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_ENABLES_G1_MAX_BW     UINT32_C(0x4)
	/*
	 * This bit must be '1' when the maximum bandwidth for queue group 2
	 * (g2_max_bw) is configured.
	 */
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_ENABLES_G2_MAX_BW     UINT32_C(0x8)
	/*
	 * This bit must be '1' when the maximum bandwidth for queue group 3
	 * (g3_max_bw) is configured.
	 */
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_ENABLES_G3_MAX_BW \
		UINT32_C(0x10)
	/*
	 * Specifies the maximum receive rate, as a percentage of total link
	 * bandwidth, of the receive traffic through queue group 0. A value
	 * of 0 indicates no rate limit.
	 *
	 * A queue group is a set of queues, one per traffic class. In
	 * single-host mode, each panel port has its own queue group, and thus,
	 * this rate limit shapes the traffic received on a port, in this case,
	 * through port 0. In multi-root or multi-host mode, each PCIe endpoint
	 * on the NIC has its own queue group. In these cases, the rate limit
	 * shapes the traffic sent to the host through one of the PCIe
	 * endpoints, in this case endpoint 0.
	 */
	uint8_t	g0_max_bw;
	/*
	 * Specifies the maximum rate of the traffic through receive CoS queue
	 * group 1 (for port 1 or PCIe endpoint 1). The rate is a percentage of
	 * total link bandwidth (the sum of the bandwidths of all links). A
	 * value of 0 indicates no rate limit.
	 */
	uint8_t	g1_max_bw;
	/*
	 * Specifies the maximum rate of the traffic through receive CoS queue
	 * group 2 (for port 2 or PCIe endpoint 2). The rate is a percentage of
	 * total link bandwidth (the sum of the bandwidths of all links). A
	 * value of 0 indicates no rate limit.
	 */
	uint8_t	g2_max_bw;
	/*
	 * Specifies the maximum receive rate, in Mbps, of the receive traffic
	 * through queue group 3 (for port 3 or PCIe endpoint 3). A value of 0
	 * indicates no rate limit.
	 */
	uint8_t	g3_max_bw;
} __rte_packed;

/* hwrm_queue_global_cfg_output (size:128b/16B) */
struct hwrm_queue_global_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_queue_global_qcfg *
 **************************/


/* hwrm_queue_global_qcfg_input (size:128b/16B) */
struct hwrm_queue_global_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_queue_global_qcfg_output (size:320b/40B) */
struct hwrm_queue_global_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Port or PCIe endpoint id to be mapped for buffer pool 0. */
	uint8_t	buffer_pool_id0_map;
	/* Port or PCIe endpoint id to be mapped for buffer pool 1. */
	uint8_t	buffer_pool_id1_map;
	/* Port or PCIe endpoint id to be mapped for buffer pool 2. */
	uint8_t	buffer_pool_id2_map;
	/* Port or PCIe endpoint id to be mapped for buffer pool 3. */
	uint8_t	buffer_pool_id3_map;
	/* Size of buffer pool 0 (KBytes). */
	uint32_t	buffer_pool_id0_size;
	/* Size of buffer pool 1 (KBytes). */
	uint32_t	buffer_pool_id1_size;
	/* Size of buffer pool 2 (KBytes). */
	uint32_t	buffer_pool_id2_size;
	/* Size of buffer pool 3 (KBytes). */
	uint32_t	buffer_pool_id3_size;
	uint16_t	flags;
	/*
	 * Enumeration denoting whether the rx buffer pool mapping is
	 * per port or per PCIe endpoint
	 */
	#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_FLAGS_MAPPING \
		UINT32_C(0x1)
	/*
	 * The buffer_pool_id[0-3]_map field represents mapping of rx
	 * buffer pools to a port.
	 */
	#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_FLAGS_MAPPING_MAPPING_PER_PORT \
		UINT32_C(0x0)
	/*
	 * The buffer_pool_id[0-3]_map field represents mapping of rx
	 * buffer pools to a PCIe endpoint.
	 */
	#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_FLAGS_MAPPING_MAPPING_PER_ENDPOINT \
		UINT32_C(0x1)
	#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_FLAGS_MAPPING_LAST \
		HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_FLAGS_MAPPING_MAPPING_PER_ENDPOINT
	/*
	 * Configuration mode for rx cos queues, configuring whether they
	 * use one shared buffer pool (across ports or PCIe endpoints) or
	 * independent per port or per endpoint buffer pools.
	 */
	uint8_t	mode;
	/* One shared buffer pool to be used by all RX CoS queues */
	#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_MODE_SHARED      UINT32_C(0x0)
	/*
	 * Each port or PCIe endpoint to use an independent buffer pool
	 * for its RX CoS queues
	 */
	#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_MODE_INDEPENDENT UINT32_C(0x1)
	#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_MODE_LAST \
		HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_MODE_INDEPENDENT
	uint8_t	unused_0;
	/*
	 * Reports the rate limit applied to traffic through receive CoS queue
	 * group 0. The rate limit is a percentage of total link bandwidth. A
	 * value of 0 indicates no rate limit.
	 *
	 * A queue group is a set of queues, one per traffic class. In
	 * single-host mode, each panel port has its own queue group, and thus,
	 * this rate limit shapes the traffic received on a port, in this case,
	 * through port 0. In multi-root or multi-host mode, each PCIe endpoint
	 * on the NIC has its own queue group. In these cases, the rate limit
	 * shapes the traffic sent to the host through one of the PCIe
	 * endpoints, in this case endpoint 0.
	 */
	uint8_t	g0_max_bw;
	/*
	 * Reports the rate limit applied to traffic through receive CoS queue
	 * group 1 (for port 1 or PCIe endpoint 1). The rate limit is a
	 * percentage of total link bandwidth. A value of 0 indicates no rate
	 * limit.
	 */
	uint8_t	g1_max_bw;
	/*
	 * Reports the rate limit applied to traffic through receive CoS queue
	 * group 2 (for port 2 or PCIe endpoint 2). The rate limit is a
	 * percentage of total link bandwidth. A value of 0 indicates no rate
	 * limit.
	 */
	uint8_t	g2_max_bw;
	/*
	 * Reports the rate limit applied to traffic through receive CoS queue
	 * group 3 (for port 3 or PCIe endpoint 3). The rate limit is a
	 * percentage of total link bandwidth. A value of 0 indicates no rate
	 * limit.
	 */
	uint8_t	g3_max_bw;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************
 * hwrm_vnic_alloc *
 *******************/


/* hwrm_vnic_alloc_input (size:192b/24B) */
struct hwrm_vnic_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', this VNIC is requested to
	 * be the default VNIC for this function.
	 */
	#define HWRM_VNIC_ALLOC_INPUT_FLAGS_DEFAULT \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', proxy VEE PF is requesting
	 * allocation of a default VNIC on behalf of virtio-net
	 * function given in virtio_net_fid field.
	 */
	#define HWRM_VNIC_ALLOC_INPUT_FLAGS_VIRTIO_NET_FID_VALID \
		UINT32_C(0x2)
	/*
	 * Virtio-net function's FID.
	 * This virtio-net function is requesting allocation of default
	 * VNIC through proxy VEE PF.
	 */
	uint16_t	virtio_net_fid;
	uint8_t	unused_0[2];
} __rte_packed;

/* hwrm_vnic_alloc_output (size:128b/16B) */
struct hwrm_vnic_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Logical vnic ID */
	uint32_t	vnic_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/********************
 * hwrm_vnic_update *
 ********************/


/* hwrm_vnic_update_input (size:256b/32B) */
struct hwrm_vnic_update_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Logical vnic ID */
	uint32_t	vnic_id;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vnic_state field to be
	 * configured.
	 */
	#define HWRM_VNIC_UPDATE_INPUT_ENABLES_VNIC_STATE_VALID \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the mru field to be
	 * configured.
	 */
	#define HWRM_VNIC_UPDATE_INPUT_ENABLES_MRU_VALID \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the metadata_format_type field to be
	 * configured.
	 */
	#define HWRM_VNIC_UPDATE_INPUT_ENABLES_METADATA_FORMAT_TYPE_VALID \
		UINT32_C(0x4)
	/*
	 * This will update the context variable with the same name if
	 * the corresponding enable is set.
	 */
	uint8_t	vnic_state;
	/* Normal operation state for the VNIC. */
	#define HWRM_VNIC_UPDATE_INPUT_VNIC_STATE_NORMAL UINT32_C(0x0)
	/* All packets are dropped in this state. */
	#define HWRM_VNIC_UPDATE_INPUT_VNIC_STATE_DROP   UINT32_C(0x1)
	#define HWRM_VNIC_UPDATE_INPUT_VNIC_STATE_LAST \
		HWRM_VNIC_UPDATE_INPUT_VNIC_STATE_DROP
	/*
	 * The metadata format type used in all the RX packet completions
	 * going through this VNIC. This value is product specific. Refer to
	 * the L2 HSI completion ring structures for the detailed
	 * descriptions. For Thor and Thor2, it corresponds to meta_format
	 * in rx_pkt_cmpl_hi and rx_pkt_v3_cmpl_hi, respectively.
	 */
	uint8_t	metadata_format_type;
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_0 UINT32_C(0x0)
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_1 UINT32_C(0x1)
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_2 UINT32_C(0x2)
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_3 UINT32_C(0x3)
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_4 UINT32_C(0x4)
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_LAST \
		HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_4
	/*
	 * The maximum receive unit of the vnic.
	 * Each vnic is associated with a function.
	 * The vnic mru value overwrites the mru setting of the
	 * associated function.
	 * The HWRM shall make sure that vnic mru does not exceed
	 * the mru of the port the function is associated with.
	 */
	uint16_t	mru;
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_vnic_update_output (size:128b/16B) */
struct hwrm_vnic_update_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************
 * hwrm_vnic_free *
 ******************/


/* hwrm_vnic_free_input (size:192b/24B) */
struct hwrm_vnic_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Logical vnic ID */
	uint32_t	vnic_id;
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_vnic_free_output (size:128b/16B) */
struct hwrm_vnic_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************
 * hwrm_vnic_cfg *
 *****************/


/* hwrm_vnic_cfg_input (size:384b/48B) */
struct hwrm_vnic_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the VNIC is requested to
	 * be the default VNIC for the function.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_DEFAULT \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', the VNIC is being configured to
	 * strip VLAN in the RX path.
	 * If set to '0', then VLAN stripping is disabled on
	 * this VNIC.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_VLAN_STRIP_MODE \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', the VNIC is being configured to
	 * buffer receive packets in the hardware until the host
	 * posts new receive buffers.
	 * If set to '0', then bd_stall is being configured to be
	 * disabled on this VNIC.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_BD_STALL_MODE \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', the VNIC is being configured to
	 * receive both RoCE and non-RoCE traffic.
	 * If set to '0', then this VNIC is not configured to be
	 * operating in dual VNIC mode.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_ROCE_DUAL_VNIC_MODE \
		UINT32_C(0x8)
	/*
	 * When this flag is set to '1', the VNIC is requested to
	 * be configured to receive only RoCE traffic.
	 * If this flag is set to '0', then this flag shall be
	 * ignored by the HWRM.
	 * If roce_dual_vnic_mode flag is set to '1'
	 * or roce_mirroring_capable_vnic_mode flag to 1,
	 * then the HWRM client shall not set this flag to '1'.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_ROCE_ONLY_VNIC_MODE \
		UINT32_C(0x10)
	/*
	 * When a VNIC uses one destination ring group for certain
	 * application (e.g. Receive Flow Steering) where
	 * exact match is used to direct packets to a VNIC with one
	 * destination ring group only, there is no need to configure
	 * RSS indirection table for that VNIC as only one destination
	 * ring group is used.
	 *
	 * This flag is used to enable a mode where
	 * RSS is enabled in the VNIC using a RSS context
	 * for computing RSS hash but the RSS indirection table is
	 * not configured using hwrm_vnic_rss_cfg.
	 *
	 * If this mode is enabled, then the driver should not program
	 * RSS indirection table for the RSS context that is used for
	 * computing RSS hash only.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_RSS_DFLT_CR_MODE \
		UINT32_C(0x20)
	/*
	 * When this bit is '1', the VNIC is being configured to
	 * receive both RoCE and non-RoCE traffic, but forward only the
	 * RoCE traffic further. Also, RoCE traffic can be mirrored to
	 * L2 driver.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_ROCE_MIRRORING_CAPABLE_VNIC_MODE \
		UINT32_C(0x40)
	/*
	 * When this bit is '1' it enables ring selection using the incoming
	 * spif and lcos for the packet.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_PORTCOS_MAPPING_MODE \
		UINT32_C(0x80)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the dflt_ring_grp field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_DFLT_RING_GRP \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the rss_rule field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_RSS_RULE \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the cos_rule field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_COS_RULE \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the lb_rule field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_LB_RULE \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the mru field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_MRU \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the default_rx_ring_id field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_DEFAULT_RX_RING_ID \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the default_cmpl_ring_id field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_DEFAULT_CMPL_RING_ID \
		UINT32_C(0x40)
	/* This bit must be '1' for the queue_id field to be configured. */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_QUEUE_ID \
		UINT32_C(0x80)
	/* This bit must be '1' for the rx_csum_v2_mode field to be configured. */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_RX_CSUM_V2_MODE \
		UINT32_C(0x100)
	/* This bit must be '1' for the l2_cqe_mode field to be configured. */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_L2_CQE_MODE \
		UINT32_C(0x200)
	/* Logical vnic ID */
	uint16_t	vnic_id;
	/*
	 * Default Completion ring for the VNIC.  This ring will
	 * be chosen if packet does not match any RSS rules and if
	 * there is no COS rule.
	 */
	uint16_t	dflt_ring_grp;
	/*
	 * RSS ID for RSS rule/table structure.  0xFF... (All Fs) if
	 * there is no RSS rule.
	 */
	uint16_t	rss_rule;
	/*
	 * RSS ID for COS rule/table structure.  0xFF... (All Fs) if
	 * there is no COS rule.
	 */
	uint16_t	cos_rule;
	/*
	 * RSS ID for load balancing rule/table structure.
	 * 0xFF... (All Fs) if there is no LB rule.
	 */
	uint16_t	lb_rule;
	/*
	 * The maximum receive unit of the vnic.
	 * Each vnic is associated with a function.
	 * The vnic mru value overwrites the mru setting of the
	 * associated function.
	 * The HWRM shall make sure that vnic mru does not exceed
	 * the mru of the port the function is associated with.
	 */
	uint16_t	mru;
	/*
	 * Default Rx ring for the VNIC.  This ring will
	 * be chosen if packet does not match any RSS rules.
	 * The aggregation ring associated with the Rx ring is
	 * implied based on the Rx ring specified when the
	 * aggregation ring was allocated.
	 */
	uint16_t	default_rx_ring_id;
	/*
	 * Default completion ring for the VNIC.  This ring will
	 * be chosen if packet does not match any RSS rules.
	 */
	uint16_t	default_cmpl_ring_id;
	/*
	 * When specified, only incoming packets classified to the specified CoS
	 * queue ID will be arriving on this VNIC.  Packet priority to CoS mapping
	 * rules can be specified using HWRM_QUEUE_PRI2COS_CFG.  In this mode,
	 * ntuple filters with VNIC destination specified are invalid since they
	 * conflict with the CoS to VNIC steering rules in this mode.
	 *
	 * If this field is not specified, packet to VNIC steering will be
	 * subject to the standard L2 filter rules and any additional ntuple
	 * filter rules with destination VNIC specified.
	 */
	uint16_t	queue_id;
	/*
	 * If the device supports the RX V2 and RX TPA start V2 completion
	 * records as indicated by the HWRM_VNIC_QCAPS command, this field is
	 * used to specify the two RX checksum modes supported by these
	 * completion records.
	 */
	uint8_t	rx_csum_v2_mode;
	/*
	 * When configured with this checksum mode, the number of header
	 * groups in the delivered packet with a valid IP checksum and
	 * the number of header groups in the delivered packet with a valid
	 * L4 checksum are reported. Valid checksums are counted from the
	 * outermost header group to the innermost header group, stopping at
	 * the first error.  This is the default checksum mode supported if
	 * the driver doesn't explicitly configure the RX checksum mode.
	 */
	#define HWRM_VNIC_CFG_INPUT_RX_CSUM_V2_MODE_DEFAULT UINT32_C(0x0)
	/*
	 * When configured with this checksum mode, the checksum status is
	 * reported using 'all ok' mode. In the RX completion record, one
	 * bit indicates if the IP checksum is valid for all the parsed
	 * header groups with an IP checksum. Another bit indicates if the
	 * L4 checksum is valid for all the parsed header groups with an L4
	 * checksum. The number of header groups that were parsed by the
	 * chip and passed in the delivered packet is also reported.
	 */
	#define HWRM_VNIC_CFG_INPUT_RX_CSUM_V2_MODE_ALL_OK  UINT32_C(0x1)
	/*
	 * Any rx_csum_v2_mode value larger than or equal to this is not
	 * valid
	 */
	#define HWRM_VNIC_CFG_INPUT_RX_CSUM_V2_MODE_MAX     UINT32_C(0x2)
	#define HWRM_VNIC_CFG_INPUT_RX_CSUM_V2_MODE_LAST \
		HWRM_VNIC_CFG_INPUT_RX_CSUM_V2_MODE_MAX
	/*
	 * If the device supports different L2 RX CQE modes, as indicated by
	 * the HWRM_VNIC_QCAPS command, this field is used to configure the
	 * CQE mode.
	 */
	uint8_t	l2_cqe_mode;
	/*
	 * When configured with this cqe mode, A normal (32B) CQE
	 * will be generated. This is the default mode.
	 */
	#define HWRM_VNIC_CFG_INPUT_L2_CQE_MODE_DEFAULT    UINT32_C(0x0)
	/*
	 * When configured with this cqe mode, A compressed (16B) CQE
	 * will be generated. In this mode TPA and HDS are not supported.
	 * Host drivers should not configure the TPA and HDS along with
	 * compressed mode, per VNIC. FW returns error, if host drivers
	 * try to configure the VNIC with compressed mode and (TPA or HDS).
	 * The compressed completion does not include PTP data. Host
	 * drivers should not use this mode to receive the PTP data.
	 */
	#define HWRM_VNIC_CFG_INPUT_L2_CQE_MODE_COMPRESSED UINT32_C(0x1)
	/*
	 * When configured with this cqe mode, HW generates either a 32B
	 * completion or a 16B completion depending on use case within a
	 * VNIC. For ex. a simple L2 packet could use the compressed form
	 * while a PTP packet on the same VNIC would use the 32B form.
	 */
	#define HWRM_VNIC_CFG_INPUT_L2_CQE_MODE_MIXED      UINT32_C(0x2)
	#define HWRM_VNIC_CFG_INPUT_L2_CQE_MODE_LAST \
		HWRM_VNIC_CFG_INPUT_L2_CQE_MODE_MIXED
	uint8_t	unused0[4];
} __rte_packed;

/* hwrm_vnic_cfg_output (size:128b/16B) */
struct hwrm_vnic_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************
 * hwrm_vnic_qcfg *
 ******************/


/* hwrm_vnic_qcfg_input (size:256b/32B) */
struct hwrm_vnic_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vf_id_valid field to be
	 * configured.
	 */
	#define HWRM_VNIC_QCFG_INPUT_ENABLES_VF_ID_VALID     UINT32_C(0x1)
	/* Logical vnic ID */
	uint32_t	vnic_id;
	/* ID of Virtual Function whose VNIC resource is being queried. */
	uint16_t	vf_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_vnic_qcfg_output (size:256b/32B) */
struct hwrm_vnic_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Default Completion ring for the VNIC. */
	uint16_t	dflt_ring_grp;
	/*
	 * RSS ID for RSS rule/table structure.  0xFF... (All Fs) if
	 * there is no RSS rule.
	 */
	uint16_t	rss_rule;
	/*
	 * RSS ID for COS rule/table structure.  0xFF... (All Fs) if
	 * there is no COS rule.
	 */
	uint16_t	cos_rule;
	/*
	 * RSS ID for load balancing rule/table structure.
	 * 0xFF... (All Fs) if there is no LB rule.
	 */
	uint16_t	lb_rule;
	/* The maximum receive unit of the vnic. */
	uint16_t	mru;
	uint8_t	unused_0[2];
	uint32_t	flags;
	/*
	 * When this bit is '1', the VNIC is the default VNIC for
	 * the function.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_DEFAULT \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * strip VLAN in the RX path.
	 * If set to '0', then VLAN stripping is disabled on
	 * this VNIC.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_VLAN_STRIP_MODE \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * buffer receive packets in the hardware until the host
	 * posts new receive buffers.
	 * If set to '0', then bd_stall is disabled on
	 * this VNIC.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_BD_STALL_MODE \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * receive both RoCE and non-RoCE traffic.
	 * If set to '0', then this VNIC is not configured to
	 * operate in dual VNIC mode.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_ROCE_DUAL_VNIC_MODE \
		UINT32_C(0x8)
	/*
	 * When this flag is set to '1', the VNIC is configured to
	 * receive only RoCE traffic.
	 * When this flag is set to '0', the VNIC is not configured
	 * to receive only RoCE traffic.
	 * If roce_dual_vnic_mode flag and this flag both are set
	 * to '1', then it is an invalid configuration of the
	 * VNIC. The HWRM should not allow that type of
	 * mis-configuration by HWRM clients.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_ROCE_ONLY_VNIC_MODE \
		UINT32_C(0x10)
	/*
	 * When a VNIC uses one destination ring group for certain
	 * application (e.g. Receive Flow Steering) where
	 * exact match is used to direct packets to a VNIC with one
	 * destination ring group only, there is no need to configure
	 * RSS indirection table for that VNIC as only one destination
	 * ring group is used.
	 *
	 * When this bit is set to '1', then the VNIC is enabled in a
	 * mode where RSS is enabled in the VNIC using a RSS context
	 * for computing RSS hash but the RSS indirection table is
	 * not configured.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_RSS_DFLT_CR_MODE \
		UINT32_C(0x20)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * receive both RoCE and non-RoCE traffic, but forward only
	 * RoCE traffic further. Also RoCE traffic can be mirrored to
	 * L2 driver.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_ROCE_MIRRORING_CAPABLE_VNIC_MODE \
		UINT32_C(0x40)
	/*
	 * When this bit is '0', VNIC is in normal operation state.
	 * When this bit is '1', VNIC drops all the received packets.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_OPERATION_STATE \
		UINT32_C(0x80)
	/* When this bit is '1' it indicates port cos_mapping_mode enabled. */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_PORTCOS_MAPPING_MODE \
		UINT32_C(0x100)
	/*
	 * When returned with a valid CoS Queue id, the CoS Queue/VNIC association
	 * is valid.  Otherwise it will return 0xFFFF to indicate no VNIC/CoS
	 * queue association.
	 */
	uint16_t	queue_id;
	/*
	 * If the device supports the RX V2 and RX TPA start V2 completion
	 * records as indicated by the HWRM_VNIC_QCAPS command, this field is
	 * used to specify the current RX checksum mode configured for all the
	 * RX rings of a VNIC.
	 */
	uint8_t	rx_csum_v2_mode;
	/*
	 * This value indicates that the VNIC is configured to use the
	 * default RX checksum mode for all the rings associated with this
	 * VNIC.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_RX_CSUM_V2_MODE_DEFAULT UINT32_C(0x0)
	/*
	 * This value indicates that the VNIC is configured to use the RX
	 * checksum all_ok mode for all the rings associated with this
	 * VNIC.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_RX_CSUM_V2_MODE_ALL_OK  UINT32_C(0x1)
	/*
	 * Any rx_csum_v2_mode value larger than or equal to this is not
	 * valid
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_RX_CSUM_V2_MODE_MAX     UINT32_C(0x2)
	#define HWRM_VNIC_QCFG_OUTPUT_RX_CSUM_V2_MODE_LAST \
		HWRM_VNIC_QCFG_OUTPUT_RX_CSUM_V2_MODE_MAX
	/*
	 * If the device supports different L2 RX CQE modes, as indicated by
	 * the HWRM_VNIC_QCAPS command, this field is used to convey the
	 * configured CQE mode.
	 */
	uint8_t	l2_cqe_mode;
	/*
	 * This value indicates that the VNIC is configured with normal
	 * (32B) CQE mode.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_L2_CQE_MODE_DEFAULT    UINT32_C(0x0)
	/*
	 * This value indicates that the VNIC is configured with compressed
	 * (16B) CQE mode.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_L2_CQE_MODE_COMPRESSED UINT32_C(0x1)
	/*
	 * This value indicates that the VNIC is configured with mixed
	 * CQE mode. HW generates either a 32B completion or a 16B
	 * completion depending on use case within a VNIC.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_L2_CQE_MODE_MIXED      UINT32_C(0x2)
	#define HWRM_VNIC_QCFG_OUTPUT_L2_CQE_MODE_LAST \
		HWRM_VNIC_QCFG_OUTPUT_L2_CQE_MODE_MIXED
	/*
	 * This field conveys the metadata format type that has been
	 * configured. This value is product specific. Refer to the L2 HSI
	 * completion ring structures for the detailed descriptions. For Thor
	 * and Thor2, it corresponds to meta_format in rx_pkt_cmpl_hi and
	 * rx_pkt_v3_cmpl_hi, respectively.
	 */
	uint8_t	metadata_format_type;
	#define HWRM_VNIC_QCFG_OUTPUT_METADATA_FORMAT_TYPE_0 UINT32_C(0x0)
	#define HWRM_VNIC_QCFG_OUTPUT_METADATA_FORMAT_TYPE_1 UINT32_C(0x1)
	#define HWRM_VNIC_QCFG_OUTPUT_METADATA_FORMAT_TYPE_2 UINT32_C(0x2)
	#define HWRM_VNIC_QCFG_OUTPUT_METADATA_FORMAT_TYPE_3 UINT32_C(0x3)
	#define HWRM_VNIC_QCFG_OUTPUT_METADATA_FORMAT_TYPE_4 UINT32_C(0x4)
	#define HWRM_VNIC_QCFG_OUTPUT_METADATA_FORMAT_TYPE_LAST \
		HWRM_VNIC_QCFG_OUTPUT_METADATA_FORMAT_TYPE_4
	/* This field conveys the VNIC operation state. */
	uint8_t	vnic_state;
	/* Normal operation state. */
	#define HWRM_VNIC_QCFG_OUTPUT_VNIC_STATE_NORMAL UINT32_C(0x0)
	/* Drop all packets. */
	#define HWRM_VNIC_QCFG_OUTPUT_VNIC_STATE_DROP   UINT32_C(0x1)
	#define HWRM_VNIC_QCFG_OUTPUT_VNIC_STATE_LAST \
		HWRM_VNIC_QCFG_OUTPUT_VNIC_STATE_DROP
	uint8_t	unused_1;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************
 * hwrm_vnic_qcaps *
 *******************/


/* hwrm_vnic_qcaps_input (size:192b/24B) */
struct hwrm_vnic_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_vnic_qcaps_output (size:192b/24B) */
struct hwrm_vnic_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The maximum receive unit that is settable on a vnic. */
	uint16_t	mru;
	uint8_t	unused_0[2];
	uint32_t	flags;
	/* Unused. */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_UNUSED \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', the capability of stripping VLAN in
	 * the RX path is supported on VNIC(s).
	 * If set to '0', then VLAN stripping capability is
	 * not supported on VNIC(s).
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_VLAN_STRIP_CAP \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', the capability to buffer receive
	 * packets in the hardware until the host posts new receive buffers
	 * is supported on VNIC(s).
	 * If set to '0', then bd_stall capability is not supported
	 * on VNIC(s).
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_BD_STALL_CAP \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', the capability to
	 * receive both RoCE and non-RoCE traffic on VNIC(s) is
	 * supported.
	 * If set to '0', then the capability to receive
	 * both RoCE and non-RoCE traffic on VNIC(s) is
	 * not supported.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_ROCE_DUAL_VNIC_CAP \
		UINT32_C(0x8)
	/*
	 * When this bit is set to '1', the capability to configure
	 * a VNIC to receive only RoCE traffic is supported.
	 * When this flag is set to '0', the VNIC capability to
	 * configure to receive only RoCE traffic is not supported.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_ROCE_ONLY_VNIC_CAP \
		UINT32_C(0x10)
	/*
	 * When this bit is set to '1', then the capability to enable
	 * a VNIC in a mode where RSS context without configuring
	 * RSS indirection table is supported (for RSS hash computation).
	 * When this bit is set to '0', then a VNIC can not be configured
	 * with a mode to enable RSS context without configuring RSS
	 * indirection table.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_DFLT_CR_CAP \
		UINT32_C(0x20)
	/*
	 * When this bit is '1', the capability to
	 * mirror the RoCE traffic is supported.
	 * If set to '0', then the capability to mirror the
	 * RoCE traffic is not supported.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_ROCE_MIRRORING_CAPABLE_VNIC_CAP \
		UINT32_C(0x40)
	/*
	 * When this bit is '1', the outermost RSS hashing capability
	 * is supported. If set to '0', then the outermost RSS hashing
	 * capability is not supported.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_OUTERMOST_RSS_CAP \
		UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates that firmware supports the
	 * ability to steer incoming packets from one CoS queue to one
	 * VNIC.  This optional feature can then be enabled
	 * using HWRM_VNIC_CFG on any VNIC.  This feature is only
	 * available when NVM option enable_cos_classification is set
	 * to 1.  If set to '0', firmware does not support this feature.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_COS_ASSIGNMENT_CAP \
		UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates that HW and firmware supports
	 * the use of RX V2 and RX TPA start V2 completion records for all
	 * the RX rings of a VNIC. Once set, this feature is mandatory to
	 * be used for the RX rings of the VNIC. Additionally, two new RX
	 * checksum features supported by these completion records can be
	 * configured using the HWRM_VNIC_CFG on a VNIC. If set to '0', the
	 * HW and the firmware does not support this feature.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RX_CMPL_V2_CAP \
		UINT32_C(0x200)
	/*
	 * When this bit is '1', it indicates that HW and firmware support
	 * vnic state change. Host drivers can change the vnic state using
	 * HWRM_VNIC_UPDATE. If set to '0', the HW and firmware do not
	 * support this feature.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_VNIC_STATE_CAP \
		UINT32_C(0x400)
	/*
	 * When this bit is '1', it indicates that firmware supports
	 * virtio-net functions default VNIC allocation using
	 * HWRM_VNIC_ALLOC.
	 * This capability is available only on Proxy VEE PF. If set to '0',
	 * firmware does not support this feature.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_VIRTIO_NET_VNIC_ALLOC_CAP \
		UINT32_C(0x800)
	/*
	 * When this bit is set '1', then the capability to configure the
	 * metadata format in the RX completion is supported for the VNIC.
	 * When this bit is set to '0', then the capability to configure
	 * the metadata format in the RX completion is not supported for
	 * the VNIC.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_METADATA_FORMAT_CAP \
		UINT32_C(0x1000)
	/*
	 * When this bit is set '1', it indicates that firmware returns
	 * INVALID_PARAM error, if host drivers choose invalid hash type
	 * bit combinations in vnic_rss_cfg.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_STRICT_HASH_TYPE_CAP \
		UINT32_C(0x2000)
	/*
	 * When this bit is set '1', it indicates that firmware supports
	 * the hash_type include and exclude flags in hwrm_vnic_rss_cfg.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_HASH_TYPE_DELTA_CAP \
		UINT32_C(0x4000)
	/*
	 * When this bit is '1', it indicates that HW is capable of using
	 * Toeplitz algorithm. This mode uses Toeplitz algorithm and
	 * provided Toeplitz hash key to hash the packets according to the
	 * configured hash type and hash mode. The Toeplitz hash results and
	 * the provided Toeplitz RSS indirection table are used to determine
	 * the RSS rings.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RING_SELECT_MODE_TOEPLITZ_CAP \
		UINT32_C(0x8000)
	/*
	 * When this bit is '1', it indicates that HW is capable of using
	 * XOR algorithm. This mode usesXORalgorithm to hash the packets
	 * according to the configured hash type and hash mode. TheXOR
	 * hash results and the provided XOR RSS indirection table are
	 * used to determine the RSS rings. Host drivers provided hash key
	 * is not honored in this mode.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RING_SELECT_MODE_XOR_CAP \
		UINT32_C(0x10000)
	/*
	 * When this bit is '1', it indicates that HW is capable of using
	 * checksum algorithm. In this mode, HW uses inner packets checksum
	 * algorithm to distribute the packets across the rings and Toeplitz
	 * algorithm to calculate the hash to convey it in the RX
	 * completions. Host drivers should provide Toeplitz hash key.
	 * As HW uses innermost packets checksum to distribute the packets
	 * across the rings, host drivers can't convey hash  mode to choose
	 * outer headers to calculate Toeplitz hash. FW will fail such
	 * configuration.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RING_SELECT_MODE_TOEPLITZ_CHKSM_CAP \
		UINT32_C(0x20000)
	/*
	 * When this bit is '1' HW supports hash calculation
	 * based on IPV6 flow labels.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_IPV6_FLOW_LABEL_CAP \
		UINT32_C(0x40000)
	/*
	 * When this bit is '1', it indicates that HW and firmware supports
	 * the use of RX V3 and RX TPA start V3 completion records for all
	 * the RX rings of a VNIC. Once set, this feature is mandatory to
	 * be used for the RX rings of the VNIC. If set to '0', the
	 * HW and the firmware does not support this feature.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RX_CMPL_V3_CAP \
		UINT32_C(0x80000)
	/*
	 * When this bit is '1' HW supports different RX CQE record types.
	 * Host drivers can choose the mode based on their application
	 * requirements like performance, TPA, HDS and PTP.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_L2_CQE_MODE_CAP \
		UINT32_C(0x100000)
	/*
	 * When this bit is '1' HW supports hash calculation
	 * based on IPv4 IPSEC AH SPI field.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_IPSEC_AH_SPI_IPV4_CAP \
		UINT32_C(0x200000)
	/*
	 * When this bit is '1' HW supports hash calculation
	 * based on IPv4 IPSEC ESP SPI field.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_IPSEC_ESP_SPI_IPV4_CAP \
		UINT32_C(0x400000)
	/*
	 * When this bit is '1' HW supports hash calculation
	 * based on IPv6 IPSEC AH SPI field.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_IPSEC_AH_SPI_IPV6_CAP \
		UINT32_C(0x800000)
	/*
	 * When this bit is '1' HW supports hash calculation
	 * based on IPv6 IPSEC ESP SPI field.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_IPSEC_ESP_SPI_IPV6_CAP \
		UINT32_C(0x1000000)
	/*
	 * When outermost_rss_cap is '1' and this bit is '1', the outermost
	 * RSS hash mode may be set on a PF or trusted VF.
	 * When outermost_rss_cap is '1' and this bit is '0', the outermost
	 * RSS hash mode may be set on a PF.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_OUTERMOST_RSS_TRUSTED_VF_CAP \
		UINT32_C(0x2000000)
	/*
	 * When this bit is '1' it indicates HW is capable of enabling ring
	 * selection using the incoming spif and lcos for the packet.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_PORTCOS_MAPPING_MODE \
		UINT32_C(0x4000000)
	/*
	 * When this bit is '1', it indicates controller enabled
	 * RSS profile TCAM mode.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_PROF_TCAM_MODE_ENABLED \
		UINT32_C(0x8000000)
	/* When this bit is '1' FW supports VNIC hash mode. */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_VNIC_RSS_HASH_MODE_CAP \
		UINT32_C(0x10000000)
	/*
	 * This field advertises the maximum concurrent TPA aggregations
	 * supported by the VNIC on new devices that support TPA v2 or v3.
	 * '0' means that both the TPA v2 and v3 are not supported.
	 */
	uint16_t	max_aggs_supported;
	uint8_t	unused_1[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_vnic_tpa_cfg *
 *********************/


/* hwrm_vnic_tpa_cfg_input (size:320b/40B) */
struct hwrm_vnic_tpa_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) of
	 * non-tunneled TCP packets.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_TPA \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) of
	 * tunneled TCP packets.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_ENCAP_TPA \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) according
	 * to Windows Receive Segment Coalescing (RSC) rules.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_RSC_WND_UPDATE \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) according
	 * to Linux Generic Receive Offload (GRO) rules.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_GRO \
		UINT32_C(0x8)
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) for TCP
	 * packets with IP ECN set to non-zero.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_AGG_WITH_ECN \
		UINT32_C(0x10)
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) for
	 * GRE tunneled TCP packets only if all packets have the
	 * same GRE sequence.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_AGG_WITH_SAME_GRE_SEQ \
		UINT32_C(0x20)
	/*
	 * When this bit is '1' and the GRO mode is enabled,
	 * the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) for
	 * TCP/IPv4 packets with consecutively increasing IPIDs.
	 * In other words, the last packet that is being
	 * aggregated to an already existing aggregation context
	 * shall have IPID 1 more than the IPID of the last packet
	 * that was aggregated in that aggregation context.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_GRO_IPID_CHECK \
		UINT32_C(0x40)
	/*
	 * When this bit is '1' and the GRO mode is enabled,
	 * the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) for
	 * TCP packets with the same TTL (IPv4) or Hop limit (IPv6)
	 * value.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_GRO_TTL_CHECK \
		UINT32_C(0x80)
	/*
	 * When this bit is '1' and the GRO mode is enabled,
	 * the VNIC shall DMA payload data using GRO rules.
	 * When this bit is '0', the VNIC shall DMA payload data
	 * using the more efficient LRO rules of filling all
	 * aggregation buffers.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_AGG_PACK_AS_GRO \
		UINT32_C(0x100)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the max_agg_segs field to be
	 * configured.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_ENABLES_MAX_AGG_SEGS      UINT32_C(0x1)
	/*
	 * This bit must be '1' for the max_aggs field to be
	 * configured.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_ENABLES_MAX_AGGS          UINT32_C(0x2)
	/*
	 * This bit must be '1' for the max_agg_timer field to be
	 * configured.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_ENABLES_MAX_AGG_TIMER     UINT32_C(0x4)
	/* deprecated bit.  Do not use!!! */
	#define HWRM_VNIC_TPA_CFG_INPUT_ENABLES_MIN_AGG_LEN       UINT32_C(0x8)
	/* Logical vnic ID */
	uint16_t	vnic_id;
	/*
	 * This is the maximum number of TCP segments that can
	 * be aggregated (unit is Log2). Max value is 31. On new
	 * devices supporting TPA v2, the unit is multiples of 4 and
	 * valid values are > 0 and <= 63.
	 */
	uint16_t	max_agg_segs;
	/* 1 segment */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_1   UINT32_C(0x0)
	/* 2 segments */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_2   UINT32_C(0x1)
	/* 4 segments */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_4   UINT32_C(0x2)
	/* 8 segments */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_8   UINT32_C(0x3)
	/* Any segment size larger than this is not valid */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_MAX UINT32_C(0x1f)
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_LAST \
		HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_MAX
	/*
	 * This is the maximum number of aggregations this VNIC is
	 * allowed (unit is Log2). Max value is 7. On new devices
	 * supporting TPA v2, this is in unit of 1 and must be > 0
	 * and <= max_aggs_supported in the hwrm_vnic_qcaps response
	 * to enable TPA v2.
	 */
	uint16_t	max_aggs;
	/* 1 aggregation */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_1   UINT32_C(0x0)
	/* 2 aggregations */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_2   UINT32_C(0x1)
	/* 4 aggregations */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_4   UINT32_C(0x2)
	/* 8 aggregations */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_8   UINT32_C(0x3)
	/* 16 aggregations */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_16  UINT32_C(0x4)
	/* Any aggregation size larger than this is not valid */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_MAX UINT32_C(0x7)
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_LAST \
		HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_MAX
	uint8_t	unused_0[2];
	/*
	 * This is the maximum amount of time allowed for
	 * an aggregation context to complete after it was initiated.
	 */
	uint32_t	max_agg_timer;
	/*
	 * This is the minimum amount of payload length required to
	 * start an aggregation context. This field is deprecated and
	 * should be set to 0.  The minimum length is set by firmware
	 * and can be queried using hwrm_vnic_tpa_qcfg.
	 */
	uint32_t	min_agg_len;
} __rte_packed;

/* hwrm_vnic_tpa_cfg_output (size:128b/16B) */
struct hwrm_vnic_tpa_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_vnic_rss_cfg *
 *********************/


/* hwrm_vnic_rss_cfg_input (size:384b/48B) */
struct hwrm_vnic_rss_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	hash_type;
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv4
	 * packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_IPV4 \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of TCP/IPv4 packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_TCP_IPV4 \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of UDP/IPv4 packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_UDP_IPV4 \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv6 addresses of IPv6
	 * packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_IPV6 \
		UINT32_C(0x8)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of TCP/IPv6 packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_TCP_IPV6 \
		UINT32_C(0x10)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of UDP/IPv6 packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_UDP_IPV6 \
		UINT32_C(0x20)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source, destination IPv6 addresses and flow label of IPv6
	 * packets. Hash type ipv6 and ipv6_flow_label are mutually
	 * exclusive. HW does not include the flow_label in hash
	 * calculation for the packets that are matching tcp_ipv6 and
	 * udp_ipv6 hash types. Host drivers should set this bit based on
	 * rss_ipv6_flow_label_cap.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_IPV6_FLOW_LABEL \
		UINT32_C(0x40)
	/*
	 * When this bit is '1', the RSS hash shall be computed over
	 * source/destination IPv4 addresses and IPSEC AH SPI field of IPSEC
	 * AH/IPv4 packets. Host drivers should set this bit based on
	 * rss_ipsec_ah_spi_ipv4_cap.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_AH_SPI_IPV4 \
		UINT32_C(0x80)
	/*
	 * When this bit is '1', the RSS hash shall be computed over
	 * source/destination IPv4 addresses and IPSEC ESP SPI field of IPSEC
	 * ESP/IPv4 packets. Host drivers should set this bit based on
	 * rss_ipsec_esp_spi_ipv4_cap.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_ESP_SPI_IPV4 \
		UINT32_C(0x100)
	/*
	 * When this bit is '1', the RSS hash shall be computed over
	 * source/destination IPv6 addresses and IPSEC AH SPI field of IPSEC
	 * AH/IPv6 packets. Host drivers should set this bit based on
	 * rss_ipsec_ah_spi_ipv6_cap.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_AH_SPI_IPV6 \
		UINT32_C(0x200)
	/*
	 * When this bit is '1', the RSS hash shall be computed over
	 * source/destination IPv6 addresses and IPSEC ESP SPI field of IPSEC
	 * ESP/IPv6 packets. Host drivers should set this bit based on
	 * rss_ipsec_esp_spi_ipv6_cap.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_ESP_SPI_IPV6 \
		UINT32_C(0x400)
	/* VNIC ID of VNIC associated with RSS table being configured. */
	uint16_t	vnic_id;
	/*
	 * Specifies which VNIC ring table pair to configure.
	 * Valid values range from 0 to 7.
	 */
	uint8_t	ring_table_pair_index;
	/*
	 * Flags to specify different RSS hash modes. Global RSS hash mode is
	 * indicated when vnic_id and rss_ctx_idx fields are set to value of
	 * 0xffff. Only PF can initiate global RSS hash mode setting changes.
	 * VNIC RSS hash mode is indicated with valid vnic_id and rss_ctx_idx,
	 * if FW is VNIC_RSS_HASH_MODE capable. FW configures the mode based
	 * on first come first serve order. Global RSS hash mode and VNIC RSS
	 * hash modes are mutually exclusive. FW returns invalid error
	 * if FW receives conflicting requests. To change the current hash
	 * mode, the mode associated drivers need to be unloaded and apply
	 * the new configuration.
	 */
	uint8_t	hash_mode_flags;
	/*
	 * When this bit is '1' and FW is VNIC_RSS_HASH_MODE capable,
	 * innermost_4 and innermost_2 hash modes are used to configure
	 * the tuple mode. When this bit is '1' and FW is not
	 * VNIC_RSS_HASH_MODE capable, It indicates using current RSS hash
	 * mode setting configured in the device otherwise.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_MODE_FLAGS_DEFAULT \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 4 tuples {l3.src, l3.dest,
	 * l4.src, l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_MODE_FLAGS_INNERMOST_4 \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 2 tuples {l3.src, l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_MODE_FLAGS_INNERMOST_2 \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 4 tuples {t_l3.src, t_l3.dest,
	 * t_l4.src, t_l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_MODE_FLAGS_OUTERMOST_4 \
		UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 2 tuples {t_l3.src, t_l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_MODE_FLAGS_OUTERMOST_2 \
		UINT32_C(0x10)
	/* This is the address for rss ring group table */
	uint64_t	ring_grp_tbl_addr;
	/* This is the address for rss hash key table */
	uint64_t	hash_key_tbl_addr;
	/* Index to the rss indirection table. */
	uint16_t	rss_ctx_idx;
	uint8_t	flags;
	/*
	 * When this bit is '1', it indicates that the hash_type field is
	 * interpreted as a change relative the current configuration. Each
	 * '1' bit in hash_type represents a header to add to the current
	 * hash. Zeroes designate the hash_type state bits that should remain
	 * unchanged, if possible. If this constraint on the existing state
	 * cannot be satisfied, then the implementation should preference
	 * adding other headers so as to honor the request to add the
	 * specified headers. It is an error to set this flag concurrently
	 * with hash_type_exclude.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_FLAGS_HASH_TYPE_INCLUDE \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates that the hash_type field is
	 * interpreted as a change relative the current configuration. Each
	 * '1' bit in hash_type represents a header to remove from the
	 * current hash. Zeroes designate the hash_type state bits that
	 * should remain unchanged, if possible. If this constraint on the
	 * existing state cannot be satisfied, then the implementation should
	 * preference removing other headers so as to honor the request to
	 * remove the specified headers. It is an error to set this flag
	 * concurrently with hash_type_include.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_FLAGS_HASH_TYPE_EXCLUDE \
		UINT32_C(0x2)
	uint8_t	ring_select_mode;
	/*
	 * In this mode, HW uses Toeplitz algorithm and provided Toeplitz
	 * hash key to hash the packets according to the configured hash
	 * type and hash mode. The Toeplitz hash results and the provided
	 * Toeplitz RSS indirection table are used to determine the RSS
	 * rings.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_RING_SELECT_MODE_TOEPLITZ \
		UINT32_C(0x0)
	/*
	 * In this mode, HW uses XOR algorithm to hash the packets according
	 * to the configured hash type and hash mode. The XOR hash results
	 * and the provided XOR RSS indirection table are used to determine
	 * the RSS rings. Host drivers provided hash key is not honored in
	 * this mode.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_RING_SELECT_MODE_XOR \
		UINT32_C(0x1)
	/*
	 * In this mode, HW uses inner packets checksum algorithm to
	 * distribute the packets across the rings and Toeplitz algorithm
	 * to calculate the hash to convey it in the RX completions. Host
	 * drivers should provide Toeplitz hash key. As HW uses innermost
	 * packets checksum to distribute the packets across the rings,
	 * host drivers can't convey hash mode to choose outer headers to
	 * calculate Toeplitz hash. FW will fail such configuration.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_RING_SELECT_MODE_TOEPLITZ_CHECKSUM \
		UINT32_C(0x2)
	#define HWRM_VNIC_RSS_CFG_INPUT_RING_SELECT_MODE_LAST \
		HWRM_VNIC_RSS_CFG_INPUT_RING_SELECT_MODE_TOEPLITZ_CHECKSUM
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_vnic_rss_cfg_output (size:128b/16B) */
struct hwrm_vnic_rss_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* hwrm_vnic_rss_cfg_cmd_err (size:64b/8B) */
struct hwrm_vnic_rss_cfg_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_VNIC_RSS_CFG_CMD_ERR_CODE_UNKNOWN \
		UINT32_C(0x0)
	/*
	 * Unable to change global RSS mode to outer due to all active
	 * interfaces are not ready to support outer RSS hashing.
	 */
	#define HWRM_VNIC_RSS_CFG_CMD_ERR_CODE_INTERFACE_NOT_READY \
		UINT32_C(0x1)
	#define HWRM_VNIC_RSS_CFG_CMD_ERR_CODE_LAST \
		HWRM_VNIC_RSS_CFG_CMD_ERR_CODE_INTERFACE_NOT_READY
	uint8_t	unused_0[7];
} __rte_packed;

/**********************
 * hwrm_vnic_rss_qcfg *
 **********************/


/* hwrm_vnic_rss_qcfg_input (size:192b/24B) */
struct hwrm_vnic_rss_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Index to the rss indirection table. This field is used as a lookup
	 * for chips before Thor - i.e. Cumulus and Whitney.
	 */
	uint16_t	rss_ctx_idx;
	/*
	 * VNIC ID of VNIC associated with RSS table being queried. This field
	 * is used as a lookup for Thor and later chips.
	 */
	uint16_t	vnic_id;
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_vnic_rss_qcfg_output (size:512b/64B) */
struct hwrm_vnic_rss_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	hash_type;
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv4
	 * packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_IPV4 \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of TCP/IPv4 packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_TCP_IPV4 \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of UDP/IPv4 packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_UDP_IPV4 \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv6 addresses of IPv6
	 * packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_IPV6 \
		UINT32_C(0x8)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of TCP/IPv6 packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_TCP_IPV6 \
		UINT32_C(0x10)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of UDP/IPv6 packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_UDP_IPV6 \
		UINT32_C(0x20)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source, destination IPv6 addresses and flow label of IPv6
	 * packets. Hash type ipv6 and ipv6_flow_label are mutually
	 * exclusive. HW does not include the flow_label in hash
	 * calculation for the packets that are matching tcp_ipv6 and
	 * udp_ipv6 hash types. This bit will be '0' if
	 * rss_ipv6_flow_label_cap is '0'.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_IPV6_FLOW_LABEL \
		UINT32_C(0x40)
	/*
	 * When this bit is '1', the RSS hash shall be computed over
	 * source/destination IPv4 addresses and IPSEC AH SPI field of IPSEC
	 * AH/IPv4 packets. This bit will be '0' if rss_ipsec_ah_spi_ipv4_cap
	 * is '0'.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_AH_SPI_IPV4 \
		UINT32_C(0x80)
	/*
	 * When this bit is '1', the RSS hash shall be computed over
	 * source/destination IPv4 addresses and IPSEC ESP SPI field of IPSEC
	 * ESP/IPv4 packets. This bit will be '0' if
	 * rss_ipsec_esp_spi_ipv4_cap is '0'.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_ESP_SPI_IPV4 \
		UINT32_C(0x100)
	/*
	 * When this bit is '1', the RSS hash shall be computed over
	 * source/destination IPv6 addresses and IPSEC AH SPI field of IPSEC
	 * AH/IPv6 packets. This bit will be '0' if
	 * rss_ipsec_ah_spi_ipv6_cap is '0'.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_AH_SPI_IPV6 \
		UINT32_C(0x200)
	/*
	 * When this bit is '1', the RSS hash shall be computed over
	 * source/destination IPv6 addresses and IPSEC ESP SPI field of IPSEC
	 * ESP/IPv6 packets. This bit will be '0' if
	 * rss_ipsec_esp_spi_ipv6_cap is '0'.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_ESP_SPI_IPV6 \
		UINT32_C(0x400)
	uint8_t	unused_0[4];
	/* This is the value of rss hash key */
	uint32_t	hash_key[10];
	/*
	 * Flags to specify different RSS hash modes. Setting rss_ctx_idx to
	 * the value of 0xffff implies a global RSS configuration query.
	 * hash_mode_flags are only valid for global RSS configuration query.
	 * Only the PF can initiate a global RSS configuration query.
	 * The query request fails if any VNIC is configured with hash mode
	 * and rss_ctx_idx is 0xffff.
	 */
	uint8_t	hash_mode_flags;
	/*
	 * When this bit is '1' and FW is VNIC_RSS_HASH_MODE capable,
	 * it indicates VNIC's configured RSS hash mode.
	 * When this bit is '1' and FW is not VNIC_RSS_HASH_MODE capable,
	 * It indicates using current RSS hash mode setting configured in the
	 * device.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_MODE_FLAGS_DEFAULT \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 4 tuples {l3.src, l3.dest,
	 * l4.src, l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_MODE_FLAGS_INNERMOST_4 \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 2 tuples {l3.src, l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_MODE_FLAGS_INNERMOST_2 \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 4 tuples {t_l3.src, t_l3.dest,
	 * t_l4.src, t_l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_MODE_FLAGS_OUTERMOST_4 \
		UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 2 tuples {t_l3.src, t_l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_MODE_FLAGS_OUTERMOST_2 \
		UINT32_C(0x10)
	uint8_t	ring_select_mode;
	/*
	 * In this mode, HW uses Toeplitz algorithm and provided Toeplitz
	 * hash key to hash the packets according to the configured hash
	 * type and hash mode. The Toeplitz hash results and the provided
	 * Toeplitz RSS indirection table are used to determine the RSS
	 * rings.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_RING_SELECT_MODE_TOEPLITZ \
		UINT32_C(0x0)
	/*
	 * In this mode, HW uses XOR algorithm to hash the packets according
	 * to the configured hash type and hash mode. The XOR hash results
	 * and the provided XOR RSS indirection table are used to determine
	 * the RSS rings. Host drivers provided hash key is not honored in
	 * this mode.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_RING_SELECT_MODE_XOR \
		UINT32_C(0x1)
	/*
	 * In this mode, HW uses inner packets checksum algorithm to
	 * distribute the packets across the rings and Toeplitz algorithm
	 * to calculate the hash to convey it in the RX completions. Host
	 * drivers should provide Toeplitz hash key. As HW uses innermost
	 * packets checksum to distribute the packets across the rings,
	 * host drivers can't convey hash mode to choose outer headers to
	 * calculate Toeplitz hash. FW will fail such configuration.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_RING_SELECT_MODE_TOEPLITZ_CHECKSUM \
		UINT32_C(0x2)
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_RING_SELECT_MODE_LAST \
		HWRM_VNIC_RSS_QCFG_OUTPUT_RING_SELECT_MODE_TOEPLITZ_CHECKSUM
	uint8_t	unused_1[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_vnic_plcmodes_cfg *
 **************************/


/* hwrm_vnic_plcmodes_cfg_input (size:320b/40B) */
struct hwrm_vnic_plcmodes_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * use regular placement algorithm.
	 * By default, the regular placement algorithm shall be
	 * enabled on the VNIC.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_REGULAR_PLACEMENT \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', the VNIC shall be configured
	 * use the jumbo placement algorithm.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_JUMBO_PLACEMENT \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', the VNIC shall be configured
	 * to enable Header-Data split for IPv4 packets according
	 * to the following rules:
	 * # If the packet is identified as TCP/IPv4, then the
	 * packet is split at the beginning of the TCP payload.
	 * # If the packet is identified as UDP/IPv4, then the
	 * packet is split at the beginning of UDP payload.
	 * # If the packet is identified as non-TCP and non-UDP
	 * IPv4 packet, then the packet is split at the beginning
	 * of the upper layer protocol header carried in the IPv4
	 * packet.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_HDS_IPV4 \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', the VNIC shall be configured
	 * to enable Header-Data split for IPv6 packets according
	 * to the following rules:
	 * # If the packet is identified as TCP/IPv6, then the
	 * packet is split at the beginning of the TCP payload.
	 * # If the packet is identified as UDP/IPv6, then the
	 * packet is split at the beginning of UDP payload.
	 * # If the packet is identified as non-TCP and non-UDP
	 * IPv6 packet, then the packet is split at the beginning
	 * of the upper layer protocol header carried in the IPv6
	 * packet.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_HDS_IPV6 \
		UINT32_C(0x8)
	/*
	 * When this bit is '1', the VNIC shall be configured
	 * to enable Header-Data split for FCoE packets at the
	 * beginning of FC payload.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_HDS_FCOE \
		UINT32_C(0x10)
	/*
	 * When this bit is '1', the VNIC shall be configured
	 * to enable Header-Data split for RoCE packets at the
	 * beginning of RoCE payload (after BTH/GRH headers).
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_HDS_ROCE \
		UINT32_C(0x20)
	/*
	 * When this bit is '1', the VNIC shall be configured use the virtio
	 * placement algorithm. This feature can only be configured when
	 * proxy mode is supported on the function.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_VIRTIO_PLACEMENT \
		UINT32_C(0x40)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the jumbo_thresh_valid field to be
	 * configured.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_ENABLES_JUMBO_THRESH_VALID \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the hds_offset_valid field to be
	 * configured.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_ENABLES_HDS_OFFSET_VALID \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the hds_threshold_valid field to be
	 * configured.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_ENABLES_HDS_THRESHOLD_VALID \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the max_bds_valid field to be
	 * configured.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_ENABLES_MAX_BDS_VALID \
		UINT32_C(0x8)
	/* Logical vnic ID */
	uint32_t	vnic_id;
	/*
	 * When jumbo placement algorithm is enabled, this value
	 * is used to determine the threshold for jumbo placement.
	 * Packets with length larger than this value will be
	 * placed according to the jumbo placement algorithm.
	 */
	uint16_t	jumbo_thresh;
	/*
	 * This value is used to determine the offset into
	 * packet buffer where the split data (payload) will be
	 * placed according to one of HDS placement algorithm.
	 *
	 * The lengths of packet buffers provided for split data
	 * shall be larger than this value.
	 */
	uint16_t	hds_offset;
	/*
	 * When one of the HDS placement algorithm is enabled, this
	 * value is used to determine the threshold for HDS
	 * placement.
	 * Packets with length larger than this value will be
	 * placed according to the HDS placement algorithm.
	 * This value shall be in multiple of 4 bytes.
	 */
	uint16_t	hds_threshold;
	/*
	 * When virtio placement algorithm is enabled, this
	 * value is used to determine the maximum number of BDs
	 * that can be used to place an Rx Packet.
	 * If an incoming packet does not fit in the buffers described
	 * by the max BDs, the packet will be dropped and an error
	 * will be reported in the completion. Valid values for this
	 * field are between 1 and 8. If the VNIC uses header-data-
	 * separation and/or TPA with buffer spanning enabled, valid
	 * values for this field are between 2 and 8.
	 * This feature can only be configured when proxy mode is
	 * supported on the function.
	 */
	uint16_t	max_bds;
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_vnic_plcmodes_cfg_output (size:128b/16B) */
struct hwrm_vnic_plcmodes_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_vnic_plcmodes_qcfg *
 ***************************/


/* hwrm_vnic_plcmodes_qcfg_input (size:192b/24B) */
struct hwrm_vnic_plcmodes_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Logical vnic ID */
	uint32_t	vnic_id;
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_vnic_plcmodes_qcfg_output (size:192b/24B) */
struct hwrm_vnic_plcmodes_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When this bit is '1', the VNIC is configured to
	 * use regular placement algorithm.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_REGULAR_PLACEMENT \
		UINT32_C(0x1)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * use the jumbo placement algorithm.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_JUMBO_PLACEMENT \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', the VNIC is configured
	 * to enable Header-Data split for IPv4 packets.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_HDS_IPV4 \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', the VNIC is configured
	 * to enable Header-Data split for IPv6 packets.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_HDS_IPV6 \
		UINT32_C(0x8)
	/*
	 * When this bit is '1', the VNIC is configured
	 * to enable Header-Data split for FCoE packets.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_HDS_FCOE \
		UINT32_C(0x10)
	/*
	 * When this bit is '1', the VNIC is configured
	 * to enable Header-Data split for RoCE packets.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_HDS_ROCE \
		UINT32_C(0x20)
	/*
	 * When this bit is '1', the VNIC is configured
	 * to be the default VNIC of the requesting function.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_DFLT_VNIC \
		UINT32_C(0x40)
	/*
	 * When this bit is '1', the VNIC is configured to use the virtio
	 * placement algorithm. This feature can only be configured when
	 * proxy mode is supported on the function.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_VIRTIO_PLACEMENT \
		UINT32_C(0x80)
	/*
	 * When jumbo placement algorithm is enabled, this value
	 * is used to determine the threshold for jumbo placement.
	 * Packets with length larger than this value will be
	 * placed according to the jumbo placement algorithm.
	 */
	uint16_t	jumbo_thresh;
	/*
	 * This value is used to determine the offset into
	 * packet buffer where the split data (payload) will be
	 * placed according to one of HDS placement algorithm.
	 *
	 * The lengths of packet buffers provided for split data
	 * shall be larger than this value.
	 */
	uint16_t	hds_offset;
	/*
	 * When one of the HDS placement algorithm is enabled, this
	 * value is used to determine the threshold for HDS
	 * placement.
	 * Packets with length larger than this value will be
	 * placed according to the HDS placement algorithm.
	 * This value shall be in multiple of 4 bytes.
	 */
	uint16_t	hds_threshold;
	/*
	 * When virtio placement algorithm is enabled, this
	 * value is used to determine the maximum number of BDs
	 * that can be used to place an Rx Packet.
	 * If an incoming packet does not fit in the buffers described
	 * by the max BDs, the packet will be dropped and an error
	 * will be reported in the completion. Valid values for this
	 * field are between 1 and 8. If the VNIC uses header-data-
	 * separation and/or TPA with buffer spanning enabled, valid
	 * values for this field are between 2 and 8.
	 * This feature can only be configured when proxy mode is supported
	 * on the function
	 */
	uint16_t	max_bds;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************************
 * hwrm_vnic_rss_cos_lb_ctx_alloc *
 **********************************/


/* hwrm_vnic_rss_cos_lb_ctx_alloc_input (size:128b/16B) */
struct hwrm_vnic_rss_cos_lb_ctx_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_vnic_rss_cos_lb_ctx_alloc_output (size:128b/16B) */
struct hwrm_vnic_rss_cos_lb_ctx_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* rss_cos_lb_ctx_id is 16 b */
	uint16_t	rss_cos_lb_ctx_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************************
 * hwrm_vnic_rss_cos_lb_ctx_free *
 *********************************/


/* hwrm_vnic_rss_cos_lb_ctx_free_input (size:192b/24B) */
struct hwrm_vnic_rss_cos_lb_ctx_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* rss_cos_lb_ctx_id is 16 b */
	uint16_t	rss_cos_lb_ctx_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_vnic_rss_cos_lb_ctx_free_output (size:128b/16B) */
struct hwrm_vnic_rss_cos_lb_ctx_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************
 * hwrm_ring_alloc *
 *******************/


/* hwrm_ring_alloc_input (size:704b/88B) */
struct hwrm_ring_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the ring_arb_cfg field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_RING_ARB_CFG \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the stat_ctx_id_valid field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_STAT_CTX_ID_VALID \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the max_bw_valid field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_MAX_BW_VALID \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the rx_ring_id field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_RX_RING_ID_VALID \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the nq_ring_id field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_NQ_RING_ID_VALID \
		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the rx_buf_size field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_RX_BUF_SIZE_VALID \
		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the schq_id field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_SCHQ_ID \
		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the mpc_chnls_type field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_MPC_CHNLS_TYPE \
		UINT32_C(0x400)
	/* Ring Type. */
	uint8_t	ring_type;
	/* L2 Completion Ring (CR) */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_L2_CMPL   UINT32_C(0x0)
	/* TX Ring (TR) */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_TX        UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_RX        UINT32_C(0x2)
	/* RoCE Notification Completion Ring (ROCE_CR) */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_ROCE_CMPL UINT32_C(0x3)
	/* RX Aggregation Ring */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_RX_AGG    UINT32_C(0x4)
	/* Notification Queue */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_NQ        UINT32_C(0x5)
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_LAST \
		HWRM_RING_ALLOC_INPUT_RING_TYPE_NQ
	/*
	 * This field controls the number of packets transmitted before a TX
	 * completion is generated. Non-zero values for the field are only
	 * valid if HWRM_FUNC_QCAPS indicates that the TX coalesced completion
	 * records capability is supported.
	 */
	uint8_t	cmpl_coal_cnt;
	/* Generates a legacy TX completion on every packet. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_OFF UINT32_C(0x0)
	/* Generates a TX coalesced completion for up to 4 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_4   UINT32_C(0x1)
	/* Generates a TX coalesced completion for up to 8 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_8   UINT32_C(0x2)
	/* Generates a TX coalesced completion for up to 12 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_12  UINT32_C(0x3)
	/* Generates a TX coalesced completion for up to 16 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_16  UINT32_C(0x4)
	/* Generates a TX coalesced completion for up to 24 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_24  UINT32_C(0x5)
	/* Generates a TX coalesced completion for up to 32 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_32  UINT32_C(0x6)
	/* Generates a TX coalesced completion for up to 48 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_48  UINT32_C(0x7)
	/* Generates a TX coalesced completion for up to 64 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_64  UINT32_C(0x8)
	/* Generates a TX coalesced completion for up to 96 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_96  UINT32_C(0x9)
	/* Generates a TX coalesced completion for up to 128 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_128 UINT32_C(0xa)
	/* Generates a TX coalesced completion for up to 192 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_192 UINT32_C(0xb)
	/* Generates a TX coalesced completion for up to 256 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_256 UINT32_C(0xc)
	/* Generates a TX coalesced completion for up to 320 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_320 UINT32_C(0xd)
	/* Generates a TX coalesced completion for up to 384 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_384 UINT32_C(0xe)
	/* Generates a TX coalesced completion up to the last packet. (Maximum coalescing). */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_MAX UINT32_C(0xf)
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_LAST \
		HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_MAX
	/* Ring allocation flags. */
	uint16_t	flags;
	/*
	 * For Rx rings, the incoming packet data can be placed at either
	 * a 0B or 2B offset from the start of the Rx packet buffer. When
	 * '1', the received packet will be padded with 2B of zeros at the
	 * front of the packet. Note that this flag is only used for
	 * Rx rings and is ignored for all other rings included Rx
	 * Aggregation rings.
	 */
	#define HWRM_RING_ALLOC_INPUT_FLAGS_RX_SOP_PAD \
		UINT32_C(0x1)
	/*
	 * When the HW Doorbell Drop Recovery feature is enabled,
	 * HW can flag false CQ overflow when CQ consumer index
	 * doorbells are dropped when there really wasn't any overflow.
	 * The CQE values could have already been processed by the driver,
	 * but HW doesn't know about this because of the doorbell drop.
	 * To avoid false detection of CQ overflow events,
	 * it is recommended that CQ overflow detection is disabled
	 * by the driver when HW based doorbell recovery is enabled.
	 */
	#define HWRM_RING_ALLOC_INPUT_FLAGS_DISABLE_CQ_OVERFLOW_DETECTION \
		UINT32_C(0x2)
	/*
	 * Used with enhanced Doorbell Pacing feature, when set to '1'
	 * this flag indicates that the NQ id that's allocated should be
	 * used for DBR pacing notifications.
	 */
	#define HWRM_RING_ALLOC_INPUT_FLAGS_NQ_DBR_PACING \
		UINT32_C(0x4)
	/*
	 * Host driver should set this flag bit to '1' to enable
	 * two-completion TX packet timestamp feature. By enabling this
	 * per QP flag and enabling stamp bit in TX BD lflags, host drivers
	 * expect two completions, one for regular TX completion and the
	 * other completion with timestamp. For a QP with both completion
	 * coalescing and timestamp completion features enabled, completion
	 * coalescing takes place on regular TX completions. The timestamp
	 * completions are not coalesced and a separate timestamp completion
	 * is generated for each packet with stamp bit set in the TX BD
	 * lflags.
	 */
	#define HWRM_RING_ALLOC_INPUT_FLAGS_TX_PKT_TS_CMPL_ENABLE \
		UINT32_C(0x8)
	/*
	 * This value is a pointer to the page table for the
	 * Ring.
	 */
	uint64_t	page_tbl_addr;
	/* First Byte Offset of the first entry in the first page. */
	uint32_t	fbo;
	/*
	 * Actual page size in 2^page_size. The supported range is increments
	 * in powers of 2 from 16 bytes to 1GB.
	 * - 4 = 16 B
	 *     Page size is 16 B.
	 * - 12 = 4 KB
	 *     Page size is 4 KB.
	 * - 13 = 8 KB
	 *     Page size is 8 KB.
	 * - 16 = 64 KB
	 *     Page size is 64 KB.
	 * - 21 = 2 MB
	 *     Page size is 2 MB.
	 * - 22 = 4 MB
	 *     Page size is 4 MB.
	 * - 30 = 1 GB
	 *     Page size is 1 GB.
	 */
	uint8_t	page_size;
	/*
	 * This value indicates the depth of page table.
	 * For this version of the specification, value other than 0 or
	 * 1 shall be considered as an invalid value.
	 * When the page_tbl_depth = 0, then it is treated as a
	 * special case with the following.
	 * 1. FBO and page size fields are not valid.
	 * 2. page_tbl_addr is the physical address of the first
	 *    element of the ring.
	 */
	uint8_t	page_tbl_depth;
	/* Used by a PF driver to associate a SCHQ with one of its TX rings. */
	uint16_t	schq_id;
	/*
	 * Number of 16B units in the ring.  Minimum size for
	 * a ring is 16 16B entries.
	 */
	uint32_t	length;
	/*
	 * Logical ring number for the ring to be allocated.
	 * This value determines the position in the doorbell
	 * area where the update to the ring will be made.
	 *
	 * For completion rings, this value is also the MSI-X
	 * vector number for the function the completion ring is
	 * associated with.
	 */
	uint16_t	logical_id;
	/*
	 * This field is used only when ring_type is a TX ring.
	 * This value indicates what completion ring the TX ring
	 * is associated with.
	 */
	uint16_t	cmpl_ring_id;
	/*
	 * This field is used only when ring_type is a TX ring.
	 * This value indicates what CoS queue the TX ring
	 * is associated with.
	 */
	uint16_t	queue_id;
	/*
	 * When allocating a Rx ring or Rx aggregation ring, this field
	 * specifies the size of the buffer descriptors posted to the ring.
	 */
	uint16_t	rx_buf_size;
	/*
	 * When allocating an Rx aggregation ring, this field
	 * specifies the associated Rx ring ID.
	 */
	uint16_t	rx_ring_id;
	/*
	 * When allocating a completion ring, this field
	 * specifies the associated NQ ring ID.
	 */
	uint16_t	nq_ring_id;
	/*
	 * This field is used only when ring_type is a TX ring.
	 * This field is used to configure arbitration related
	 * parameters for a TX ring.
	 */
	uint16_t	ring_arb_cfg;
	/* Arbitration policy used for the ring. */
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_MASK \
		UINT32_C(0xf)
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_SFT       0
	/*
	 * Use strict priority for the TX ring.
	 * Priority value is specified in arb_policy_param
	 */
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_SP \
		UINT32_C(0x1)
	/*
	 * Use weighted fair queue arbitration for the TX ring.
	 * Weight is specified in arb_policy_param
	 */
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_WFQ \
		UINT32_C(0x2)
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_LAST \
		HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_WFQ
	/* Reserved field. */
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_RSVD_MASK \
		UINT32_C(0xf0)
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_RSVD_SFT             4
	/*
	 * Arbitration policy specific parameter.
	 * # For strict priority arbitration policy, this field
	 * represents a priority value. If set to 0, then the priority
	 * is not specified and the HWRM is allowed to select
	 * any priority for this TX ring.
	 * # For weighted fair queue arbitration policy, this field
	 * represents a weight value. If set to 0, then the weight
	 * is not specified and the HWRM is allowed to select
	 * any weight for this TX ring.
	 */
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_PARAM_MASK \
		UINT32_C(0xff00)
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_PARAM_SFT 8
	uint16_t	unused_3;
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint32_t	reserved3;
	/*
	 * This field is used only when ring_type is a TX ring.
	 * This input indicates what statistics context this ring
	 * should be associated with.
	 */
	uint32_t	stat_ctx_id;
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint32_t	reserved4;
	/*
	 * This field is used only when ring_type is a TX ring
	 * to specify maximum BW allocated to the TX ring.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this ring inside the device.
	 */
	uint32_t	max_bw;
	/* The bandwidth value. */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_SFT              0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE_LAST \
		HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_SFT         29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_LAST \
		HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_INVALID
	/*
	 * This field is used only when ring_type is a Completion ring.
	 * This value indicates what interrupt mode should be used
	 * on this completion ring.
	 * Note: In the legacy interrupt mode, no more than 16
	 * completion rings are allowed.
	 */
	uint8_t	int_mode;
	/* Legacy INTA (deprecated) */
	#define HWRM_RING_ALLOC_INPUT_INT_MODE_LEGACY UINT32_C(0x0)
	/* Reserved */
	#define HWRM_RING_ALLOC_INPUT_INT_MODE_RSVD   UINT32_C(0x1)
	/* MSI-X */
	#define HWRM_RING_ALLOC_INPUT_INT_MODE_MSIX   UINT32_C(0x2)
	/* No Interrupt - Polled mode */
	#define HWRM_RING_ALLOC_INPUT_INT_MODE_POLL   UINT32_C(0x3)
	#define HWRM_RING_ALLOC_INPUT_INT_MODE_LAST \
		HWRM_RING_ALLOC_INPUT_INT_MODE_POLL
	/* Midpath channel type */
	uint8_t	mpc_chnls_type;
	/*
	 * Indicate the TX ring alloc MPC channel type is a MPC channel
	 * with destination to the TX crypto engine block.
	 */
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_TCE     UINT32_C(0x0)
	/*
	 * Indicate the RX ring alloc MPC channel type is a MPC channel
	 * with destination to the RX crypto engine block.
	 */
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_RCE     UINT32_C(0x1)
	/*
	 * Indicate the RX ring alloc MPC channel type is a MPC channel
	 * with destination to the TX configurable flow processing block.
	 */
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_TE_CFA  UINT32_C(0x2)
	/*
	 * Indicate the RX ring alloc MPC channel type is a MPC channel
	 * with destination to the RX configurable flow processing block.
	 */
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_RE_CFA  UINT32_C(0x3)
	/*
	 * Indicate the RX ring alloc MPC channel type is a MPC channel
	 * with destination to the primate processor block.
	 */
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_PRIMATE UINT32_C(0x4)
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_LAST \
		HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_PRIMATE
	uint8_t	unused_4[2];
	/*
	 * The cq_handle is specified when allocating a completion ring. For
	 * devices that support NQs, this cq_handle will be included in the
	 * NQE to specify which CQ should be read to retrieve the completion
	 * record.
	 */
	uint64_t	cq_handle;
} __rte_packed;

/* hwrm_ring_alloc_output (size:128b/16B) */
struct hwrm_ring_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Physical number of ring allocated.
	 * This value shall be unique for a ring type.
	 */
	uint16_t	ring_id;
	/* Logical number of ring allocated. */
	uint16_t	logical_ring_id;
	/*
	 * This field will tell whether to use ping or pong buffer
	 * for first push operation.
	 */
	uint8_t	push_buffer_index;
	/* Start push from ping buffer index */
	#define HWRM_RING_ALLOC_OUTPUT_PUSH_BUFFER_INDEX_PING_BUFFER \
		UINT32_C(0x0)
	/* Start push from pong buffer index */
	#define HWRM_RING_ALLOC_OUTPUT_PUSH_BUFFER_INDEX_PONG_BUFFER \
		UINT32_C(0x1)
	#define HWRM_RING_ALLOC_OUTPUT_PUSH_BUFFER_INDEX_LAST \
		HWRM_RING_ALLOC_OUTPUT_PUSH_BUFFER_INDEX_PONG_BUFFER
	uint8_t	unused_0[2];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************
 * hwrm_ring_free *
 ******************/


/* hwrm_ring_free_input (size:256b/32B) */
struct hwrm_ring_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Ring Type. */
	uint8_t	ring_type;
	/* L2 Completion Ring (CR) */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_L2_CMPL   UINT32_C(0x0)
	/* TX Ring (TR) */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_TX        UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_RX        UINT32_C(0x2)
	/* RoCE Notification Completion Ring (ROCE_CR) */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_ROCE_CMPL UINT32_C(0x3)
	/* RX Aggregation Ring */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_RX_AGG    UINT32_C(0x4)
	/* Notification Queue */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_NQ        UINT32_C(0x5)
	#define HWRM_RING_FREE_INPUT_RING_TYPE_LAST \
		HWRM_RING_FREE_INPUT_RING_TYPE_NQ
	uint8_t	flags;
	/*
	 * If this bit is set to '1', ring_id in this command belongs to
	 * virtio function. prod_idx in this command corresponds to doorbell
	 * producer index. opaque field in this command needs to be inserted
	 * by firmware in VEE_FLUSH completion record.
	 * Firmware will poll the corresponding ring context to reach the
	 * given producer index before sending successful response. It will
	 * finish the completion using VEE_FLUSH completion record.
	 *
	 * If this bit is '0', firmware will not treat ring_id as virtio
	 * ring and ignore prod_idx, opaque fields.
	 *
	 * This feature is not applicable for L2 or RoCE.
	 */
	#define HWRM_RING_FREE_INPUT_FLAGS_VIRTIO_RING_VALID UINT32_C(0x1)
	#define HWRM_RING_FREE_INPUT_FLAGS_LAST \
		HWRM_RING_FREE_INPUT_FLAGS_VIRTIO_RING_VALID
	/* Physical number of ring allocated. */
	uint16_t	ring_id;
	/*
	 * Ring BD producer index posted by the virtio block.
	 * This field is valid if virtio_ring_valid flag is set.
	 */
	uint32_t	prod_idx;
	/*
	 * User defined opaque field to be inserted into VEE_FLUSH completion
	 * record. This field is valid if virtio_ring_valid flag is set.
	 */
	uint32_t	opaque;
	uint32_t	unused_1;
} __rte_packed;

/* hwrm_ring_free_output (size:128b/16B) */
struct hwrm_ring_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************
 * hwrm_ring_reset *
 *******************/


/* hwrm_ring_reset_input (size:192b/24B) */
struct hwrm_ring_reset_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Ring Type. */
	uint8_t	ring_type;
	/* L2 Completion Ring (CR) */
	#define HWRM_RING_RESET_INPUT_RING_TYPE_L2_CMPL     UINT32_C(0x0)
	/* TX Ring (TR) */
	#define HWRM_RING_RESET_INPUT_RING_TYPE_TX          UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_RING_RESET_INPUT_RING_TYPE_RX          UINT32_C(0x2)
	/* RoCE Notification Completion Ring (ROCE_CR) */
	#define HWRM_RING_RESET_INPUT_RING_TYPE_ROCE_CMPL   UINT32_C(0x3)
	/*
	 * Rx Ring Group.  This is to reset rx and aggregation in an atomic
	 * operation. Completion ring associated with this ring group is
	 * not reset.
	 */
	#define HWRM_RING_RESET_INPUT_RING_TYPE_RX_RING_GRP UINT32_C(0x6)
	#define HWRM_RING_RESET_INPUT_RING_TYPE_LAST \
		HWRM_RING_RESET_INPUT_RING_TYPE_RX_RING_GRP
	uint8_t	unused_0;
	/*
	 * Physical number of the ring. When ring type is rx_ring_grp, ring id
	 * actually refers to ring group id.
	 */
	uint16_t	ring_id;
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_ring_reset_output (size:128b/16B) */
struct hwrm_ring_reset_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field will tell whether to use ping or pong buffer
	 * for first push operation.
	 */
	uint8_t	push_buffer_index;
	/* Start push from ping buffer index */
	#define HWRM_RING_RESET_OUTPUT_PUSH_BUFFER_INDEX_PING_BUFFER \
		UINT32_C(0x0)
	/* Start push from pong buffer index */
	#define HWRM_RING_RESET_OUTPUT_PUSH_BUFFER_INDEX_PONG_BUFFER \
		UINT32_C(0x1)
	#define HWRM_RING_RESET_OUTPUT_PUSH_BUFFER_INDEX_LAST \
		HWRM_RING_RESET_OUTPUT_PUSH_BUFFER_INDEX_PONG_BUFFER
	uint8_t	unused_0[3];
	/* Position of consumer index after ring reset completes. */
	uint8_t	consumer_idx[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************
 * hwrm_ring_cfg *
 *****************/


/* hwrm_ring_cfg_input (size:320b/40B) */
struct hwrm_ring_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Ring Type. */
	uint8_t	ring_type;
	/* TX Ring (TR) */
	#define HWRM_RING_CFG_INPUT_RING_TYPE_TX UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_RING_CFG_INPUT_RING_TYPE_RX UINT32_C(0x2)
	#define HWRM_RING_CFG_INPUT_RING_TYPE_LAST \
		HWRM_RING_CFG_INPUT_RING_TYPE_RX
	uint8_t	unused_0;
	/* Physical number of the ring. */
	uint16_t	ring_id;
	/* Ring config enable bits. */
	uint16_t	enables;
	/*
	 * For Rx rings, the incoming packet data can be placed at either
	 * a 0B, 2B, 10B or 12B offset from the start of the Rx packet
	 * buffer.
	 * When '1', the received packet will be padded with 2B, 10B or 12B
	 * of zeros at the front of the packet. The exact offset is specified
	 * by rx_sop_pad_bytes parameter.
	 * When '0', the received packet will not be padded.
	 * Note that this flag is only used for Rx rings and is ignored
	 * for all other rings included Rx Aggregation rings.
	 */
	#define HWRM_RING_CFG_INPUT_ENABLES_RX_SOP_PAD_ENABLE \
		UINT32_C(0x1)
	/*
	 * Proxy mode enable, for Tx, Rx and Rx aggregation rings only.
	 * When rings are allocated, the PCI function on which driver issues
	 * HWRM_RING_CFG command is assumed to own the rings. Hardware takes
	 * the buffer descriptors (BDs) from those rings is assumed to issue
	 * packet payload DMA using same PCI function. When proxy mode is
	 * enabled, hardware can perform payload DMA using another PCI
	 * function on same or different host.
	 * When set to '0', the PCI function on which driver issues
	 * HWRM_RING_CFG command is used for host payload DMA operation.
	 * When set to '1', the host PCI function specified by proxy_fid is
	 * used for host payload DMA operation.
	 */
	#define HWRM_RING_CFG_INPUT_ENABLES_PROXY_MODE_ENABLE \
		UINT32_C(0x2)
	/*
	 * Tx ring packet source interface override, for Tx rings only.
	 * When TX rings are allocated, the PCI function on which driver
	 * issues HWRM_RING_CFG is assumed to be source interface of
	 * packets sent from TX ring.
	 * When set to '1', the host PCI function specified by proxy_fid
	 * is used as source interface of the transmitted packets.
	 */
	#define HWRM_RING_CFG_INPUT_ENABLES_TX_PROXY_SRC_INTF_OVERRIDE \
		UINT32_C(0x4)
	/* The schq_id field is valid */
	#define HWRM_RING_CFG_INPUT_ENABLES_SCHQ_ID \
		UINT32_C(0x8)
	/* Update completion ring ID associated with Tx or Rx ring. */
	#define HWRM_RING_CFG_INPUT_ENABLES_CMPL_RING_ID_UPDATE \
		UINT32_C(0x10)
	/*
	 * When set to '1', metadata value provided by tx_metadata
	 * field in this command is inserted in the lb_header_metadata
	 * QP context field. When set to '0', no change done to metadata.
	 * Firmware rejects the tx ring metadata programming with
	 * HWRM_ERR_CODE_UNSUPPORTED error if the per function CFA BD
	 * metadata feature is not disabled.
	 */
	#define HWRM_RING_CFG_INPUT_ENABLES_TX_METADATA \
		UINT32_C(0x20)
	/*
	 * Proxy function FID value.
	 * This value is only used when either proxy_mode_enable flag or
	 * tx_proxy_svif_override is set to '1'.
	 * When proxy_mode_enable is set to '1', it identifies a host PCI
	 * function used for host payload DMA operations.
	 * When tx_proxy_src_intf is set to '1', it identifies a host PCI
	 * function as source interface for all transmitted packets from
	 * the TX ring.
	 */
	uint16_t	proxy_fid;
	/*
	 * Identifies the new scheduler queue (SCHQ) to associate with the
	 * ring. Only valid for Tx rings.
	 * A value of zero indicates that the Tx ring should be associated
	 * with the default scheduler queue (SCHQ).
	 */
	uint16_t	schq_id;
	/*
	 * This field is valid for TX or Rx rings. This value identifies the
	 * new completion ring ID to associate with the TX or Rx ring.
	 */
	uint16_t	cmpl_ring_id;
	/*
	 * Rx SOP padding amount in bytes.
	 * This value is only used when rx_sop_pad_enable flag is set to '1'.
	 */
	uint8_t	rx_sop_pad_bytes;
	uint8_t	unused_1[3];
	/*
	 * When tx_metadata enable bit is set, value specified in this field
	 * is copied to lb_header_metadata in the QP context.
	 */
	uint32_t	tx_metadata;
	uint8_t	unused_2[4];
} __rte_packed;

/* hwrm_ring_cfg_output (size:128b/16B) */
struct hwrm_ring_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************
 * hwrm_ring_qcfg *
 ******************/


/* hwrm_ring_qcfg_input (size:192b/24B) */
struct hwrm_ring_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Ring Type. */
	uint8_t	ring_type;
	/* TX Ring (TR) */
	#define HWRM_RING_QCFG_INPUT_RING_TYPE_TX UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_RING_QCFG_INPUT_RING_TYPE_RX UINT32_C(0x2)
	#define HWRM_RING_QCFG_INPUT_RING_TYPE_LAST \
		HWRM_RING_QCFG_INPUT_RING_TYPE_RX
	uint8_t	unused_0[5];
	/* Physical number of the ring. */
	uint16_t	ring_id;
} __rte_packed;

/* hwrm_ring_qcfg_output (size:256b/32B) */
struct hwrm_ring_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Ring config enable bits. */
	uint16_t	enables;
	/*
	 * For Rx rings, the incoming packet data can be placed at either
	 * a 0B, 2B, 10B or 12B offset from the start of the Rx packet
	 * buffer.
	 * When '1', the received packet will be padded with 2B, 10B or 12B
	 * of zeros at the front of the packet. The exact offset is specified
	 * by rx_sop_pad_bytes parameter.
	 * When '0', the received packet will not be padded.
	 * Note that this flag is only used for Rx rings and is ignored
	 * for all other rings included Rx Aggregation rings.
	 */
	#define HWRM_RING_QCFG_OUTPUT_ENABLES_RX_SOP_PAD_ENABLE \
		UINT32_C(0x1)
	/*
	 * Proxy mode enable, for Tx, Rx and Rx aggregation rings only.
	 * When rings are allocated, the PCI function on which driver issues
	 * HWRM_RING_CFG command is assumed to own the rings. Hardware takes
	 * the buffer descriptors (BDs) from those rings is assumed to issue
	 * packet payload DMA using same PCI function. When proxy mode is
	 * enabled, hardware can perform payload DMA using another PCI
	 * function on same or different host.
	 * When set to '0', the PCI function on which driver issues
	 * HWRM_RING_CFG command is used for host payload DMA operation.
	 * When set to '1', the host PCI function specified by proxy_fid is
	 * used for host payload DMA operation.
	 */
	#define HWRM_RING_QCFG_OUTPUT_ENABLES_PROXY_MODE_ENABLE \
		UINT32_C(0x2)
	/*
	 * Tx ring packet source interface override, for Tx rings only.
	 * When TX rings are allocated, the PCI function on which driver
	 * issues HWRM_RING_CFG is assumed to be source interface of
	 * packets sent from TX ring.
	 * When set to '1', the host PCI function specified by proxy_fid is
	 * used as source interface of the transmitted packets.
	 */
	#define HWRM_RING_QCFG_OUTPUT_ENABLES_TX_PROXY_SRC_INTF_OVERRIDE \
		UINT32_C(0x4)
	/*
	 * Proxy function FID value.
	 * This value is only used when either proxy_mode_enable flag or
	 * tx_proxy_svif_override is set to '1'.
	 * When proxy_mode_enable is set to '1', it identifies a host PCI
	 * function used for host payload DMA operations.
	 * When tx_proxy_src_intf is set to '1', it identifies a host PCI
	 * function as source interface for all transmitted packets from the TX
	 * ring.
	 */
	uint16_t	proxy_fid;
	/*
	 * Identifies the new scheduler queue (SCHQ) to associate with the
	 * ring. Only valid for Tx rings.
	 * A value of zero indicates that the Tx ring should be associated with
	 * the default scheduler queue (SCHQ).
	 */
	uint16_t	schq_id;
	/*
	 * This field is used when ring_type is a TX or Rx ring.
	 * This value indicates what completion ring the TX or Rx ring
	 * is associated with.
	 */
	uint16_t	cmpl_ring_id;
	/*
	 * Rx SOP padding amount in bytes.
	 * This value is only used when rx_sop_pad_enable flag is set to '1'.
	 */
	uint8_t	rx_sop_pad_bytes;
	uint8_t	unused_0[3];
	/* lb_header_metadata in the QP context is copied to this field. */
	uint32_t	tx_metadata;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_ring_aggint_qcaps *
 **************************/


/* hwrm_ring_aggint_qcaps_input (size:128b/16B) */
struct hwrm_ring_aggint_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_ring_aggint_qcaps_output (size:384b/48B) */
struct hwrm_ring_aggint_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	cmpl_params;
	/*
	 * When this bit is set to '1', int_lat_tmr_min can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_INT_LAT_TMR_MIN \
		UINT32_C(0x1)
	/*
	 * When this bit is set to '1', int_lat_tmr_max can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_INT_LAT_TMR_MAX \
		UINT32_C(0x2)
	/*
	 * When this bit is set to '1', timer_reset can be enabled
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_TIMER_RESET \
		UINT32_C(0x4)
	/*
	 * When this bit is set to '1', ring_idle can be enabled
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_RING_IDLE \
		UINT32_C(0x8)
	/*
	 * When this bit is set to '1', num_cmpl_dma_aggr can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_NUM_CMPL_DMA_AGGR \
		UINT32_C(0x10)
	/*
	 * When this bit is set to '1', num_cmpl_dma_aggr_during_int can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_NUM_CMPL_DMA_AGGR_DURING_INT \
		UINT32_C(0x20)
	/*
	 * When this bit is set to '1', cmpl_aggr_dma_tmr can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_CMPL_AGGR_DMA_TMR \
		UINT32_C(0x40)
	/*
	 * When this bit is set to '1', cmpl_aggr_dma_tmr_during_int can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_CMPL_AGGR_DMA_TMR_DURING_INT \
		UINT32_C(0x80)
	/*
	 * When this bit is set to '1', num_cmpl_aggr_int can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_NUM_CMPL_AGGR_INT \
		UINT32_C(0x100)
	uint32_t	nq_params;
	/*
	 * When this bit is set to '1', int_lat_tmr_min can be configured
	 * on notification queues.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_NQ_PARAMS_INT_LAT_TMR_MIN \
		UINT32_C(0x1)
	/* Minimum value for num_cmpl_dma_aggr */
	uint16_t	num_cmpl_dma_aggr_min;
	/* Maximum value for num_cmpl_dma_aggr */
	uint16_t	num_cmpl_dma_aggr_max;
	/* Minimum value for num_cmpl_dma_aggr_during_int */
	uint16_t	num_cmpl_dma_aggr_during_int_min;
	/* Maximum value for num_cmpl_dma_aggr_during_int */
	uint16_t	num_cmpl_dma_aggr_during_int_max;
	/* Minimum value for cmpl_aggr_dma_tmr */
	uint16_t	cmpl_aggr_dma_tmr_min;
	/* Maximum value for cmpl_aggr_dma_tmr */
	uint16_t	cmpl_aggr_dma_tmr_max;
	/* Minimum value for cmpl_aggr_dma_tmr_during_int */
	uint16_t	cmpl_aggr_dma_tmr_during_int_min;
	/* Maximum value for cmpl_aggr_dma_tmr_during_int */
	uint16_t	cmpl_aggr_dma_tmr_during_int_max;
	/* Minimum value for int_lat_tmr_min */
	uint16_t	int_lat_tmr_min_min;
	/* Maximum value for int_lat_tmr_min */
	uint16_t	int_lat_tmr_min_max;
	/* Minimum value for int_lat_tmr_max */
	uint16_t	int_lat_tmr_max_min;
	/* Maximum value for int_lat_tmr_max */
	uint16_t	int_lat_tmr_max_max;
	/* Minimum value for num_cmpl_aggr_int */
	uint16_t	num_cmpl_aggr_int_min;
	/* Maximum value for num_cmpl_aggr_int */
	uint16_t	num_cmpl_aggr_int_max;
	/* The units for timer parameters, in nanoseconds. */
	uint16_t	timer_units;
	uint8_t	unused_0[1];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************************
 * hwrm_ring_cmpl_ring_qaggint_params *
 **************************************/


/* hwrm_ring_cmpl_ring_qaggint_params_input (size:192b/24B) */
struct hwrm_ring_cmpl_ring_qaggint_params_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Physical number of completion ring. */
	uint16_t	ring_id;
	uint16_t	flags;
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS_INPUT_FLAGS_UNUSED_0_MASK \
		UINT32_C(0x3)
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS_INPUT_FLAGS_UNUSED_0_SFT 0
	/*
	 * Set this flag to 1 when querying parameters on a notification
	 * queue. Set this flag to 0 when querying parameters on a
	 * completion queue or completion ring.
	 */
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS_INPUT_FLAGS_IS_NQ \
		UINT32_C(0x4)
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_ring_cmpl_ring_qaggint_params_output (size:256b/32B) */
struct hwrm_ring_cmpl_ring_qaggint_params_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint16_t	flags;
	/*
	 * When this bit is set to '1', interrupt max
	 * timer is reset whenever a completion is received.
	 */
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS_OUTPUT_FLAGS_TIMER_RESET \
		UINT32_C(0x1)
	/*
	 * When this bit is set to '1', ring idle mode
	 * aggregation will be enabled.
	 */
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS_OUTPUT_FLAGS_RING_IDLE \
		UINT32_C(0x2)
	/*
	 * Number of completions to aggregate before DMA
	 * during the normal mode.
	 */
	uint16_t	num_cmpl_dma_aggr;
	/*
	 * Number of completions to aggregate before DMA
	 * during the interrupt mode.
	 */
	uint16_t	num_cmpl_dma_aggr_during_int;
	/*
	 * Timer used to aggregate completions before
	 * DMA during the normal mode (not in interrupt mode).
	 */
	uint16_t	cmpl_aggr_dma_tmr;
	/*
	 * Timer used to aggregate completions before
	 * DMA when in interrupt mode.
	 */
	uint16_t	cmpl_aggr_dma_tmr_during_int;
	/* Minimum time between two interrupts. */
	uint16_t	int_lat_tmr_min;
	/*
	 * Maximum wait time spent aggregating
	 * completions before signaling the interrupt after the
	 * interrupt is enabled.
	 */
	uint16_t	int_lat_tmr_max;
	/*
	 * Minimum number of completions aggregated before signaling
	 * an interrupt.
	 */
	uint16_t	num_cmpl_aggr_int;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************************************
 * hwrm_ring_cmpl_ring_cfg_aggint_params *
 *****************************************/


/* hwrm_ring_cmpl_ring_cfg_aggint_params_input (size:320b/40B) */
struct hwrm_ring_cmpl_ring_cfg_aggint_params_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Physical number of completion ring. */
	uint16_t	ring_id;
	uint16_t	flags;
	/*
	 * When this bit is set to '1', interrupt latency max
	 * timer is reset whenever a completion is received.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_FLAGS_TIMER_RESET \
		UINT32_C(0x1)
	/*
	 * When this bit is set to '1', ring idle mode
	 * aggregation will be enabled.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_FLAGS_RING_IDLE \
		UINT32_C(0x2)
	/*
	 * Set this flag to 1 when configuring parameters on a
	 * notification queue. Set this flag to 0 when configuring
	 * parameters on a completion queue or completion ring.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_FLAGS_IS_NQ \
		UINT32_C(0x4)
	/*
	 * Number of completions to aggregate before DMA
	 * during the normal mode.
	 */
	uint16_t	num_cmpl_dma_aggr;
	/*
	 * Number of completions to aggregate before DMA
	 * during the interrupt mode.
	 */
	uint16_t	num_cmpl_dma_aggr_during_int;
	/*
	 * Timer used to aggregate completions before
	 * DMA during the normal mode (not in interrupt mode).
	 */
	uint16_t	cmpl_aggr_dma_tmr;
	/*
	 * Timer used to aggregate completions before
	 * DMA while in interrupt mode.
	 */
	uint16_t	cmpl_aggr_dma_tmr_during_int;
	/* Minimum time between two interrupts. */
	uint16_t	int_lat_tmr_min;
	/*
	 * Maximum wait time spent aggregating
	 * completions before signaling the interrupt after the
	 * interrupt is enabled.
	 */
	uint16_t	int_lat_tmr_max;
	/*
	 * Minimum number of completions aggregated before signaling
	 * an interrupt.
	 */
	uint16_t	num_cmpl_aggr_int;
	/*
	 * Bitfield that indicates which parameters are to be applied. Only
	 * required when configuring devices with notification queues, and
	 * used in that case to set certain parameters on completion queues
	 * and others on notification queues.
	 */
	uint16_t	enables;
	/*
	 * This bit must be '1' for the num_cmpl_dma_aggr field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_NUM_CMPL_DMA_AGGR \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the num_cmpl_dma_aggr_during_int field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_NUM_CMPL_DMA_AGGR_DURING_INT \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the cmpl_aggr_dma_tmr field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_CMPL_AGGR_DMA_TMR \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the int_lat_tmr_min field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_INT_LAT_TMR_MIN \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the int_lat_tmr_max field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_INT_LAT_TMR_MAX \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the num_cmpl_aggr_int field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_NUM_CMPL_AGGR_INT \
		UINT32_C(0x20)
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_ring_cmpl_ring_cfg_aggint_params_output (size:128b/16B) */
struct hwrm_ring_cmpl_ring_cfg_aggint_params_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_ring_grp_alloc *
 ***********************/


/* hwrm_ring_grp_alloc_input (size:192b/24B) */
struct hwrm_ring_grp_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value identifies the CR associated with the ring
	 * group.
	 */
	uint16_t	cr;
	/*
	 * This value identifies the main RR associated with the ring
	 * group.
	 */
	uint16_t	rr;
	/*
	 * This value identifies the aggregation RR associated with
	 * the ring group.  If this value is 0xFF... (All Fs), then no
	 * Aggregation ring will be set.
	 */
	uint16_t	ar;
	/*
	 * This value identifies the statistics context associated
	 * with the ring group.
	 */
	uint16_t	sc;
} __rte_packed;

/* hwrm_ring_grp_alloc_output (size:128b/16B) */
struct hwrm_ring_grp_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is the ring group ID value.  Use this value to program
	 * the default ring group for the VNIC or as table entries
	 * in an RSS/COS context.
	 */
	uint32_t	ring_group_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_ring_grp_free *
 **********************/


/* hwrm_ring_grp_free_input (size:192b/24B) */
struct hwrm_ring_grp_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This is the ring group ID value. */
	uint32_t	ring_group_id;
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_ring_grp_free_output (size:128b/16B) */
struct hwrm_ring_grp_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_ring_schq_alloc *
 ************************/


/* hwrm_ring_schq_alloc_input (size:1088b/136B) */
struct hwrm_ring_schq_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the tqm_ring0 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING0     UINT32_C(0x1)
	/*
	 * This bit must be '1' for the tqm_ring1 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING1     UINT32_C(0x2)
	/*
	 * This bit must be '1' for the tqm_ring2 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING2     UINT32_C(0x4)
	/*
	 * This bit must be '1' for the tqm_ring3 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING3     UINT32_C(0x8)
	/*
	 * This bit must be '1' for the tqm_ring4 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING4     UINT32_C(0x10)
	/*
	 * This bit must be '1' for the tqm_ring5 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING5     UINT32_C(0x20)
	/*
	 * This bit must be '1' for the tqm_ring6 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING6     UINT32_C(0x40)
	/*
	 * This bit must be '1' for the tqm_ring7 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING7     UINT32_C(0x80)
	/* Reserved for future use. */
	uint32_t	reserved;
	/* TQM ring 0 page size and level. */
	uint8_t	tqm_ring0_pg_size_tqm_ring0_lvl;
	/* TQM ring 0 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_LAST \
		HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_LVL_2
	/* TQM ring 0 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_LAST \
		HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_1G
	/* TQM ring 1 page size and level. */
	uint8_t	tqm_ring1_pg_size_tqm_ring1_lvl;
	/* TQM ring 1 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_LAST \
		HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_LVL_2
	/* TQM ring 1 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_LAST \
		HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_1G
	/* TQM ring 2 page size and level. */
	uint8_t	tqm_ring2_pg_size_tqm_ring2_lvl;
	/* TQM ring 2 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_LAST \
		HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_LVL_2
	/* TQM ring 2 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_LAST \
		HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_1G
	/* TQM ring 3 page size and level. */
	uint8_t	tqm_ring3_pg_size_tqm_ring3_lvl;
	/* TQM ring 3 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_LAST \
		HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_LVL_2
	/* TQM ring 3 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_LAST \
		HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_1G
	/* TQM ring 4 page size and level. */
	uint8_t	tqm_ring4_pg_size_tqm_ring4_lvl;
	/* TQM ring 4 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_LAST \
		HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_LVL_2
	/* TQM ring 4 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_LAST \
		HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_1G
	/* TQM ring 5 page size and level. */
	uint8_t	tqm_ring5_pg_size_tqm_ring5_lvl;
	/* TQM ring 5 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_LAST \
		HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_LVL_2
	/* TQM ring 5 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_LAST \
		HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_1G
	/* TQM ring 6 page size and level. */
	uint8_t	tqm_ring6_pg_size_tqm_ring6_lvl;
	/* TQM ring 6 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_LAST \
		HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_LVL_2
	/* TQM ring 6 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_LAST \
		HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_1G
	/* TQM ring 7 page size and level. */
	uint8_t	tqm_ring7_pg_size_tqm_ring7_lvl;
	/* TQM ring 7 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_MASK \
		UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_SFT       0
	/* PBL pointer is physical start address. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_LVL_0 \
		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_LVL_1 \
		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_LVL_2 \
		UINT32_C(0x2)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_LAST \
		HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_LVL_2
	/* TQM ring 7 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_MASK \
		UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_SFT   4
	/* 4KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_4K \
		(UINT32_C(0x0) << 4)
	/* 8KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_8K \
		(UINT32_C(0x1) << 4)
	/* 64KB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_64K \
		(UINT32_C(0x2) << 4)
	/* 2MB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_2M \
		(UINT32_C(0x3) << 4)
	/* 8MB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_8M \
		(UINT32_C(0x4) << 4)
	/* 1GB. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_1G \
		(UINT32_C(0x5) << 4)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_LAST \
		HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_1G
	/* TQM ring 0 page directory. */
	uint64_t	tqm_ring0_page_dir;
	/* TQM ring 1 page directory. */
	uint64_t	tqm_ring1_page_dir;
	/* TQM ring 2 page directory. */
	uint64_t	tqm_ring2_page_dir;
	/* TQM ring 3 page directory. */
	uint64_t	tqm_ring3_page_dir;
	/* TQM ring 4 page directory. */
	uint64_t	tqm_ring4_page_dir;
	/* TQM ring 5 page directory. */
	uint64_t	tqm_ring5_page_dir;
	/* TQM ring 6 page directory. */
	uint64_t	tqm_ring6_page_dir;
	/* TQM ring 7 page directory. */
	uint64_t	tqm_ring7_page_dir;
	/*
	 * Number of TQM ring 0 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring0_num_entries;
	/*
	 * Number of TQM ring 1 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring1_num_entries;
	/*
	 * Number of TQM ring 2 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring2_num_entries;
	/*
	 * Number of TQM ring 3 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring3_num_entries;
	/*
	 * Number of TQM ring 4 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring4_num_entries;
	/*
	 * Number of TQM ring 5 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring5_num_entries;
	/*
	 * Number of TQM ring 6 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring6_num_entries;
	/*
	 * Number of TQM ring 7 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring7_num_entries;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	tqm_entry_size;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_ring_schq_alloc_output (size:128b/16B) */
struct hwrm_ring_schq_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is an identifier for the SCHQ to be used in other HWRM commands
	 * that need to reference this SCHQ. This value is greater than zero
	 * (i.e. a schq_id of zero references the default SCHQ).
	 */
	uint16_t	schq_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_ring_schq_cfg *
 **********************/


/* hwrm_ring_schq_cfg_input (size:768b/96B) */
struct hwrm_ring_schq_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Identifies the SCHQ being configured. A schq_id of zero refers to
	 * the default SCHQ.
	 */
	uint16_t	schq_id;
	/*
	 * This field is an 8 bit bitmap that indicates which TCs are enabled
	 * in this SCHQ. Bit 0 represents traffic class 0 and bit 7 represents
	 * traffic class 7.
	 */
	uint8_t	tc_enabled;
	uint8_t	unused_0;
	uint32_t	flags;
	/* The tc_max_bw array and the max_bw parameters are valid */
	#define HWRM_RING_SCHQ_CFG_INPUT_FLAGS_TC_MAX_BW_ENABLED \
		UINT32_C(0x1)
	/* The tc_min_bw array is valid */
	#define HWRM_RING_SCHQ_CFG_INPUT_FLAGS_TC_MIN_BW_ENABLED \
		UINT32_C(0x2)
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc0;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc1;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc2;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc3;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc4;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc5;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc6;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc7;
	/*
	 * Bandwidth reservation for the traffic class, specified in Mbps.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	min_bw_tc0;
	/*
	 * Bandwidth reservation for the traffic class, specified in Mbps.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	min_bw_tc1;
	/*
	 * Bandwidth reservation for the traffic class, specified in Mbps.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	min_bw_tc2;
	/*
	 * Bandwidth reservation for the traffic class, specified in Mbps.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	min_bw_tc3;
	/*
	 * Bandwidth reservation for the traffic class, specified in Mbps.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	min_bw_tc4;
	/*
	 * Bandwidth reservation for the traffic class, specified in Mbps.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	min_bw_tc5;
	/*
	 * Bandwidth reservation for the traffic class, specified in Mbps.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	min_bw_tc6;
	/*
	 * Bandwidth reservation for the traffic class, specified in Mbps.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	min_bw_tc7;
	/*
	 * Indicates the max bandwidth for all enabled traffic classes in
	 * this SCHQ, specified in Mbps.
	 */
	uint32_t	max_bw;
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_ring_schq_cfg_output (size:128b/16B) */
struct hwrm_ring_schq_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_ring_schq_free *
 ***********************/


/* hwrm_ring_schq_free_input (size:192b/24B) */
struct hwrm_ring_schq_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Identifies the SCHQ being freed. */
	uint16_t	schq_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_ring_schq_free_output (size:128b/16B) */
struct hwrm_ring_schq_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;
/*
 * special reserved flow ID to identify per function default
 * flows for vSwitch offload
 */
#define DEFAULT_FLOW_ID 0xFFFFFFFFUL
/*
 * special reserved flow ID to identify per function RoCEv1
 * flows
 */
#define ROCEV1_FLOW_ID 0xFFFFFFFEUL
/*
 * special reserved flow ID to identify per function RoCEv2
 * flows
 */
#define ROCEV2_FLOW_ID 0xFFFFFFFDUL
/*
 * special reserved flow ID to identify per function RoCEv2
 * CNP flows
 */
#define ROCEV2_CNP_FLOW_ID 0xFFFFFFFCUL

/****************************
 * hwrm_cfa_l2_filter_alloc *
 ****************************/


/* hwrm_cfa_l2_filter_alloc_input (size:768b/96B) */
struct hwrm_cfa_l2_filter_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH \
		UINT32_C(0x1)
	/* tx path */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH_TX \
		UINT32_C(0x0)
	/* rx path */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH_RX \
		UINT32_C(0x1)
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH_LAST \
		HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH_RX
	/*
	 * Setting of this flag indicates the applicability to the loopback
	 * path.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_LOOPBACK \
		UINT32_C(0x2)
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_DROP \
		UINT32_C(0x4)
	/*
	 * If this flag is set, all t_l2_* fields are invalid
	 * and they should not be specified.
	 * If this flag is set, then l2_* fields refer to
	 * fields of outermost L2 header.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_OUTERMOST \
		UINT32_C(0x8)
	/*
	 * Enumeration denoting NO_ROCE_L2 to support old drivers.
	 * New driver L2 for only L2 traffic, ROCE for roce and l2 traffic
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_MASK \
		UINT32_C(0x30)
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_SFT       4
	/* To support old drivers */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_NO_ROCE_L2 \
		(UINT32_C(0x0) << 4)
	/* Only L2 traffic */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_L2 \
		(UINT32_C(0x1) << 4)
	/* Roce & L2 traffic */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_ROCE \
		(UINT32_C(0x2) << 4)
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_LAST \
		HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_ROCE
	/*
	 * Setting of this flag indicates that no XDP filter is created with
	 * L2 filter.
	 * 0 - legacy behavior, XDP filter is created with L2 filter
	 * 1 - XDP filter won't be created with L2 filter
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_XDP_DISABLE \
		UINT32_C(0x40)
	/*
	 * Setting this flag to 1 indicate the L2 fields in this command
	 * pertain to source fields. Setting this flag to 0 indicate the
	 * L2 fields in this command pertain to the destination fields
	 * and this is the default/legacy behavior.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_SOURCE_VALID \
		UINT32_C(0x80)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the l2_addr field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_ADDR \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the l2_addr_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_ADDR_MASK \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the l2_ovlan field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_OVLAN \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the l2_ovlan_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_OVLAN_MASK \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the l2_ivlan field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_IVLAN \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the l2_ivlan_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_IVLAN_MASK \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the t_l2_addr field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_ADDR \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the t_l2_addr_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_ADDR_MASK \
		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the t_l2_ovlan field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_OVLAN \
		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the t_l2_ovlan_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_OVLAN_MASK \
		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the t_l2_ivlan field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_IVLAN \
		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the t_l2_ivlan_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_IVLAN_MASK \
		UINT32_C(0x800)
	/*
	 * This bit must be '1' for the src_type field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_SRC_TYPE \
		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the src_id field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_SRC_ID \
		UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the tunnel_type field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_TYPE \
		UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_DST_ID \
		UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID \
		UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the num_vlans field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_NUM_VLANS \
		UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the t_num_vlans field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_NUM_VLANS \
		UINT32_C(0x40000)
	/*
	 * This value sets the match value for the L2 MAC address.
	 * Destination MAC address for RX path.
	 * Source MAC address for TX path.
	 */
	uint8_t	l2_addr[6];
	/* This value sets the match value for the number of VLANs. */
	uint8_t	num_vlans;
	/*
	 * This value sets the match value for the number of VLANs
	 * in the tunnel headers.
	 */
	uint8_t	t_num_vlans;
	/*
	 * This value sets the mask value for the L2 address.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint8_t	l2_addr_mask[6];
	/* This value sets VLAN ID value for outer VLAN. */
	uint16_t	l2_ovlan;
	/*
	 * This value sets the mask value for the ovlan id.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint16_t	l2_ovlan_mask;
	/* This value sets VLAN ID value for inner VLAN. */
	uint16_t	l2_ivlan;
	/*
	 * This value sets the mask value for the ivlan id.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint16_t	l2_ivlan_mask;
	uint8_t	unused_1[2];
	/*
	 * This value sets the match value for the tunnel
	 * L2 MAC address.
	 * Destination MAC address for RX path.
	 * Source MAC address for TX path.
	 */
	uint8_t	t_l2_addr[6];
	uint8_t	unused_2[2];
	/*
	 * This value sets the mask value for the tunnel L2
	 * address.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint8_t	t_l2_addr_mask[6];
	/* This value sets VLAN ID value for tunnel outer VLAN. */
	uint16_t	t_l2_ovlan;
	/*
	 * This value sets the mask value for the tunnel ovlan id.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint16_t	t_l2_ovlan_mask;
	/* This value sets VLAN ID value for tunnel inner VLAN. */
	uint16_t	t_l2_ivlan;
	/*
	 * This value sets the mask value for the tunnel ivlan id.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint16_t	t_l2_ivlan_mask;
	/* This value identifies the type of source of the packet. */
	uint8_t	src_type;
	/* Network port */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_NPORT UINT32_C(0x0)
	/* Physical function */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_PF    UINT32_C(0x1)
	/* Virtual function */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_VF    UINT32_C(0x2)
	/* Virtual NIC of a function */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_VNIC  UINT32_C(0x3)
	/* Embedded processor for CFA management */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_KONG  UINT32_C(0x4)
	/* Embedded processor for OOB management */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_APE   UINT32_C(0x5)
	/* Embedded processor for RoCE */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_BONO  UINT32_C(0x6)
	/* Embedded processor for network proxy functions */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_TANG  UINT32_C(0x7)
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_LAST \
		HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_TANG
	uint8_t	unused_3;
	/*
	 * This value is the id of the source.
	 * For a network port, it represents port_id.
	 * For a physical function, it represents fid.
	 * For a virtual function, it represents vf_id.
	 * For a vnic, it represents vnic_id.
	 * For embedded processors, this id is not valid.
	 *
	 * Notes:
	 * 1. The function ID is implied if it src_id is
	 *    not provided for a src_type that is either
	 */
	uint32_t	src_id;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL \
		UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN \
		UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NVGRE \
		UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2GRE \
		UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPIP \
		UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_GENEVE \
		UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_MPLS \
		UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_STT \
		UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE \
		UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4 \
		UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1 \
		UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE \
		UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 \
		UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE \
		UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL \
		UINT32_C(0xff)
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_LAST \
		HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused_4;
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and network port id of the destination port for
	 * the TX path.
	 */
	uint16_t	dst_id;
	/*
	 * Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint16_t	mirror_vnic_id;
	/*
	 * This hint is provided to help in placing
	 * the filter in the filter table.
	 */
	uint8_t	pri_hint;
	/* No preference */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_NO_PREFER \
		UINT32_C(0x0)
	/* Above the given filter */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_ABOVE_FILTER \
		UINT32_C(0x1)
	/* Below the given filter */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_BELOW_FILTER \
		UINT32_C(0x2)
	/* As high as possible */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_MAX \
		UINT32_C(0x3)
	/* As low as possible */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_MIN \
		UINT32_C(0x4)
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_LAST \
		HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_MIN
	uint8_t	unused_5;
	uint32_t	unused_6;
	/*
	 * This is the ID of the filter that goes along with
	 * the pri_hint.
	 *
	 * This field is valid only for the following values.
	 * 1 - Above the given filter
	 * 2 - Below the given filter
	 */
	uint64_t	l2_filter_id_hint;
} __rte_packed;

/* hwrm_cfa_l2_filter_alloc_output (size:192b/24B) */
struct hwrm_cfa_l2_filter_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK \
		UINT32_C(0x3fffffff)
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE \
		UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_INT \
		(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT \
		(UINT32_C(0x1) << 30)
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST \
		HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR \
		UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_RX \
		(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX \
		(UINT32_C(0x1) << 31)
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_LAST \
		HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_cfa_l2_filter_free *
 ***************************/


/* hwrm_cfa_l2_filter_free_input (size:192b/24B) */
struct hwrm_cfa_l2_filter_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
} __rte_packed;

/* hwrm_cfa_l2_filter_free_output (size:128b/16B) */
struct hwrm_cfa_l2_filter_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_cfa_l2_filter_cfg *
 **************************/


/* hwrm_cfa_l2_filter_cfg_input (size:320b/40B) */
struct hwrm_cfa_l2_filter_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH \
		UINT32_C(0x1)
	/* tx path */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH_TX \
		UINT32_C(0x0)
	/* rx path */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH_RX \
		UINT32_C(0x1)
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH_LAST \
		HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH_RX
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_DROP \
		UINT32_C(0x2)
	/*
	 * Enumeration denoting NO_ROCE_L2 to support old drivers.
	 * New driver L2 for only L2 traffic, ROCE for roce and l2 traffic
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_MASK \
		UINT32_C(0xc)
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_SFT       2
	/* To support old drivers */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_NO_ROCE_L2 \
		(UINT32_C(0x0) << 2)
	/* Only L2 traffic */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_L2 \
		(UINT32_C(0x1) << 2)
	/* Roce & L2 traffic */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_ROCE \
		(UINT32_C(0x2) << 2)
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_LAST \
		HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_ROCE
	uint32_t	enables;
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_ENABLES_DST_ID \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the new_mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_ENABLES_NEW_MIRROR_VNIC_ID \
		UINT32_C(0x2)
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and network port id of the destination port for
	 * the TX path.
	 */
	uint32_t	dst_id;
	/*
	 * New Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint32_t	new_mirror_vnic_id;
} __rte_packed;

/* hwrm_cfa_l2_filter_cfg_output (size:128b/16B) */
struct hwrm_cfa_l2_filter_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_cfa_l2_set_rx_mask *
 ***************************/


/* hwrm_cfa_l2_set_rx_mask_input (size:448b/56B) */
struct hwrm_cfa_l2_set_rx_mask_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* VNIC ID */
	uint32_t	vnic_id;
	uint32_t	mask;
	/*
	 * When this bit is '1', the function is requested to accept
	 * multi-cast packets specified by the multicast addr table.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_MCAST \
		UINT32_C(0x2)
	/*
	 * When this bit is '1', the function is requested to accept
	 * all multi-cast packets.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_ALL_MCAST \
		UINT32_C(0x4)
	/*
	 * When this bit is '1', the function is requested to accept
	 * broadcast packets.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_BCAST \
		UINT32_C(0x8)
	/*
	 * When this bit is '1', the function is requested to be
	 * put in the promiscuous mode.
	 *
	 * The HWRM should accept any function to set up
	 * promiscuous mode.
	 *
	 * The HWRM shall follow the semantics below for the
	 * promiscuous mode support.
	 * # When partitioning is not enabled on a port
	 * (i.e. single PF on the port), then the PF shall
	 * be allowed to be in the promiscuous mode. When the
	 * PF is in the promiscuous mode, then it shall
	 * receive all host bound traffic on that port.
	 * # When partitioning is enabled on a port
	 * (i.e. multiple PFs per port) and a PF on that
	 * port is in the promiscuous mode, then the PF
	 * receives all traffic within that partition as
	 * identified by a unique identifier for the
	 * PF (e.g. S-Tag). If a unique outer VLAN
	 * for the PF is specified, then the setting of
	 * promiscuous mode on that PF shall result in the
	 * PF receiving all host bound traffic with matching
	 * outer VLAN.
	 * # A VF shall can be set in the promiscuous mode.
	 * In the promiscuous mode, the VF does not receive any
	 * traffic unless a unique outer VLAN for the
	 * VF is specified. If a unique outer VLAN
	 * for the VF is specified, then the setting of
	 * promiscuous mode on that VF shall result in the
	 * VF receiving all host bound traffic with the
	 * matching outer VLAN.
	 * # The HWRM shall allow the setting of promiscuous
	 * mode on a function independently from the
	 * promiscuous mode settings on other functions.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_PROMISCUOUS \
		UINT32_C(0x10)
	/*
	 * If this flag is set, the corresponding RX
	 * filters shall be set up to cover multicast/broadcast
	 * filters for the outermost Layer 2 destination MAC
	 * address field.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_OUTERMOST \
		UINT32_C(0x20)
	/*
	 * If this flag is set, the corresponding RX
	 * filters shall be set up to cover multicast/broadcast
	 * filters for the VLAN-tagged packets that match the
	 * TPID and VID fields of VLAN tags in the VLAN tag
	 * table specified in this command.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_VLANONLY \
		UINT32_C(0x40)
	/*
	 * If this flag is set, the corresponding RX
	 * filters shall be set up to cover multicast/broadcast
	 * filters for non-VLAN tagged packets and VLAN-tagged
	 * packets that match the TPID and VID fields of VLAN
	 * tags in the VLAN tag table specified in this command.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_VLAN_NONVLAN \
		UINT32_C(0x80)
	/*
	 * If this flag is set, the corresponding RX
	 * filters shall be set up to cover multicast/broadcast
	 * filters for non-VLAN tagged packets and VLAN-tagged
	 * packets matching any VLAN tag.
	 *
	 * If this flag is set, then the HWRM shall ignore
	 * VLAN tags specified in vlan_tag_tbl.
	 *
	 * If none of vlanonly, vlan_nonvlan, and anyvlan_nonvlan
	 * flags is set, then the HWRM shall ignore
	 * VLAN tags specified in vlan_tag_tbl.
	 *
	 * The HWRM client shall set at most one flag out of
	 * vlanonly, vlan_nonvlan, and anyvlan_nonvlan.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_ANYVLAN_NONVLAN \
		UINT32_C(0x100)
	/* This is the address for mcast address tbl. */
	uint64_t	mc_tbl_addr;
	/*
	 * This value indicates how many entries in mc_tbl are valid.
	 * Each entry is 6 bytes.
	 */
	uint32_t	num_mc_entries;
	uint8_t	unused_0[4];
	/*
	 * This is the address for VLAN tag table.
	 * Each VLAN entry in the table is 4 bytes of a VLAN tag
	 * including TPID, PCP, DEI, and VID fields in network byte
	 * order.
	 */
	uint64_t	vlan_tag_tbl_addr;
	/*
	 * This value indicates how many entries in vlan_tag_tbl are
	 * valid. Each entry is 4 bytes.
	 */
	uint32_t	num_vlan_tags;
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_cfa_l2_set_rx_mask_output (size:128b/16B) */
struct hwrm_cfa_l2_set_rx_mask_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* hwrm_cfa_l2_set_rx_mask_cmd_err (size:64b/8B) */
struct hwrm_cfa_l2_set_rx_mask_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_CFA_L2_SET_RX_MASK_CMD_ERR_CODE_UNKNOWN \
		UINT32_C(0x0)
	/* Unable to complete operation due to conflict with Ntuple Filter */
	#define HWRM_CFA_L2_SET_RX_MASK_CMD_ERR_CODE_NTUPLE_FILTER_CONFLICT_ERR \
		UINT32_C(0x1)
	#define HWRM_CFA_L2_SET_RX_MASK_CMD_ERR_CODE_LAST \
		HWRM_CFA_L2_SET_RX_MASK_CMD_ERR_CODE_NTUPLE_FILTER_CONFLICT_ERR
	uint8_t	unused_0[7];
} __rte_packed;

/*******************************
 * hwrm_cfa_vlan_antispoof_cfg *
 *******************************/


/* hwrm_cfa_vlan_antispoof_cfg_input (size:256b/32B) */
struct hwrm_cfa_vlan_antispoof_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being configured.
	 * Only valid for a VF FID configured by the PF.
	 */
	uint16_t	fid;
	uint8_t	unused_0[2];
	/* Number of VLAN entries in the vlan_tag_mask_tbl. */
	uint32_t	num_vlan_entries;
	/*
	 * The vlan_tag_mask_tbl_addr is the DMA address of the VLAN
	 * antispoof table. Each table entry contains the 16-bit TPID
	 * (0x8100 or 0x88a8 only), 16-bit VLAN ID, and a 16-bit mask,
	 * all in network order to match hwrm_cfa_l2_set_rx_mask.
	 * For an individual VLAN entry, the mask value should be 0xfff
	 * for the 12-bit VLAN ID.
	 */
	uint64_t	vlan_tag_mask_tbl_addr;
} __rte_packed;

/* hwrm_cfa_vlan_antispoof_cfg_output (size:128b/16B) */
struct hwrm_cfa_vlan_antispoof_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/********************************
 * hwrm_cfa_vlan_antispoof_qcfg *
 ********************************/


/* hwrm_cfa_vlan_antispoof_qcfg_input (size:256b/32B) */
struct hwrm_cfa_vlan_antispoof_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * Only valid for a VF FID queried by the PF.
	 */
	uint16_t	fid;
	uint8_t	unused_0[2];
	/*
	 * Maximum number of VLAN entries the firmware is allowed to DMA
	 * to vlan_tag_mask_tbl.
	 */
	uint32_t	max_vlan_entries;
	/*
	 * The vlan_tag_mask_tbl_addr is the DMA address of the VLAN
	 * antispoof table to which firmware will DMA to. Each table
	 * entry will contain the 16-bit TPID (0x8100 or 0x88a8 only),
	 * 16-bit VLAN ID, and a 16-bit mask, all in network order to
	 * match hwrm_cfa_l2_set_rx_mask. For an individual VLAN entry,
	 * the mask value should be 0xfff for the 12-bit VLAN ID.
	 */
	uint64_t	vlan_tag_mask_tbl_addr;
} __rte_packed;

/* hwrm_cfa_vlan_antispoof_qcfg_output (size:128b/16B) */
struct hwrm_cfa_vlan_antispoof_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of valid entries DMAd by firmware to vlan_tag_mask_tbl. */
	uint32_t	num_vlan_entries;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/********************************
 * hwrm_cfa_tunnel_filter_alloc *
 ********************************/


/* hwrm_cfa_tunnel_filter_alloc_input (size:704b/88B) */
struct hwrm_cfa_tunnel_filter_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Setting of this flag indicates the applicability to the loopback
	 * path.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_FLAGS_LOOPBACK \
		UINT32_C(0x1)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the l2_filter_id field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L2_FILTER_ID \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the l2_addr field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L2_ADDR \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the l2_ivlan field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L2_IVLAN \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the l3_addr field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L3_ADDR \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the l3_addr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L3_ADDR_TYPE \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the t_l3_addr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_T_L3_ADDR_TYPE \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the t_l3_addr field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_T_L3_ADDR \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the tunnel_type field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_TYPE \
		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the vni field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_VNI \
		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the dst_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_DST_VNIC_ID \
		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID \
		UINT32_C(0x400)
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	/*
	 * This value sets the match value for the inner L2
	 * MAC address.
	 * Destination MAC address for RX path.
	 * Source MAC address for TX path.
	 */
	uint8_t	l2_addr[6];
	/*
	 * This value sets VLAN ID value for inner VLAN.
	 * Only 12-bits of VLAN ID are used in setting the filter.
	 */
	uint16_t	l2_ivlan;
	/*
	 * The value of inner destination IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	l3_addr[4];
	/*
	 * The value of tunnel destination IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	t_l3_addr[4];
	/*
	 * This value indicates the type of inner IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	l3_addr_type;
	/*
	 * This value indicates the type of tunnel IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	t_l3_addr_type;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL \
		UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN \
		UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NVGRE \
		UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2GRE \
		UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPIP \
		UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_GENEVE \
		UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_MPLS \
		UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_STT \
		UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE \
		UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4 \
		UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1 \
		UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE \
		UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 \
		UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE \
		UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL \
		UINT32_C(0xff)
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_LAST \
		HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	/*
	 * tunnel_flags allows the user to indicate the tunnel tag detection
	 * for the tunnel type specified in tunnel_type.
	 */
	uint8_t	tunnel_flags;
	/*
	 * If the tunnel_type is geneve, then this bit indicates if we
	 * need to match the geneve OAM packet.
	 * If the tunnel_type is nvgre or gre, then this bit indicates if
	 * we need to detect checksum present bit in geneve header.
	 * If the tunnel_type is mpls, then this bit indicates if we need
	 * to match mpls packet with explicit IPV4/IPV6 null header.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_FLAGS_TUN_FLAGS_OAM_CHECKSUM_EXPLHDR \
		UINT32_C(0x1)
	/*
	 * If the tunnel_type is geneve, then this bit indicates if we
	 * need to detect the critical option bit set in the oam packet.
	 * If the tunnel_type is nvgre or gre, then this bit indicates
	 * if we need to match nvgre packets with key present bit set in
	 * gre header.
	 * If the tunnel_type is mpls, then this bit indicates if we
	 * need to match mpls packet with S bit from inner/second label.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_FLAGS_TUN_FLAGS_CRITICAL_OPT_S1 \
		UINT32_C(0x2)
	/*
	 * If the tunnel_type is geneve, then this bit indicates if we
	 * need to match geneve packet with extended header bit set in
	 * geneve header.
	 * If the tunnel_type is nvgre or gre, then this bit indicates
	 * if we need to match nvgre packets with sequence number
	 * present bit set in gre header.
	 * If the tunnel_type is mpls, then this bit indicates if we
	 * need to match mpls packet with S bit from out/first label.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_FLAGS_TUN_FLAGS_EXTHDR_SEQNUM_S0 \
		UINT32_C(0x4)
	/*
	 * Virtual Network Identifier (VNI). Only valid with
	 * tunnel_types VXLAN, NVGRE, and Geneve.
	 * Only lower 24-bits of VNI field are used
	 * in setting up the filter.
	 */
	uint32_t	vni;
	/* Logical VNIC ID of the destination VNIC. */
	uint32_t	dst_vnic_id;
	/*
	 * Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint32_t	mirror_vnic_id;
} __rte_packed;

/* hwrm_cfa_tunnel_filter_alloc_output (size:192b/24B) */
struct hwrm_cfa_tunnel_filter_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	tunnel_filter_id;
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK \
		UINT32_C(0x3fffffff)
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE \
		UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_INT \
		(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT \
		(UINT32_C(0x1) << 30)
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST \
		HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR \
		UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_RX \
		(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX \
		(UINT32_C(0x1) << 31)
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_LAST \
		HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************************
 * hwrm_cfa_tunnel_filter_free *
 *******************************/


/* hwrm_cfa_tunnel_filter_free_input (size:192b/24B) */
struct hwrm_cfa_tunnel_filter_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	tunnel_filter_id;
} __rte_packed;

/* hwrm_cfa_tunnel_filter_free_output (size:128b/16B) */
struct hwrm_cfa_tunnel_filter_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************************
 * hwrm_cfa_redirect_tunnel_type_alloc *
 ***************************************/


/* hwrm_cfa_redirect_tunnel_type_alloc_input (size:192b/24B) */
struct hwrm_cfa_redirect_tunnel_type_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The destination function id, to whom the traffic is redirected. */
	uint16_t	dest_fid;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL \
		UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_VXLAN \
		UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_NVGRE \
		UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_L2GRE \
		UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_IPIP \
		UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_GENEVE \
		UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_MPLS \
		UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_STT \
		UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_IPGRE \
		UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4 \
		UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1 \
		UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE \
		UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 \
		UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE \
		UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL \
		UINT32_C(0xff)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_LAST \
		HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	/* Tunnel alloc flags. */
	uint8_t	flags;
	/*
	 * Setting of this flag indicates modify existing redirect tunnel
	 * to new destination function ID.
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_FLAGS_MODIFY_DST \
		UINT32_C(0x1)
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_cfa_redirect_tunnel_type_alloc_output (size:128b/16B) */
struct hwrm_cfa_redirect_tunnel_type_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************************
 * hwrm_cfa_redirect_tunnel_type_free *
 **************************************/


/* hwrm_cfa_redirect_tunnel_type_free_input (size:192b/24B) */
struct hwrm_cfa_redirect_tunnel_type_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The destination function id, to whom the traffic is redirected. */
	uint16_t	dest_fid;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_NONTUNNEL \
		UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_VXLAN \
		UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_NVGRE \
		UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_L2GRE \
		UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_IPIP \
		UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_GENEVE \
		UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_MPLS \
		UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_STT \
		UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_IPGRE \
		UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_VXLAN_V4 \
		UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_IPGRE_V1 \
		UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_L2_ETYPE \
		UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 \
		UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_VXLAN_GPE \
		UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_ANYTUNNEL \
		UINT32_C(0xff)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_LAST \
		HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused_0[5];
} __rte_packed;

/* hwrm_cfa_redirect_tunnel_type_free_output (size:128b/16B) */
struct hwrm_cfa_redirect_tunnel_type_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************************
 * hwrm_cfa_redirect_tunnel_type_info *
 **************************************/


/* hwrm_cfa_redirect_tunnel_type_info_input (size:192b/24B) */
struct hwrm_cfa_redirect_tunnel_type_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The source function id. */
	uint16_t	src_fid;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_NONTUNNEL \
		UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_VXLAN \
		UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_NVGRE \
		UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_L2GRE \
		UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_IPIP \
		UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_GENEVE \
		UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_MPLS \
		UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_STT \
		UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_IPGRE \
		UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_VXLAN_V4 \
		UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_IPGRE_V1 \
		UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_L2_ETYPE \
		UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 \
		UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_VXLAN_GPE \
		UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_ANYTUNNEL \
		UINT32_C(0xff)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_LAST \
		HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused_0[5];
} __rte_packed;

/* hwrm_cfa_redirect_tunnel_type_info_output (size:128b/16B) */
struct hwrm_cfa_redirect_tunnel_type_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The destination function id, to whom the traffic is redirected. */
	uint16_t	dest_fid;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* hwrm_vxlan_ipv4_hdr (size:128b/16B) */
struct hwrm_vxlan_ipv4_hdr {
	/* IPv4 version and header length. */
	uint8_t	ver_hlen;
	/* IPv4 header length */
	#define HWRM_VXLAN_IPV4_HDR_VER_HLEN_HEADER_LENGTH_MASK UINT32_C(0xf)
	#define HWRM_VXLAN_IPV4_HDR_VER_HLEN_HEADER_LENGTH_SFT 0
	/* Version */
	#define HWRM_VXLAN_IPV4_HDR_VER_HLEN_VERSION_MASK      UINT32_C(0xf0)
	#define HWRM_VXLAN_IPV4_HDR_VER_HLEN_VERSION_SFT       4
	/* IPv4 type of service. */
	uint8_t	tos;
	/* IPv4 identification. */
	uint16_t	ip_id;
	/* IPv4 flags and offset. */
	uint16_t	flags_frag_offset;
	/* IPv4 TTL. */
	uint8_t	ttl;
	/* IPv4 protocol. */
	uint8_t	protocol;
	/* IPv4 source address. */
	uint32_t	src_ip_addr;
	/* IPv4 destination address. */
	uint32_t	dest_ip_addr;
} __rte_packed;

/* hwrm_vxlan_ipv6_hdr (size:320b/40B) */
struct hwrm_vxlan_ipv6_hdr {
	/* IPv6 version, traffic class and flow label. */
	uint32_t	ver_tc_flow_label;
	/* IPv6 version shift */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_VER_SFT \
		UINT32_C(0x1c)
	/* IPv6 version mask */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_VER_MASK \
		UINT32_C(0xf0000000)
	/* IPv6 TC shift */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_TC_SFT \
		UINT32_C(0x14)
	/* IPv6 TC mask */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_TC_MASK \
		UINT32_C(0xff00000)
	/* IPv6 flow label shift */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_FLOW_LABEL_SFT \
		UINT32_C(0x0)
	/* IPv6 flow label mask */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_FLOW_LABEL_MASK \
		UINT32_C(0xfffff)
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_LAST \
		HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_FLOW_LABEL_MASK
	/* IPv6 payload length. */
	uint16_t	payload_len;
	/* IPv6 next header. */
	uint8_t	next_hdr;
	/* IPv6 TTL. */
	uint8_t	ttl;
	/* IPv6 source address. */
	uint32_t	src_ip_addr[4];
	/* IPv6 destination address. */
	uint32_t	dest_ip_addr[4];
} __rte_packed;

/* hwrm_cfa_encap_data_vxlan (size:640b/80B) */
struct hwrm_cfa_encap_data_vxlan {
	/* Source MAC address. */
	uint8_t	src_mac_addr[6];
	/* reserved. */
	uint16_t	unused_0;
	/* Destination MAC address. */
	uint8_t	dst_mac_addr[6];
	/* Number of VLAN tags. */
	uint8_t	num_vlan_tags;
	/* reserved. */
	uint8_t	unused_1;
	/* Outer VLAN TPID. */
	uint16_t	ovlan_tpid;
	/* Outer VLAN TCI. */
	uint16_t	ovlan_tci;
	/* Inner VLAN TPID. */
	uint16_t	ivlan_tpid;
	/* Inner VLAN TCI. */
	uint16_t	ivlan_tci;
	/* L3 header fields. */
	uint32_t	l3[10];
	/* IP version mask. */
	#define HWRM_CFA_ENCAP_DATA_VXLAN_L3_VER_MASK UINT32_C(0xf)
	/* IP version 4. */
	#define HWRM_CFA_ENCAP_DATA_VXLAN_L3_VER_IPV4 UINT32_C(0x4)
	/* IP version 6. */
	#define HWRM_CFA_ENCAP_DATA_VXLAN_L3_VER_IPV6 UINT32_C(0x6)
	#define HWRM_CFA_ENCAP_DATA_VXLAN_L3_LAST \
		HWRM_CFA_ENCAP_DATA_VXLAN_L3_VER_IPV6
	/* UDP source port. */
	uint16_t	src_port;
	/* UDP destination port. */
	uint16_t	dst_port;
	/* VXLAN Network Identifier. */
	uint32_t	vni;
	/*
	 * 3 bytes VXLAN header reserve fields from 1st dword of the VXLAN
	 * header.
	 */
	uint8_t	hdr_rsvd0[3];
	/* 1 byte VXLAN header reserve field from 2nd dword of the VXLAN header. */
	uint8_t	hdr_rsvd1;
	/* VXLAN header flags field. */
	uint8_t	hdr_flags;
	uint8_t	unused[3];
} __rte_packed;

/*******************************
 * hwrm_cfa_encap_record_alloc *
 *******************************/


/* hwrm_cfa_encap_record_alloc_input (size:832b/104B) */
struct hwrm_cfa_encap_record_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Setting of this flag indicates the applicability to the loopback
	 * path.
	 */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_FLAGS_LOOPBACK \
		UINT32_C(0x1)
	/*
	 * Setting of this flag indicates this encap record is external
	 * encap record. Resetting of this flag indicates this flag is
	 * internal encap record and this is the default setting.
	 */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_FLAGS_EXTERNAL \
		UINT32_C(0x2)
	/* Encapsulation Type. */
	uint8_t	encap_type;
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VXLAN \
		UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_NVGRE \
		UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) after inside Ethernet payload */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_L2GRE \
		UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_IPIP \
		UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_GENEVE \
		UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_MPLS \
		UINT32_C(0x6)
	/* VLAN */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VLAN \
		UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_IPGRE \
		UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VXLAN_V4 \
		UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_IPGRE_V1 \
		UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_L2_ETYPE \
		UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VXLAN_GPE_V6 \
		UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VXLAN_GPE \
		UINT32_C(0x10)
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_LAST \
		HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VXLAN_GPE
	uint8_t	unused_0[3];
	/* This value is encap data used for the given encap type. */
	uint32_t	encap_data[20];
} __rte_packed;

/* hwrm_cfa_encap_record_alloc_output (size:128b/16B) */
struct hwrm_cfa_encap_record_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint32_t	encap_record_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************************
 * hwrm_cfa_encap_record_free *
 ******************************/


/* hwrm_cfa_encap_record_free_input (size:192b/24B) */
struct hwrm_cfa_encap_record_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint32_t	encap_record_id;
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_cfa_encap_record_free_output (size:128b/16B) */
struct hwrm_cfa_encap_record_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/********************************
 * hwrm_cfa_ntuple_filter_alloc *
 ********************************/


/* hwrm_cfa_ntuple_filter_alloc_input (size:1024b/128B) */
struct hwrm_cfa_ntuple_filter_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Setting of this flag indicates the applicability to the loopback
	 * path.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_LOOPBACK \
		UINT32_C(0x1)
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_DROP \
		UINT32_C(0x2)
	/*
	 * Setting of this flag indicates that a meter is expected to be
	 * attached to this flow. This hint can be used when choosing the
	 * action record format required for the flow.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_METER \
		UINT32_C(0x4)
	/*
	 * Setting of this flag indicates that the dst_id field contains
	 * function ID. If this is not set it indicates dest_id is VNIC
	 * or VPORT.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_DEST_FID \
		UINT32_C(0x8)
	/*
	 * Setting of this flag indicates match on arp reply when ethertype
	 * is 0x0806. If this is not set it indicates no specific arp opcode
	 * matching.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_ARP_REPLY \
		UINT32_C(0x10)
	/*
	 * Setting of this flag indicates that the dst_id field contains RFS
	 * ring table index. If this is not set it indicates dst_id is VNIC
	 * or VPORT or function ID.  Note dest_fid and dest_rfs_ring_idx
	 * cant be set at the same time.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_DEST_RFS_RING_IDX \
		UINT32_C(0x20)
	/*
	 * Setting of this flag indicates that when the ntuple filter is
	 * created, the L2 context should not be used in the filter.  This
	 * allows packet from different L2 contexts to match and be directed
	 * to the same destination.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_NO_L2_CONTEXT \
		UINT32_C(0x40)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the l2_filter_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_L2_FILTER_ID \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the ethertype field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_ETHERTYPE \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the tunnel_type field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_TYPE \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the src_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_MACADDR \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the ipaddr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_IPADDR_TYPE \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the src_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_IPADDR \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the src_ipaddr_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_IPADDR_MASK \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the dst_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_IPADDR \
		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the dst_ipaddr_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_IPADDR_MASK \
		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the ip_protocol field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_IP_PROTOCOL \
		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the src_port field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_PORT \
		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the src_port_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_PORT_MASK \
		UINT32_C(0x800)
	/*
	 * This bit must be '1' for the dst_port field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_PORT \
		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the dst_port_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_PORT_MASK \
		UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the pri_hint field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_PRI_HINT \
		UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the ntuple_filter_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_NTUPLE_FILTER_ID \
		UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_ID \
		UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID \
		UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the dst_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_MACADDR \
		UINT32_C(0x40000)
	/* This flag is deprecated. */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_RFS_RING_TBL_IDX \
		UINT32_C(0x80000)
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	/*
	 * This value indicates the source MAC address in
	 * the Ethernet header.
	 */
	uint8_t	src_macaddr[6];
	/* This value indicates the ethertype in the Ethernet header. */
	uint16_t	ethertype;
	/*
	 * This value indicates the type of IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	ip_addr_type;
	/* invalid */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_UNKNOWN \
		UINT32_C(0x0)
	/* IPv4 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV4 \
		UINT32_C(0x4)
	/* IPv6 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6 \
		UINT32_C(0x6)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_LAST \
		HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6
	/*
	 * The value of protocol filed in IP header.
	 * Applies to UDP and TCP traffic.
	 * 6 - TCP
	 * 17 - UDP
	 * 1 - ICMP
	 * 58 - ICMPV6
	 * 255 - RSVD
	 */
	uint8_t	ip_protocol;
	/* invalid */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_UNKNOWN \
		UINT32_C(0x0)
	/* TCP */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_TCP \
		UINT32_C(0x6)
	/* UDP */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_UDP \
		UINT32_C(0x11)
	/* ICMP */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_ICMP \
		UINT32_C(0x1)
	/* ICMPV6 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_ICMPV6 \
		UINT32_C(0x3a)
	/* RSVD */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_RSVD \
		UINT32_C(0xff)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_LAST \
		HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_RSVD
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and network port id of the destination port for
	 * the TX path.
	 */
	uint16_t	dst_id;
	/*
	 * Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint16_t	mirror_vnic_id;
	/*
	 * This value indicates the tunnel type for this filter.
	 * If this field is not specified, then the filter shall
	 * apply to both non-tunneled and tunneled packets.
	 * If this field conflicts with the tunnel_type specified
	 * in the l2_filter_id, then the HWRM shall return an
	 * error for this command.
	 */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL \
		UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN \
		UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NVGRE \
		UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2GRE \
		UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPIP \
		UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_GENEVE \
		UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_MPLS \
		UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_STT \
		UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE \
		UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4 \
		UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1 \
		UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE \
		UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 \
		UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE \
		UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL \
		UINT32_C(0xff)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_LAST \
		HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	/*
	 * This hint is provided to help in placing
	 * the filter in the filter table.
	 */
	uint8_t	pri_hint;
	/* No preference */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_NO_PREFER \
		UINT32_C(0x0)
	/* Above the given filter */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_ABOVE \
		UINT32_C(0x1)
	/* Below the given filter */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_BELOW \
		UINT32_C(0x2)
	/* As high as possible */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_HIGHEST \
		UINT32_C(0x3)
	/* As low as possible */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_LOWEST \
		UINT32_C(0x4)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_LAST \
		HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_LOWEST
	/*
	 * The value of source IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	src_ipaddr[4];
	/*
	 * The value of source IP address mask to be used in
	 * filtering.
	 * For IPv4, first four bytes represent the IP address mask.
	 */
	uint32_t	src_ipaddr_mask[4];
	/*
	 * The value of destination IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	dst_ipaddr[4];
	/*
	 * The value of destination IP address mask to be used in
	 * filtering.
	 * For IPv4, first four bytes represent the IP address mask.
	 */
	uint32_t	dst_ipaddr_mask[4];
	/*
	 * The value of source port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	src_port;
	/*
	 * The value of source port mask to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	src_port_mask;
	/*
	 * The value of destination port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	dst_port;
	/*
	 * The value of destination port mask to be used in
	 * filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	dst_port_mask;
	/*
	 * This is the ID of the filter that goes along with
	 * the pri_hint.
	 */
	uint64_t	ntuple_filter_id_hint;
} __rte_packed;

/* hwrm_cfa_ntuple_filter_alloc_output (size:192b/24B) */
struct hwrm_cfa_ntuple_filter_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	ntuple_filter_id;
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK \
		UINT32_C(0x3fffffff)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE \
		UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_INT \
		(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT \
		(UINT32_C(0x1) << 30)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST \
		HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR \
		UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_RX \
		(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX \
		(UINT32_C(0x1) << 31)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_LAST \
		HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* hwrm_cfa_ntuple_filter_alloc_cmd_err (size:64b/8B) */
struct hwrm_cfa_ntuple_filter_alloc_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_CMD_ERR_CODE_UNKNOWN \
		UINT32_C(0x0)
	/* Unable to complete operation due to conflict with Rx Mask VLAN */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_CMD_ERR_CODE_RX_MASK_VLAN_CONFLICT_ERR \
		UINT32_C(0x1)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_CMD_ERR_CODE_LAST \
		HWRM_CFA_NTUPLE_FILTER_ALLOC_CMD_ERR_CODE_RX_MASK_VLAN_CONFLICT_ERR
	uint8_t	unused_0[7];
} __rte_packed;

/*******************************
 * hwrm_cfa_ntuple_filter_free *
 *******************************/


/* hwrm_cfa_ntuple_filter_free_input (size:192b/24B) */
struct hwrm_cfa_ntuple_filter_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	ntuple_filter_id;
} __rte_packed;

/* hwrm_cfa_ntuple_filter_free_output (size:128b/16B) */
struct hwrm_cfa_ntuple_filter_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************************
 * hwrm_cfa_ntuple_filter_cfg *
 ******************************/


/* hwrm_cfa_ntuple_filter_cfg_input (size:384b/48B) */
struct hwrm_cfa_ntuple_filter_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the new_dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_ENABLES_NEW_DST_ID \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the new_mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_ENABLES_NEW_MIRROR_VNIC_ID \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the new_meter_instance_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_ENABLES_NEW_METER_INSTANCE_ID \
		UINT32_C(0x4)
	uint32_t	flags;
	/*
	 * Setting this bit to 1 indicates that dest_id field contains FID.
	 * Setting this to 0 indicates that dest_id field contains VNIC or
	 * VPORT.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_FLAGS_DEST_FID \
		UINT32_C(0x1)
	/*
	 * Setting of this flag indicates that the new_dst_id field contains
	 * RFS ring table index. If this is not set it indicates new_dst_id
	 * is VNIC or VPORT or function ID.  Note dest_fid and
	 * dest_rfs_ring_idx cant be set at the same time.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_FLAGS_DEST_RFS_RING_IDX \
		UINT32_C(0x2)
	/*
	 * Setting of this flag indicates that when the ntuple filter is
	 * created, the L2 context should not be used in the filter.  This
	 * allows packet from different L2 contexts to match and be directed
	 * to the same destination.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_FLAGS_NO_L2_CONTEXT \
		UINT32_C(0x4)
	/* This value is an opaque id into CFA data structures. */
	uint64_t	ntuple_filter_id;
	/*
	 * If set, this value shall represent the new
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and new network port id of the destination port for
	 * the TX path.
	 */
	uint32_t	new_dst_id;
	/*
	 * New Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint32_t	new_mirror_vnic_id;
	/*
	 * New meter to attach to the flow. Specifying the
	 * invalid instance ID is used to remove any existing
	 * meter from the flow.
	 */
	uint16_t	new_meter_instance_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * instance is not configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_NEW_METER_INSTANCE_ID_INVALID \
		UINT32_C(0xffff)
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_NEW_METER_INSTANCE_ID_LAST \
		HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_NEW_METER_INSTANCE_ID_INVALID
	uint8_t	unused_1[6];
} __rte_packed;

/* hwrm_cfa_ntuple_filter_cfg_output (size:128b/16B) */
struct hwrm_cfa_ntuple_filter_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_cfa_em_flow_alloc *
 **************************/


/* hwrm_cfa_em_flow_alloc_input (size:896b/112B) */
struct hwrm_cfa_em_flow_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH         UINT32_C(0x1)
	/* tx path */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH_TX        UINT32_C(0x0)
	/* rx path */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH_RX        UINT32_C(0x1)
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH_LAST \
		HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH_RX
	/*
	 * Setting of this flag indicates enabling of a byte counter for a
	 * given flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_BYTE_CTR     UINT32_C(0x2)
	/*
	 * Setting of this flag indicates enabling of a packet counter for a
	 * given flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PKT_CTR      UINT32_C(0x4)
	/*
	 * Setting of this flag indicates de-capsulation action for the
	 * given flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_DECAP        UINT32_C(0x8)
	/*
	 * Setting of this flag indicates encapsulation action for the
	 * given flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_ENCAP        UINT32_C(0x10)
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_DROP         UINT32_C(0x20)
	/*
	 * Setting of this flag indicates that a meter is expected to be
	 * attached to this flow. This hint can be used when choosing the
	 * action record format required for the flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_METER        UINT32_C(0x40)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the l2_filter_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_L2_FILTER_ID \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the tunnel_type field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_TUNNEL_TYPE \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the tunnel_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_TUNNEL_ID \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the src_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_SRC_MACADDR \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the dst_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_DST_MACADDR \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the ovlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_OVLAN_VID \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the ivlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_IVLAN_VID \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the ethertype field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_ETHERTYPE \
		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the src_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_SRC_IPADDR \
		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the dst_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_DST_IPADDR \
		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the ipaddr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_IPADDR_TYPE \
		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the ip_protocol field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_IP_PROTOCOL \
		UINT32_C(0x800)
	/*
	 * This bit must be '1' for the src_port field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_SRC_PORT \
		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the dst_port field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_DST_PORT \
		UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_DST_ID \
		UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID \
		UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the encap_record_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_ENCAP_RECORD_ID \
		UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the meter_instance_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_METER_INSTANCE_ID \
		UINT32_C(0x20000)
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL \
		UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN \
		UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_NVGRE \
		UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_L2GRE \
		UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPIP \
		UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_GENEVE \
		UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_MPLS \
		UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_STT \
		UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPGRE \
		UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4 \
		UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1 \
		UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE \
		UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 \
		UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE \
		UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL \
		UINT32_C(0xff)
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_LAST \
		HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused_0[3];
	/*
	 * Tunnel identifier.
	 * Virtual Network Identifier (VNI). Only valid with
	 * tunnel_types VXLAN, NVGRE, and Geneve.
	 * Only lower 24-bits of VNI field are used
	 * in setting up the filter.
	 */
	uint32_t	tunnel_id;
	/*
	 * This value indicates the source MAC address in
	 * the Ethernet header.
	 */
	uint8_t	src_macaddr[6];
	/* The meter instance to attach to the flow. */
	uint16_t	meter_instance_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * instance is not configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_METER_INSTANCE_ID_INVALID \
		UINT32_C(0xffff)
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_METER_INSTANCE_ID_LAST \
		HWRM_CFA_EM_FLOW_ALLOC_INPUT_METER_INSTANCE_ID_INVALID
	/*
	 * This value indicates the destination MAC address in
	 * the Ethernet header.
	 */
	uint8_t	dst_macaddr[6];
	/*
	 * This value indicates the VLAN ID of the outer VLAN tag
	 * in the Ethernet header.
	 */
	uint16_t	ovlan_vid;
	/*
	 * This value indicates the VLAN ID of the inner VLAN tag
	 * in the Ethernet header.
	 */
	uint16_t	ivlan_vid;
	/* This value indicates the ethertype in the Ethernet header. */
	uint16_t	ethertype;
	/*
	 * This value indicates the type of IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	ip_addr_type;
	/* invalid */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_UNKNOWN UINT32_C(0x0)
	/* IPv4 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_IPV4    UINT32_C(0x4)
	/* IPv6 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_IPV6    UINT32_C(0x6)
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_LAST \
		HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_IPV6
	/*
	 * The value of protocol filed in IP header.
	 * Applies to UDP and TCP traffic.
	 * 6 - TCP
	 * 17 - UDP
	 */
	uint8_t	ip_protocol;
	/* invalid */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_UNKNOWN UINT32_C(0x0)
	/* TCP */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_TCP     UINT32_C(0x6)
	/* UDP */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_UDP     UINT32_C(0x11)
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_LAST \
		HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_UDP
	uint8_t	unused_1[2];
	/*
	 * The value of source IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	src_ipaddr[4];
	/*
	 * big_endian = True
	 *     The value of destination IP address to be used in filtering.
	 *     For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	dst_ipaddr[4];
	/*
	 * The value of source port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	src_port;
	/*
	 * The value of destination port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	dst_port;
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and network port id of the destination port for
	 * the TX path.
	 */
	uint16_t	dst_id;
	/*
	 * Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint16_t	mirror_vnic_id;
	/* Logical ID of the encapsulation record. */
	uint32_t	encap_record_id;
	uint8_t	unused_2[4];
} __rte_packed;

/* hwrm_cfa_em_flow_alloc_output (size:192b/24B) */
struct hwrm_cfa_em_flow_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	em_filter_id;
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK \
		UINT32_C(0x3fffffff)
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE \
		UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_INT \
		(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT \
		(UINT32_C(0x1) << 30)
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST \
		HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR \
		UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_RX \
		(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_TX \
		(UINT32_C(0x1) << 31)
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_LAST \
		HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_cfa_em_flow_free *
 *************************/


/* hwrm_cfa_em_flow_free_input (size:192b/24B) */
struct hwrm_cfa_em_flow_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	em_filter_id;
} __rte_packed;

/* hwrm_cfa_em_flow_free_output (size:128b/16B) */
struct hwrm_cfa_em_flow_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_cfa_meter_qcaps *
 ************************/


/* hwrm_cfa_meter_qcaps_input (size:128b/16B) */
struct hwrm_cfa_meter_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_cfa_meter_qcaps_output (size:320b/40B) */
struct hwrm_cfa_meter_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * Enumeration denoting the clock at which the Meter is running
	 * with. This enumeration is used for resources that are similar
	 * for both TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_MASK  UINT32_C(0xf)
	#define HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_SFT   0
	/* 375 MHz */
	#define HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_375MHZ  UINT32_C(0x0)
	/* 625 MHz */
	#define HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_625MHZ  UINT32_C(0x1)
	#define HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_LAST \
		HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_625MHZ
	uint8_t	unused_0[4];
	/*
	 * The minimum guaranteed number of tx meter profiles supported
	 * for this function.
	 */
	uint16_t	min_tx_profile;
	/*
	 * The maximum non-guaranteed number of tx meter profiles supported
	 * for this function.
	 */
	uint16_t	max_tx_profile;
	/*
	 * The minimum guaranteed number of rx meter profiles supported
	 * for this function.
	 */
	uint16_t	min_rx_profile;
	/*
	 * The maximum non-guaranteed number of rx meter profiles supported
	 * for this function.
	 */
	uint16_t	max_rx_profile;
	/*
	 * The minimum guaranteed number of tx meter instances supported
	 * for this function.
	 */
	uint16_t	min_tx_instance;
	/*
	 * The maximum non-guaranteed number of tx meter instances supported
	 * for this function.
	 */
	uint16_t	max_tx_instance;
	/*
	 * The minimum guaranteed number of rx meter instances supported
	 * for this function.
	 */
	uint16_t	min_rx_instance;
	/*
	 * The maximum non-guaranteed number of rx meter instances supported
	 * for this function.
	 */
	uint16_t	max_rx_instance;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/********************************
 * hwrm_cfa_meter_profile_alloc *
 ********************************/


/* hwrm_cfa_meter_profile_alloc_input (size:320b/40B) */
struct hwrm_cfa_meter_profile_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH     UINT32_C(0x1)
	/* tx path */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH_TX \
		UINT32_C(0x0)
	/* rx path */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH_RX \
		UINT32_C(0x1)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH_LAST \
		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH_RX
	/* The meter algorithm type. */
	uint8_t	meter_type;
	/* RFC 2697 (srTCM) */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_RFC2697 \
		UINT32_C(0x0)
	/* RFC 2698 (trTCM) */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_RFC2698 \
		UINT32_C(0x1)
	/* RFC 4115 (trTCM) */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_RFC4115 \
		UINT32_C(0x2)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_LAST \
		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_RFC4115
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint16_t	reserved1;
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint32_t	reserved2;
	/* A meter rate specified in bytes-per-second. */
	uint32_t	commit_rate;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE_LAST \
		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Raw value */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_RAW \
		(UINT32_C(0x7) << 29)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_LAST \
		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_RAW
	/* A meter burst size specified in bytes. */
	uint32_t	commit_burst;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE_LAST \
		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid value */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_LAST \
		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_INVALID
	/* A meter rate specified in bytes-per-second. */
	uint32_t	excess_peak_rate;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE_LAST \
		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Raw unit */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_RAW \
		(UINT32_C(0x7) << 29)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_LAST \
		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_RAW
	/* A meter burst size specified in bytes. */
	uint32_t	excess_peak_burst;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE_LAST \
		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_LAST \
		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_INVALID
} __rte_packed;

/* hwrm_cfa_meter_profile_alloc_output (size:128b/16B) */
struct hwrm_cfa_meter_profile_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value identifies a meter profile in CFA. */
	uint16_t	meter_profile_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * profile is not configured.
	 */
	#define HWRM_CFA_METER_PROFILE_ALLOC_OUTPUT_METER_PROFILE_ID_INVALID \
		UINT32_C(0xffff)
	#define HWRM_CFA_METER_PROFILE_ALLOC_OUTPUT_METER_PROFILE_ID_LAST \
		HWRM_CFA_METER_PROFILE_ALLOC_OUTPUT_METER_PROFILE_ID_INVALID
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************************
 * hwrm_cfa_meter_profile_free *
 *******************************/


/* hwrm_cfa_meter_profile_free_input (size:192b/24B) */
struct hwrm_cfa_meter_profile_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH     UINT32_C(0x1)
	/* tx path */
	#define HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH_TX \
		UINT32_C(0x0)
	/* rx path */
	#define HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH_RX \
		UINT32_C(0x1)
	#define HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH_LAST \
		HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0;
	/* This value identifies a meter profile in CFA. */
	uint16_t	meter_profile_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * profile is not configured.
	 */
	#define HWRM_CFA_METER_PROFILE_FREE_INPUT_METER_PROFILE_ID_INVALID \
		UINT32_C(0xffff)
	#define HWRM_CFA_METER_PROFILE_FREE_INPUT_METER_PROFILE_ID_LAST \
		HWRM_CFA_METER_PROFILE_FREE_INPUT_METER_PROFILE_ID_INVALID
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_cfa_meter_profile_free_output (size:128b/16B) */
struct hwrm_cfa_meter_profile_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************************
 * hwrm_cfa_meter_profile_cfg *
 ******************************/


/* hwrm_cfa_meter_profile_cfg_input (size:320b/40B) */
struct hwrm_cfa_meter_profile_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH     UINT32_C(0x1)
	/* tx path */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH_TX    UINT32_C(0x0)
	/* rx path */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH_RX    UINT32_C(0x1)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH_LAST \
		HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH_RX
	/* The meter algorithm type. */
	uint8_t	meter_type;
	/* RFC 2697 (srTCM) */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_RFC2697 \
		UINT32_C(0x0)
	/* RFC 2698 (trTCM) */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_RFC2698 \
		UINT32_C(0x1)
	/* RFC 4115 (trTCM) */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_RFC4115 \
		UINT32_C(0x2)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_LAST \
		HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_RFC4115
	/* This value identifies a meter profile in CFA. */
	uint16_t	meter_profile_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * profile is not configured.
	 */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_PROFILE_ID_INVALID \
		UINT32_C(0xffff)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_PROFILE_ID_LAST \
		HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_PROFILE_ID_INVALID
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint32_t	reserved;
	/* A meter rate specified in bytes-per-second. */
	uint32_t	commit_rate;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE_LAST \
		HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Raw value */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_RAW \
		(UINT32_C(0x7) << 29)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_LAST \
		HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_RAW
	/* A meter burst size specified in bytes. */
	uint32_t	commit_burst;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE_LAST \
		HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid value */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_LAST \
		HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_INVALID
	/* A meter rate specified in bytes-per-second. */
	uint32_t	excess_peak_rate;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE_LAST \
		HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Raw unit */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_RAW \
		(UINT32_C(0x7) << 29)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_LAST \
		HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_RAW
	/* A meter burst size specified in bytes. */
	uint32_t	excess_peak_burst;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_MASK \
		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_SFT \
		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE \
		UINT32_C(0x10000000)
	/* Value is in bits. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE_BITS \
		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE_BYTES \
		(UINT32_C(0x1) << 28)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE_LAST \
		HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_MASK \
		UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_SFT \
		29
	/* Value is in Mb or MB (base 10). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_MEGA \
		(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_KILO \
		(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_BASE \
		(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_GIGA \
		(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_PERCENT1_100 \
		(UINT32_C(0x1) << 29)
	/* Invalid unit */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_INVALID \
		(UINT32_C(0x7) << 29)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_LAST \
		HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_INVALID
} __rte_packed;

/* hwrm_cfa_meter_profile_cfg_output (size:128b/16B) */
struct hwrm_cfa_meter_profile_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************************
 * hwrm_cfa_meter_instance_alloc *
 *********************************/


/* hwrm_cfa_meter_instance_alloc_input (size:192b/24B) */
struct hwrm_cfa_meter_instance_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH \
		UINT32_C(0x1)
	/* tx path */
	#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH_TX \
		UINT32_C(0x0)
	/* rx path */
	#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH_RX \
		UINT32_C(0x1)
	#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH_LAST \
		HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0;
	/* This value identifies a meter profile in CFA. */
	uint16_t	meter_profile_id;
	/*
	 * A value of 0xffff is considered invalid and implies the
	 * profile is not configured.
	 */
	#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_METER_PROFILE_ID_INVALID \
		UINT32_C(0xffff)
	#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_METER_PROFILE_ID_LAST \
		HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_METER_PROFILE_ID_INVALID
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_cfa_meter_instance_alloc_output (size:128b/16B) */
struct hwrm_cfa_meter_instance_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value identifies a meter instance in CFA. */
	uint16_t	meter_instance_id;
	/*
	 * A value of 0xffff is considered invalid and implies the
	 * instance is not configured.
	 */
	#define HWRM_CFA_METER_INSTANCE_ALLOC_OUTPUT_METER_INSTANCE_ID_INVALID \
		UINT32_C(0xffff)
	#define HWRM_CFA_METER_INSTANCE_ALLOC_OUTPUT_METER_INSTANCE_ID_LAST \
		HWRM_CFA_METER_INSTANCE_ALLOC_OUTPUT_METER_INSTANCE_ID_INVALID
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************************
 * hwrm_cfa_meter_instance_cfg *
 *******************************/


/* hwrm_cfa_meter_instance_cfg_input (size:192b/24B) */
struct hwrm_cfa_meter_instance_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_FLAGS_PATH     UINT32_C(0x1)
	/* tx path */
	#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_FLAGS_PATH_TX \
		UINT32_C(0x0)
	/* rx path */
	#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_FLAGS_PATH_RX \
		UINT32_C(0x1)
	#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_FLAGS_PATH_LAST \
		HWRM_CFA_METER_INSTANCE_CFG_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0;
	/*
	 * This value identifies a new meter profile to be associated with
	 * the meter instance specified in this command.
	 */
	uint16_t	meter_profile_id;
	/*
	 * A value of 0xffff is considered invalid and implies the
	 * profile is not configured.
	 */
	#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_METER_PROFILE_ID_INVALID \
		UINT32_C(0xffff)
	#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_METER_PROFILE_ID_LAST \
		HWRM_CFA_METER_INSTANCE_CFG_INPUT_METER_PROFILE_ID_INVALID
	/*
	 * This value identifies the ID of a meter instance that needs to be
	 * updated with a new meter profile specified in this command.
	 */
	uint16_t	meter_instance_id;
	uint8_t	unused_1[2];
} __rte_packed;

/* hwrm_cfa_meter_instance_cfg_output (size:128b/16B) */
struct hwrm_cfa_meter_instance_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/********************************
 * hwrm_cfa_meter_instance_free *
 ********************************/


/* hwrm_cfa_meter_instance_free_input (size:192b/24B) */
struct hwrm_cfa_meter_instance_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH     UINT32_C(0x1)
	/* tx path */
	#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH_TX \
		UINT32_C(0x0)
	/* rx path */
	#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH_RX \
		UINT32_C(0x1)
	#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH_LAST \
		HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0;
	/* This value identifies a meter instance in CFA. */
	uint16_t	meter_instance_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * instance is not configured.
	 */
	#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_METER_INSTANCE_ID_INVALID \
		UINT32_C(0xffff)
	#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_METER_INSTANCE_ID_LAST \
		HWRM_CFA_METER_INSTANCE_FREE_INPUT_METER_INSTANCE_ID_INVALID
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_cfa_meter_instance_free_output (size:128b/16B) */
struct hwrm_cfa_meter_instance_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************************
 * hwrm_cfa_decap_filter_alloc *
 *******************************/


/* hwrm_cfa_decap_filter_alloc_input (size:832b/104B) */
struct hwrm_cfa_decap_filter_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* ovs_tunnel is 1 b */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_FLAGS_OVS_TUNNEL \
		UINT32_C(0x1)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the tunnel_type field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_TYPE \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the tunnel_id field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_ID \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the src_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_SRC_MACADDR \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the dst_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_DST_MACADDR \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the ovlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_OVLAN_VID \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the ivlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_IVLAN_VID \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the t_ovlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_T_OVLAN_VID \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the t_ivlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_T_IVLAN_VID \
		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the ethertype field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_ETHERTYPE \
		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the src_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_SRC_IPADDR \
		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the dst_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_DST_IPADDR \
		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the ipaddr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_IPADDR_TYPE \
		UINT32_C(0x800)
	/*
	 * This bit must be '1' for the ip_protocol field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_IP_PROTOCOL \
		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the src_port field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_SRC_PORT \
		UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the dst_port field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_DST_PORT \
		UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_DST_ID \
		UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID \
		UINT32_C(0x10000)
	/*
	 * Tunnel identifier.
	 * Virtual Network Identifier (VNI). Only valid with
	 * tunnel_types VXLAN, NVGRE, and Geneve.
	 * Only lower 24-bits of VNI field are used
	 * in setting up the filter.
	 */
	uint32_t	tunnel_id;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL \
		UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN \
		UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NVGRE \
		UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2GRE \
		UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPIP \
		UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_GENEVE \
		UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_MPLS \
		UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_STT \
		UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE \
		UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4 \
		UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1 \
		UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE \
		UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 \
		UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE \
		UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL \
		UINT32_C(0xff)
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_LAST \
		HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused_0;
	uint16_t	unused_1;
	/*
	 * This value indicates the source MAC address in
	 * the Ethernet header.
	 */
	uint8_t	src_macaddr[6];
	uint8_t	unused_2[2];
	/*
	 * This value indicates the destination MAC address in
	 * the Ethernet header.
	 */
	uint8_t	dst_macaddr[6];
	/*
	 * This value indicates the VLAN ID of the outer VLAN tag
	 * in the Ethernet header.
	 */
	uint16_t	ovlan_vid;
	/*
	 * This value indicates the VLAN ID of the inner VLAN tag
	 * in the Ethernet header.
	 */
	uint16_t	ivlan_vid;
	/*
	 * This value indicates the VLAN ID of the outer VLAN tag
	 * in the tunnel Ethernet header.
	 */
	uint16_t	t_ovlan_vid;
	/*
	 * This value indicates the VLAN ID of the inner VLAN tag
	 * in the tunnel Ethernet header.
	 */
	uint16_t	t_ivlan_vid;
	/* This value indicates the ethertype in the Ethernet header. */
	uint16_t	ethertype;
	/*
	 * This value indicates the type of IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	ip_addr_type;
	/* invalid */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_UNKNOWN \
		UINT32_C(0x0)
	/* IPv4 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV4 \
		UINT32_C(0x4)
	/* IPv6 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6 \
		UINT32_C(0x6)
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_LAST \
		HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6
	/*
	 * The value of protocol filed in IP header.
	 * Applies to UDP and TCP traffic.
	 * 6 - TCP
	 * 17 - UDP
	 */
	uint8_t	ip_protocol;
	/* invalid */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_UNKNOWN \
		UINT32_C(0x0)
	/* TCP */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_TCP \
		UINT32_C(0x6)
	/* UDP */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_UDP \
		UINT32_C(0x11)
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_LAST \
		HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_UDP
	uint16_t	unused_3;
	uint32_t	unused_4;
	/*
	 * The value of source IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	src_ipaddr[4];
	/*
	 * The value of destination IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	dst_ipaddr[4];
	/*
	 * The value of source port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	src_port;
	/*
	 * The value of destination port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	dst_port;
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path.
	 */
	uint16_t	dst_id;
	/*
	 * If set, this value shall represent the L2 context that matches the
	 * L2 information of the decap filter.
	 */
	uint16_t	l2_ctxt_ref_id;
} __rte_packed;

/* hwrm_cfa_decap_filter_alloc_output (size:128b/16B) */
struct hwrm_cfa_decap_filter_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint32_t	decap_filter_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************************
 * hwrm_cfa_decap_filter_free *
 ******************************/


/* hwrm_cfa_decap_filter_free_input (size:192b/24B) */
struct hwrm_cfa_decap_filter_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint32_t	decap_filter_id;
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_cfa_decap_filter_free_output (size:128b/16B) */
struct hwrm_cfa_decap_filter_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_cfa_flow_alloc *
 ***********************/


/* hwrm_cfa_flow_alloc_input (size:1024b/128B) */
struct hwrm_cfa_flow_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/* tunnel is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_TUNNEL \
		UINT32_C(0x1)
	/* num_vlan is 2 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_MASK \
		UINT32_C(0x6)
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_SFT           1
	/* no tags */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_NONE \
		(UINT32_C(0x0) << 1)
	/* 1 tag */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_ONE \
		(UINT32_C(0x1) << 1)
	/* 2 tags */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_TWO \
		(UINT32_C(0x2) << 1)
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_LAST \
		HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_TWO
	/* Enumeration denoting the Flow Type. */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_MASK \
		UINT32_C(0x38)
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_SFT           3
	/* L2 flow */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_L2 \
		(UINT32_C(0x0) << 3)
	/* IPV4 flow */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_IPV4 \
		(UINT32_C(0x1) << 3)
	/* IPV6 flow */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_IPV6 \
		(UINT32_C(0x2) << 3)
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_LAST \
		HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_IPV6
	/*
	 * when set to 1, indicates TX flow offload for function specified
	 * in src_fid and the dst_fid should be set to invalid value. To
	 * indicate a VM to VM flow, both of the path_tx and path_rx flags
	 * need to be set. For virtio vSwitch offload case, the src_fid and
	 * dst_fid is set to the same fid value. For the SRIOV vSwitch
	 * offload case, the src_fid and dst_fid must be set to the same VF
	 * FID belong to the children VFs of the same PF to indicate VM to
	 * VM flow.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_PATH_TX \
		UINT32_C(0x40)
	/*
	 * when set to 1, indicates RX flow offload for function specified
	 * in dst_fid and the src_fid should be set to invalid value.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_PATH_RX \
		UINT32_C(0x80)
	/*
	 * Set to 1 to indicate matching of VXLAN VNI from the custom vxlan
	 * header is required and the VXLAN VNI value is stored in the first
	 * 24 bits of the dmac field. This flag is only valid when the flow
	 * direction is RX.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_MATCH_VXLAN_IP_VNI \
		UINT32_C(0x100)
	/*
	 * Set to 1 to indicate vhost_id is specified in the outer_vlan_tci
	 * field.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_VHOST_ID_USE_VLAN \
		UINT32_C(0x200)
	/*
	 * Tx Flow: vf fid.
	 * Rx Flow: pf fid.
	 */
	uint16_t	src_fid;
	/* Tunnel handle valid when tunnel flag is set. */
	uint32_t	tunnel_handle;
	uint16_t	action_flags;
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_FWD \
		UINT32_C(0x1)
	/* recycle is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_RECYCLE \
		UINT32_C(0x2)
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_DROP \
		UINT32_C(0x4)
	/* meter is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_METER \
		UINT32_C(0x8)
	/* tunnel is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_TUNNEL \
		UINT32_C(0x10)
	/* nat_src is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_NAT_SRC \
		UINT32_C(0x20)
	/* nat_dest is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_NAT_DEST \
		UINT32_C(0x40)
	/* nat_ipv4_address is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_NAT_IPV4_ADDRESS \
		UINT32_C(0x80)
	/* l2_header_rewrite is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_L2_HEADER_REWRITE \
		UINT32_C(0x100)
	/* ttl_decrement is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_TTL_DECREMENT \
		UINT32_C(0x200)
	/*
	 * If set to 1 and flow direction is TX, it indicates decap of L2
	 * header and encap of tunnel header. If set to 1 and flow direction
	 * is RX, it indicates decap of tunnel header and encap L2 header.
	 * The type of tunnel is specified in the tunnel_type field.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_TUNNEL_IP \
		UINT32_C(0x400)
	/* If set to 1, flow aging is enabled for this flow. */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_FLOW_AGING_ENABLED \
		UINT32_C(0x800)
	/*
	 * If set to 1 an attempt will be made to try to offload this flow
	 * to the most optimal flow table resource. If set to 0, the flow
	 * will be placed to the default flow table resource.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_PRI_HINT \
		UINT32_C(0x1000)
	/*
	 * If set to 1 there will be no attempt to allocate an on-chip try
	 * to offload this flow. If set to 0, which will keep compatibility
	 * with the older drivers, will cause the FW to attempt to allocate
	 * an on-chip flow counter for the newly created flow. This will
	 * keep the existing behavior with EM flows which always had an
	 * associated flow counter.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_NO_FLOW_COUNTER_ALLOC \
		UINT32_C(0x2000)
	/*
	 * Tx Flow: pf or vf fid.
	 * Rx Flow: vf fid.
	 */
	uint16_t	dst_fid;
	/* VLAN tpid, valid when push_vlan flag is set. */
	uint16_t	l2_rewrite_vlan_tpid;
	/* VLAN tci, valid when push_vlan flag is set. */
	uint16_t	l2_rewrite_vlan_tci;
	/* Meter id, valid when meter flag is set. */
	uint16_t	act_meter_id;
	/* Flow with the same l2 context tcam key. */
	uint16_t	ref_flow_handle;
	/* This value sets the match value for the ethertype. */
	uint16_t	ethertype;
	/* valid when num tags is 1 or 2. */
	uint16_t	outer_vlan_tci;
	/* This value sets the match value for the Destination MAC address. */
	uint16_t	dmac[3];
	/* valid when num tags is 2. */
	uint16_t	inner_vlan_tci;
	/* This value sets the match value for the Source MAC address. */
	uint16_t	smac[3];
	/* The bit length of destination IP address mask. */
	uint8_t	ip_dst_mask_len;
	/* The bit length of source IP address mask. */
	uint8_t	ip_src_mask_len;
	/* The value of destination IPv4/IPv6 address. */
	uint32_t	ip_dst[4];
	/* The source IPv4/IPv6 address. */
	uint32_t	ip_src[4];
	/*
	 * The value of source port.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	l4_src_port;
	/*
	 * The value of source port mask.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	l4_src_port_mask;
	/*
	 * The value of destination port.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	l4_dst_port;
	/*
	 * The value of destination port mask.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	l4_dst_port_mask;
	/*
	 * NAT IPv4/6 address based on address type flag.
	 * 0 values are ignored.
	 */
	uint32_t	nat_ip_address[4];
	/* L2 header re-write Destination MAC address. */
	uint16_t	l2_rewrite_dmac[3];
	/*
	 * The NAT source/destination port based on direction flag.
	 * Applies to UDP and TCP traffic.
	 * 0 values are ignored.
	 */
	uint16_t	nat_port;
	/* L2 header re-write Source MAC address. */
	uint16_t	l2_rewrite_smac[3];
	/* The value of ip protocol. */
	uint8_t	ip_proto;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL \
		UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN \
		UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_NVGRE \
		UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_L2GRE \
		UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPIP \
		UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_GENEVE \
		UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_MPLS \
		UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_STT \
		UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPGRE \
		UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4 \
		UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1 \
		UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE \
		UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 \
		UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE \
		UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL \
		UINT32_C(0xff)
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_LAST \
		HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
} __rte_packed;

/* hwrm_cfa_flow_alloc_output (size:256b/32B) */
struct hwrm_cfa_flow_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Flow record index. */
	uint16_t	flow_handle;
	uint8_t	unused_0[2];
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK \
		UINT32_C(0x3fffffff)
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE \
		UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_INT \
		(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT \
		(UINT32_C(0x1) << 30)
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST \
		HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR \
		UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_RX \
		(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_TX \
		(UINT32_C(0x1) << 31)
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_LAST \
		HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	/* This value identifies a set of CFA data structures used for a flow. */
	uint64_t	ext_flow_handle;
	uint32_t	flow_counter_id;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* hwrm_cfa_flow_alloc_cmd_err (size:64b/8B) */
struct hwrm_cfa_flow_alloc_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_UNKNOWN         UINT32_C(0x0)
	/* No more L2 Context TCAM */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_L2_CONTEXT_TCAM UINT32_C(0x1)
	/* No more action records */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_ACTION_RECORD   UINT32_C(0x2)
	/* No more flow counters */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_FLOW_COUNTER    UINT32_C(0x3)
	/* No more wild-card TCAM */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_WILD_CARD_TCAM  UINT32_C(0x4)
	/* Hash collision in exact match tables */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_HASH_COLLISION  UINT32_C(0x5)
	/* Key is already installed */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_KEY_EXISTS      UINT32_C(0x6)
	/* Flow Context DB is out of resource */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_FLOW_CTXT_DB    UINT32_C(0x7)
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_LAST \
		HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_FLOW_CTXT_DB
	uint8_t	unused_0[7];
} __rte_packed;

/**********************
 * hwrm_cfa_flow_free *
 **********************/


/* hwrm_cfa_flow_free_input (size:256b/32B) */
struct hwrm_cfa_flow_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Flow record index. */
	uint16_t	flow_handle;
	uint16_t	unused_0;
	/* Flow counter id to be freed. */
	uint32_t	flow_counter_id;
	/* This value identifies a set of CFA data structures used for a flow. */
	uint64_t	ext_flow_handle;
} __rte_packed;

/* hwrm_cfa_flow_free_output (size:256b/32B) */
struct hwrm_cfa_flow_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* packet is 64 b */
	uint64_t	packet;
	/* byte is 64 b */
	uint64_t	byte;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* hwrm_cfa_flow_action_data (size:960b/120B) */
struct hwrm_cfa_flow_action_data {
	uint16_t	action_flags;
	/* Setting of this flag indicates accept action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_FWD \
		UINT32_C(0x1)
	/* Setting of this flag indicates recycle action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_RECYCLE \
		UINT32_C(0x2)
	/* Setting of this flag indicates drop action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_DROP \
		UINT32_C(0x4)
	/* Setting of this flag indicates meter action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_METER \
		UINT32_C(0x8)
	/* Setting of this flag indicates tunnel action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_TUNNEL \
		UINT32_C(0x10)
	/*
	 * If set to 1 and flow direction is TX, it indicates decap of L2
	 * header and encap of tunnel header. If set to 1 and flow direction
	 * is RX, it indicates decap of tunnel header and encap L2 header.
	 */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_TUNNEL_IP \
		UINT32_C(0x20)
	/* Setting of this flag indicates ttl decrement action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_TTL_DECREMENT \
		UINT32_C(0x40)
	/* If set to 1, flow aging is enabled for this flow. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_FLOW_AGING_ENABLED \
		UINT32_C(0x80)
	/* Setting of this flag indicates encap action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_ENCAP \
		UINT32_C(0x100)
	/* Setting of this flag indicates decap action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_DECAP \
		UINT32_C(0x200)
	/* Meter id. */
	uint16_t	act_meter_id;
	/* VNIC id. */
	uint16_t	vnic_id;
	/* vport number. */
	uint16_t	vport_id;
	/* The NAT source/destination. */
	uint16_t	nat_port;
	uint16_t	unused_0[3];
	/* NAT IPv4/IPv6 address. */
	uint32_t	nat_ip_address[4];
	/* Encapsulation Type. */
	uint8_t	encap_type;
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VXLAN        UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_NVGRE        UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) after inside Ethernet payload */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_L2GRE        UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_IPIP         UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_GENEVE       UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_MPLS         UINT32_C(0x6)
	/* VLAN */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VLAN         UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_IPGRE        UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VXLAN_V4     UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_IPGRE_V1     UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_L2_ETYPE     UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VXLAN_GPE \
		UINT32_C(0x10)
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_LAST \
		HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VXLAN_GPE
	uint8_t	unused[7];
	/* This value is encap data for the associated encap type. */
	uint32_t	encap_data[20];
} __rte_packed;

/* hwrm_cfa_flow_tunnel_hdr_data (size:64b/8B) */
struct hwrm_cfa_flow_tunnel_hdr_data {
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_NONTUNNEL \
		UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_VXLAN \
		UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_NVGRE \
		UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_L2GRE \
		UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_IPIP \
		UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_GENEVE \
		UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_MPLS \
		UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_STT \
		UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_IPGRE \
		UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_VXLAN_V4 \
		UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_IPGRE_V1 \
		UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_L2_ETYPE \
		UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_VXLAN_GPE_V6 \
		UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_VXLAN_GPE \
		UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_ANYTUNNEL \
		UINT32_C(0xff)
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_LAST \
		HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused[3];
	/*
	 * Tunnel identifier.
	 * Virtual Network Identifier (VNI).
	 */
	uint32_t	tunnel_id;
} __rte_packed;

/* hwrm_cfa_flow_l4_key_data (size:64b/8B) */
struct hwrm_cfa_flow_l4_key_data {
	/* The value of source port. */
	uint16_t	l4_src_port;
	/* The value of destination port. */
	uint16_t	l4_dst_port;
	uint32_t	unused;
} __rte_packed;

/* hwrm_cfa_flow_l3_key_data (size:512b/64B) */
struct hwrm_cfa_flow_l3_key_data {
	/* The value of ip protocol. */
	uint8_t	ip_protocol;
	uint8_t	unused_0[7];
	/* The value of destination IPv4/IPv6 address. */
	uint32_t	ip_dst[4];
	/* The source IPv4/IPv6 address. */
	uint32_t	ip_src[4];
	/* NAT IPv4/IPv6 address. */
	uint32_t	nat_ip_address[4];
	uint32_t	unused[2];
} __rte_packed;

/* hwrm_cfa_flow_l2_key_data (size:448b/56B) */
struct hwrm_cfa_flow_l2_key_data {
	/* Destination MAC address. */
	uint16_t	dmac[3];
	uint16_t	unused_0;
	/* Source MAC address. */
	uint16_t	smac[3];
	uint16_t	unused_1;
	/* L2 header re-write Destination MAC address. */
	uint16_t	l2_rewrite_dmac[3];
	uint16_t	unused_2;
	/* L2 header re-write Source MAC address. */
	uint16_t	l2_rewrite_smac[3];
	/* Ethertype. */
	uint16_t	ethertype;
	/* Number of VLAN tags. */
	uint16_t	num_vlan_tags;
	/* VLAN tpid. */
	uint16_t	l2_rewrite_vlan_tpid;
	/* VLAN tci. */
	uint16_t	l2_rewrite_vlan_tci;
	uint8_t	unused_3[2];
	/* Outer VLAN TPID. */
	uint16_t	ovlan_tpid;
	/* Outer VLAN TCI. */
	uint16_t	ovlan_tci;
	/* Inner VLAN TPID. */
	uint16_t	ivlan_tpid;
	/* Inner VLAN TCI. */
	uint16_t	ivlan_tci;
	uint8_t	unused[8];
} __rte_packed;

/* hwrm_cfa_flow_key_data (size:4160b/520B) */
struct hwrm_cfa_flow_key_data {
	/* Flow associated tunnel L2 header key info. */
	uint32_t	t_l2_key_data[14];
	/* Flow associated tunnel L2 header mask info. */
	uint32_t	t_l2_key_mask[14];
	/* Flow associated tunnel L3 header key info. */
	uint32_t	t_l3_key_data[16];
	/* Flow associated tunnel L3 header mask info. */
	uint32_t	t_l3_key_mask[16];
	/* Flow associated tunnel L4 header key info. */
	uint32_t	t_l4_key_data[2];
	/* Flow associated tunnel L4 header mask info. */
	uint32_t	t_l4_key_mask[2];
	/* Flow associated tunnel header info. */
	uint32_t	tunnel_hdr[2];
	/* Flow associated L2 header key info. */
	uint32_t	l2_key_data[14];
	/* Flow associated L2 header mask info. */
	uint32_t	l2_key_mask[14];
	/* Flow associated L3 header key info. */
	uint32_t	l3_key_data[16];
	/* Flow associated L3 header mask info. */
	uint32_t	l3_key_mask[16];
	/* Flow associated L4 header key info. */
	uint32_t	l4_key_data[2];
	/* Flow associated L4 header mask info. */
	uint32_t	l4_key_mask[2];
} __rte_packed;

/**********************
 * hwrm_cfa_flow_info *
 **********************/


/* hwrm_cfa_flow_info_input (size:256b/32B) */
struct hwrm_cfa_flow_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Flow record index. */
	uint16_t	flow_handle;
	/* Max flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_MAX_MASK \
		UINT32_C(0xfff)
	/* CNP flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_CNP_CNT \
		UINT32_C(0x1000)
	/* RoCEv1 flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_ROCEV1_CNT \
		UINT32_C(0x2000)
	/* NIC flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_NIC_TX \
		UINT32_C(0x3000)
	/* RoCEv2 flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_ROCEV2_CNT \
		UINT32_C(0x4000)
	/* Direction rx = 1 */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_DIR_RX \
		UINT32_C(0x8000)
	/* CNP flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_CNP_CNT_RX \
		UINT32_C(0x9000)
	/* RoCEv1 flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_ROCEV1_CNT_RX \
		UINT32_C(0xa000)
	/* NIC flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_NIC_RX \
		UINT32_C(0xb000)
	/* RoCEv2 flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_ROCEV2_CNT_RX \
		UINT32_C(0xc000)
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_LAST \
		HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_ROCEV2_CNT_RX
	uint8_t	unused_0[6];
	/* This value identifies a set of CFA data structures used for a flow. */
	uint64_t	ext_flow_handle;
} __rte_packed;

/* hwrm_cfa_flow_info_output (size:5632b/704B) */
struct hwrm_cfa_flow_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	flags;
	/* When set to 1, indicates the configuration is the TX flow. */
	#define HWRM_CFA_FLOW_INFO_OUTPUT_FLAGS_PATH_TX     UINT32_C(0x1)
	/* When set to 1, indicates the configuration is the RX flow. */
	#define HWRM_CFA_FLOW_INFO_OUTPUT_FLAGS_PATH_RX     UINT32_C(0x2)
	/* profile is 8 b */
	uint8_t	profile;
	/* src_fid is 16 b */
	uint16_t	src_fid;
	/* dst_fid is 16 b */
	uint16_t	dst_fid;
	/* l2_ctxt_id is 16 b */
	uint16_t	l2_ctxt_id;
	/* em_info is 64 b */
	uint64_t	em_info;
	/* tcam_info is 64 b */
	uint64_t	tcam_info;
	/* vfp_tcam_info is 64 b */
	uint64_t	vfp_tcam_info;
	/* ar_id is 16 b */
	uint16_t	ar_id;
	/* flow_handle is 16 b */
	uint16_t	flow_handle;
	/* tunnel_handle is 32 b */
	uint32_t	tunnel_handle;
	/* The flow aging timer for the flow, the unit is 100 milliseconds */
	uint16_t	flow_timer;
	uint8_t	unused_0[6];
	/* Flow associated L2, L3 and L4 headers info. */
	uint32_t	flow_key_data[130];
	/* Flow associated action record info. */
	uint32_t	flow_action_info[30];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_cfa_flow_flush *
 ***********************/


/* hwrm_cfa_flow_flush_input (size:256b/32B) */
struct hwrm_cfa_flow_flush_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* flags is 32 b */
	uint32_t	flags;
	/*
	 * Set to 1 to indicate the page size, page layers, and
	 * flow_handle_table_dma_addr fields are valid. The flow flush
	 * operation should only flush the flows from the flow table
	 * specified. This flag is set to 0 by older driver. For older
	 * firmware, setting this flag has no effect.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_TABLE_VALID \
		UINT32_C(0x1)
	/*
	 * Set to 1 to indicate flow flush operation to cleanup all the
	 * flows, meters, CFA context memory tables etc. This flag is set to
	 * 0 by older driver. For older firmware, setting this flag has no
	 * effect.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_RESET_ALL \
		UINT32_C(0x2)
	/*
	 * Set to 1 to indicate flow flush operation to cleanup all the
	 * flows by the caller. This flag is set to 0 by older driver. For
	 * older firmware, setting this flag has no effect.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_RESET_PORT \
		UINT32_C(0x4)
	/*
	 * Set to 1 to indicate the flow counter IDs are included in the
	 * flow table.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_INCL_FC \
		UINT32_C(0x8000000)
	/*
	 * This specifies the size of flow handle entries provided by the
	 * driver in the flow table specified below. Only two flow handle
	 * size enums are defined.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_MASK \
		UINT32_C(0xc0000000)
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_SFT \
		30
	/* The flow handle is 16bit */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_FLOW_HND_16BIT \
		(UINT32_C(0x0) << 30)
	/* The flow handle is 64bit */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_FLOW_HND_64BIT \
		(UINT32_C(0x1) << 30)
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_LAST \
		HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_FLOW_HND_64BIT
	/* Specify page size of the flow table memory. */
	uint8_t	page_size;
	/* The page size is 4K */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_4K   UINT32_C(0x0)
	/* The page size is 8K */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_8K   UINT32_C(0x1)
	/* The page size is 64K */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_64K  UINT32_C(0x4)
	/* The page size is 256K */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_256K UINT32_C(0x6)
	/* The page size is 1M */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_1M   UINT32_C(0x8)
	/* The page size is 2M */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_2M   UINT32_C(0x9)
	/* The page size is 4M */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_4M   UINT32_C(0xa)
	/* The page size is 1G */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_1G   UINT32_C(0x12)
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_LAST \
		HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_1G
	/* FLow table memory indirect levels. */
	uint8_t	page_level;
	/* PBL pointer is physical start address. */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_LEVEL_LVL_0 UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_LEVEL_LVL_1 UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_LEVEL_LVL_2 UINT32_C(0x2)
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_LEVEL_LAST \
		HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_LEVEL_LVL_2
	/* number of flows in the flow table */
	uint16_t	num_flows;
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	page_dir;
} __rte_packed;

/* hwrm_cfa_flow_flush_output (size:128b/16B) */
struct hwrm_cfa_flow_flush_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_cfa_flow_stats *
 ***********************/


/* hwrm_cfa_flow_stats_input (size:640b/80B) */
struct hwrm_cfa_flow_stats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Number of valid flows in this command. */
	uint16_t	num_flows;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_0 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_0;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_1 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_1;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_2 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_2;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_3 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_3;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_4 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_4;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_5 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_5;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_6 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_6;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_7 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_7;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_8 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_8;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_9 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_9;
	uint8_t	unused_0[2];
	/* Flow ID of a flow. */
	uint32_t	flow_id_0;
	/* Flow ID of a flow. */
	uint32_t	flow_id_1;
	/* Flow ID of a flow. */
	uint32_t	flow_id_2;
	/* Flow ID of a flow. */
	uint32_t	flow_id_3;
	/* Flow ID of a flow. */
	uint32_t	flow_id_4;
	/* Flow ID of a flow. */
	uint32_t	flow_id_5;
	/* Flow ID of a flow. */
	uint32_t	flow_id_6;
	/* Flow ID of a flow. */
	uint32_t	flow_id_7;
	/* Flow ID of a flow. */
	uint32_t	flow_id_8;
	/* Flow ID of a flow. */
	uint32_t	flow_id_9;
} __rte_packed;

/* hwrm_cfa_flow_stats_output (size:1408b/176B) */
struct hwrm_cfa_flow_stats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* packet_0 is 64 b */
	uint64_t	packet_0;
	/* packet_1 is 64 b */
	uint64_t	packet_1;
	/* packet_2 is 64 b */
	uint64_t	packet_2;
	/* packet_3 is 64 b */
	uint64_t	packet_3;
	/* packet_4 is 64 b */
	uint64_t	packet_4;
	/* packet_5 is 64 b */
	uint64_t	packet_5;
	/* packet_6 is 64 b */
	uint64_t	packet_6;
	/* packet_7 is 64 b */
	uint64_t	packet_7;
	/* packet_8 is 64 b */
	uint64_t	packet_8;
	/* packet_9 is 64 b */
	uint64_t	packet_9;
	/* byte_0 is 64 b */
	uint64_t	byte_0;
	/* byte_1 is 64 b */
	uint64_t	byte_1;
	/* byte_2 is 64 b */
	uint64_t	byte_2;
	/* byte_3 is 64 b */
	uint64_t	byte_3;
	/* byte_4 is 64 b */
	uint64_t	byte_4;
	/* byte_5 is 64 b */
	uint64_t	byte_5;
	/* byte_6 is 64 b */
	uint64_t	byte_6;
	/* byte_7 is 64 b */
	uint64_t	byte_7;
	/* byte_8 is 64 b */
	uint64_t	byte_8;
	/* byte_9 is 64 b */
	uint64_t	byte_9;
	/*
	 * If a flow has been hit, the bit representing the flow will be 1.
	 * Likewise, if a flow has not, the bit representing the flow
	 * will be 0. Mapping will match flow numbers where bitX is for flowX
	 * (ex: bit 0 is flow0).  This only applies for NIC flows. Upon
	 * reading of the flow, the bit will be cleared for the flow and only
	 * set again when traffic is received by the flow.
	 */
	uint16_t	flow_hits;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************************
 * hwrm_cfa_flow_aging_timer_reset *
 ***********************************/


/* hwrm_cfa_flow_aging_timer_reset_input (size:256b/32B) */
struct hwrm_cfa_flow_aging_timer_reset_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Flow record index. */
	uint16_t	flow_handle;
	uint8_t	unused_0[2];
	/*
	 * New flow timer value for the flow specified in the ext_flow_handle.
	 * The flow timer unit is 100ms.
	 */
	uint32_t	flow_timer;
	/* This value identifies a set of CFA data structures used for a flow. */
	uint64_t	ext_flow_handle;
} __rte_packed;

/* hwrm_cfa_flow_aging_timer_reset_output (size:128b/16B) */
struct hwrm_cfa_flow_aging_timer_reset_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_cfa_flow_aging_cfg *
 ***************************/


/* hwrm_cfa_flow_aging_cfg_input (size:384b/48B) */
struct hwrm_cfa_flow_aging_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The bit field to enable per flow aging configuration. */
	uint16_t	enables;
	/*
	 * This bit must be '1' for the tcp flow timer field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_TCP_FLOW_TIMER \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the tcp finish timer field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_TCP_FIN_TIMER \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the udp flow timer field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_UDP_FLOW_TIMER \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the eem dma interval field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_EEM_DMA_INTERVAL \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the eem notice interval field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_EEM_NOTICE_INTERVAL \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the eem context memory maximum entries
	 * field to be configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_EEM_CTX_MAX_ENTRIES \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the eem context memory ID field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_EEM_CTX_ID \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the eem context memory type field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_EEM_CTX_MEM_TYPE \
		UINT32_C(0x80)
	uint8_t	flags;
	/* Enumeration denoting the RX, TX type of the resource. */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_PATH       UINT32_C(0x1)
	/* tx path */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_PATH_TX      UINT32_C(0x0)
	/* rx path */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_PATH_RX      UINT32_C(0x1)
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_PATH_LAST \
		HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_PATH_RX
	/*
	 * Enumeration denoting the enable, disable eem flow aging
	 * configuration.
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_EEM        UINT32_C(0x2)
	/* tx path */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_EEM_DISABLE \
		(UINT32_C(0x0) << 1)
	/* rx path */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_EEM_ENABLE \
		(UINT32_C(0x1) << 1)
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_EEM_LAST \
		HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_EEM_ENABLE
	uint8_t	unused_0;
	/*
	 * The flow aging timer for all TCP flows, the unit is 100
	 * milliseconds.
	 */
	uint32_t	tcp_flow_timer;
	/*
	 * The TCP finished timer for all TCP flows, the unit is 100
	 * milliseconds.
	 */
	uint32_t	tcp_fin_timer;
	/*
	 * The flow aging timer for all UDP flows, the unit is 100
	 * milliseconds.
	 */
	uint32_t	udp_flow_timer;
	/*
	 * The interval to dma eem ejection data to host memory, the unit is
	 * milliseconds.
	 */
	uint16_t	eem_dma_interval;
	/*
	 * The interval to notify driver to read the eem ejection data, the
	 * unit is milliseconds.
	 */
	uint16_t	eem_notice_interval;
	/* The maximum entries number in the eem context memory. */
	uint32_t	eem_ctx_max_entries;
	/* The context memory ID for eem flow aging. */
	uint16_t	eem_ctx_id;
	uint16_t	eem_ctx_mem_type;
	/*
	 * The content of context memory is eem ejection data, the size of
	 * each entry is 4 bytes.
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_EEM_CTX_MEM_TYPE_EJECTION_DATA \
		UINT32_C(0x0)
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_EEM_CTX_MEM_TYPE_LAST \
		HWRM_CFA_FLOW_AGING_CFG_INPUT_EEM_CTX_MEM_TYPE_EJECTION_DATA
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_cfa_flow_aging_cfg_output (size:128b/16B) */
struct hwrm_cfa_flow_aging_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/****************************
 * hwrm_cfa_flow_aging_qcfg *
 ****************************/


/* hwrm_cfa_flow_aging_qcfg_input (size:192b/24B) */
struct hwrm_cfa_flow_aging_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The direction for the flow aging configuration, 1 is rx path, 2 is
	 * tx path.
	 */
	uint8_t	flags;
	/* Enumeration denoting the RX, TX type of the resource. */
	#define HWRM_CFA_FLOW_AGING_QCFG_INPUT_FLAGS_PATH     UINT32_C(0x1)
	/* tx path */
	#define HWRM_CFA_FLOW_AGING_QCFG_INPUT_FLAGS_PATH_TX    UINT32_C(0x0)
	/* rx path */
	#define HWRM_CFA_FLOW_AGING_QCFG_INPUT_FLAGS_PATH_RX    UINT32_C(0x1)
	#define HWRM_CFA_FLOW_AGING_QCFG_INPUT_FLAGS_PATH_LAST \
		HWRM_CFA_FLOW_AGING_QCFG_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0[7];
} __rte_packed;

/* hwrm_cfa_flow_aging_qcfg_output (size:320b/40B) */
struct hwrm_cfa_flow_aging_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The current flow aging timer for all TCP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	tcp_flow_timer;
	/*
	 * The current TCP finished timer for all TCP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	tcp_fin_timer;
	/*
	 * The current flow aging timer for all UDP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	udp_flow_timer;
	/*
	 * The interval to dma eem ejection data to host memory, the unit is
	 * milliseconds.
	 */
	uint16_t	eem_dma_interval;
	/*
	 * The interval to notify driver to read the eem ejection data, the
	 * unit is milliseconds.
	 */
	uint16_t	eem_notice_interval;
	/* The maximum entries number in the eem context memory. */
	uint32_t	eem_ctx_max_entries;
	/* The context memory ID for eem flow aging. */
	uint16_t	eem_ctx_id;
	/* The context memory type for eem flow aging. */
	uint16_t	eem_ctx_mem_type;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************************
 * hwrm_cfa_flow_aging_qcaps *
 *****************************/


/* hwrm_cfa_flow_aging_qcaps_input (size:192b/24B) */
struct hwrm_cfa_flow_aging_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The direction for the flow aging configuration, 1 is rx path, 2 is
	 * tx path.
	 */
	uint8_t	flags;
	/* Enumeration denoting the RX, TX type of the resource. */
	#define HWRM_CFA_FLOW_AGING_QCAPS_INPUT_FLAGS_PATH     UINT32_C(0x1)
	/* tx path */
	#define HWRM_CFA_FLOW_AGING_QCAPS_INPUT_FLAGS_PATH_TX    UINT32_C(0x0)
	/* rx path */
	#define HWRM_CFA_FLOW_AGING_QCAPS_INPUT_FLAGS_PATH_RX    UINT32_C(0x1)
	#define HWRM_CFA_FLOW_AGING_QCAPS_INPUT_FLAGS_PATH_LAST \
		HWRM_CFA_FLOW_AGING_QCAPS_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0[7];
} __rte_packed;

/* hwrm_cfa_flow_aging_qcaps_output (size:256b/32B) */
struct hwrm_cfa_flow_aging_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The maximum flow aging timer for all TCP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	max_tcp_flow_timer;
	/*
	 * The maximum TCP finished timer for all TCP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	max_tcp_fin_timer;
	/*
	 * The maximum flow aging timer for all UDP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	max_udp_flow_timer;
	/* The maximum aging flows that HW can support. */
	uint32_t	max_aging_flows;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************************
 * hwrm_cfa_tcp_flag_process_qcfg *
 **********************************/


/* hwrm_cfa_tcp_flag_process_qcfg_input (size:128b/16B) */
struct hwrm_cfa_tcp_flag_process_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_cfa_tcp_flag_process_qcfg_output (size:192b/24B) */
struct hwrm_cfa_tcp_flag_process_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The port 0 RX mirror action record ID. */
	uint16_t	rx_ar_id_port0;
	/* The port 1 RX mirror action record ID. */
	uint16_t	rx_ar_id_port1;
	/*
	 * The port 0 RX action record ID for TX TCP flag packets from
	 * loopback path.
	 */
	uint16_t	tx_ar_id_port0;
	/*
	 * The port 1 RX action record ID for TX TCP flag packets from
	 * loopback path.
	 */
	uint16_t	tx_ar_id_port1;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_cfa_vf_pair_alloc *
 **************************/


/* hwrm_cfa_vf_pair_alloc_input (size:448b/56B) */
struct hwrm_cfa_vf_pair_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_a_id;
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_b_id;
	uint8_t	unused_0[4];
	/* VF Pair name (32 byte string). */
	char	pair_name[32];
} __rte_packed;

/* hwrm_cfa_vf_pair_alloc_output (size:128b/16B) */
struct hwrm_cfa_vf_pair_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_cfa_vf_pair_free *
 *************************/


/* hwrm_cfa_vf_pair_free_input (size:384b/48B) */
struct hwrm_cfa_vf_pair_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* VF Pair name (32 byte string). */
	char	pair_name[32];
} __rte_packed;

/* hwrm_cfa_vf_pair_free_output (size:128b/16B) */
struct hwrm_cfa_vf_pair_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_cfa_vf_pair_info *
 *************************/


/* hwrm_cfa_vf_pair_info_input (size:448b/56B) */
struct hwrm_cfa_vf_pair_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* If this flag is set, lookup by name else lookup by index. */
	#define HWRM_CFA_VF_PAIR_INFO_INPUT_FLAGS_LOOKUP_TYPE     UINT32_C(0x1)
	/* vf pair table index. */
	uint16_t	vf_pair_index;
	uint8_t	unused_0[2];
	/* VF Pair name (32 byte string). */
	char	vf_pair_name[32];
} __rte_packed;

/* hwrm_cfa_vf_pair_info_output (size:512b/64B) */
struct hwrm_cfa_vf_pair_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* vf pair table index. */
	uint16_t	next_vf_pair_index;
	/* vf pair member a's vf_fid. */
	uint16_t	vf_a_fid;
	/* vf pair member a's Linux logical VF number. */
	uint16_t	vf_a_index;
	/* vf pair member b's vf_fid. */
	uint16_t	vf_b_fid;
	/* vf pair member a's Linux logical VF number. */
	uint16_t	vf_b_index;
	/* vf pair state. */
	uint8_t	pair_state;
	/* Pair has been allocated */
	#define HWRM_CFA_VF_PAIR_INFO_OUTPUT_PAIR_STATE_ALLOCATED UINT32_C(0x1)
	/* Both pair members are active */
	#define HWRM_CFA_VF_PAIR_INFO_OUTPUT_PAIR_STATE_ACTIVE    UINT32_C(0x2)
	#define HWRM_CFA_VF_PAIR_INFO_OUTPUT_PAIR_STATE_LAST \
		HWRM_CFA_VF_PAIR_INFO_OUTPUT_PAIR_STATE_ACTIVE
	uint8_t	unused_0[5];
	/* VF Pair name (32 byte string). */
	char	pair_name[32];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_cfa_pair_alloc *
 ***********************/


/* hwrm_cfa_pair_alloc_input (size:576b/72B) */
struct hwrm_cfa_pair_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Pair mode (0-vf2fn, 1-rep2fn, 2-rep2rep, 3-proxy, 4-pfpair,
	 *            5-rep2fn_mod, 6-rep2fn_modall, 7-rep2fn_truflow).
	 */
	uint16_t	pair_mode;
	/*
	 * Pair between VF on local host with PF or VF on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_VF2FN \
		UINT32_C(0x0)
	/*
	 * Pair between REP on local host with PF or VF on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2FN \
		UINT32_C(0x1)
	/*
	 * Pair between REP on local host with REP on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2REP \
		UINT32_C(0x2)
	/* Pair for the proxy interface. (deprecated) */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_PROXY \
		UINT32_C(0x3)
	/* Pair for the PF interface. (deprecated) */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_PFPAIR \
		UINT32_C(0x4)
	/* Modify existing rep2fn pair and move pair to new PF. (deprecated) */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2FN_MOD \
		UINT32_C(0x5)
	/*
	 * Modify existing rep2fn pairs paired with same PF and move pairs
	 * to new PF. (deprecated)
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2FN_MODALL \
		UINT32_C(0x6)
	/*
	 * Truflow pair between REP on local host with PF or VF on specified
	 * host.
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2FN_TRUFLOW \
		UINT32_C(0x7)
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_LAST \
		HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2FN_TRUFLOW
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_a_id;
	/* Logical Host (0xff-local host). */
	uint8_t	host_b_id;
	/* Logical PF (0xff-PF for command channel). */
	uint8_t	pf_b_id;
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_b_id;
	/* Loopback port (0xff-internal loopback), valid for mode-3. */
	uint8_t	port_id;
	/* Priority used for encap of loopback packets valid for mode-3. */
	uint8_t	pri;
	/* New PF for rep2fn modify, valid for mode 5. */
	uint16_t	new_pf_fid;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the q_ab field to be
	 * configured.
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_ENABLES_Q_AB_VALID      UINT32_C(0x1)
	/*
	 * This bit must be '1' for the q_ba field to be
	 * configured.
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_ENABLES_Q_BA_VALID      UINT32_C(0x2)
	/*
	 * This bit must be '1' for the fc_ab field to be
	 * configured.
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_ENABLES_FC_AB_VALID     UINT32_C(0x4)
	/*
	 * This bit must be '1' for the fc_ba field to be
	 * configured.
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_ENABLES_FC_BA_VALID     UINT32_C(0x8)
	/* VF Pair name (32 byte string). */
	char	pair_name[32];
	/*
	 * The q_ab value specifies the logical index of the TX/RX CoS
	 * queue to be assigned for traffic in the A to B direction of
	 * the interface pair. The default value is 0.
	 */
	uint8_t	q_ab;
	/*
	 * The q_ba value specifies the logical index of the TX/RX CoS
	 * queue to be assigned for traffic in the B to A direction of
	 * the interface pair. The default value is 1.
	 */
	uint8_t	q_ba;
	/*
	 * Specifies whether RX ring flow control is disabled (0) or enabled
	 * (1) in the A to B direction. The default value is 0, meaning that
	 * packets will be dropped when the B-side RX rings are full.
	 */
	uint8_t	fc_ab;
	/*
	 * Specifies whether RX ring flow control is disabled (0) or enabled
	 * (1) in the B to A direction. The default value is 1, meaning that
	 * the RX CoS queue will be flow controlled when the A-side RX rings
	 * are full.
	 */
	uint8_t	fc_ba;
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_cfa_pair_alloc_output (size:192b/24B) */
struct hwrm_cfa_pair_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Only valid for modes 1 and 2. */
	uint16_t	rx_cfa_code_a;
	/* Only valid for modes 1 and 2. */
	uint16_t	tx_cfa_action_a;
	/* Only valid for mode 2. */
	uint16_t	rx_cfa_code_b;
	/* Only valid for mode 2. */
	uint16_t	tx_cfa_action_b;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_cfa_pair_free *
 **********************/


/* hwrm_cfa_pair_free_input (size:448b/56B) */
struct hwrm_cfa_pair_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* VF Pair name (32 byte string). */
	char	pair_name[32];
	/* Logical PF (0xff-PF for command channel). */
	uint8_t	pf_b_id;
	uint8_t	unused_0[3];
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_id;
	/*
	 * Pair mode (0-vf2fn, 1-rep2fn, 2-rep2rep, 3-proxy, 4-pfpair,
	 *            5-rep2fn_mod, 6-rep2fn_modall, 7-rep2fn_truflow).
	 */
	uint16_t	pair_mode;
	/*
	 * Pair between VF on local host with PF or VF on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_VF2FN          UINT32_C(0x0)
	/*
	 * Pair between REP on local host with PF or VF on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2FN         UINT32_C(0x1)
	/*
	 * Pair between REP on local host with REP on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2REP        UINT32_C(0x2)
	/* Pair for the proxy interface. (deprecated) */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_PROXY          UINT32_C(0x3)
	/* Pair for the PF interface. (deprecated) */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_PFPAIR         UINT32_C(0x4)
	/* Modify existing rep2fn pair and move pair to new PF. (deprecated) */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2FN_MOD     UINT32_C(0x5)
	/*
	 * Modify existing rep2fn pairs paired with same PF and move pairs
	 * to new PF. (deprecated)
	 */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2FN_MODALL  UINT32_C(0x6)
	/*
	 * Truflow pair between REP on local host with PF or VF on
	 * specified host.
	 */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2FN_TRUFLOW UINT32_C(0x7)
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_LAST \
		HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2FN_TRUFLOW
} __rte_packed;

/* hwrm_cfa_pair_free_output (size:128b/16B) */
struct hwrm_cfa_pair_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_cfa_pair_info *
 **********************/


/* hwrm_cfa_pair_info_input (size:448b/56B) */
struct hwrm_cfa_pair_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* If this flag is set, lookup by name else lookup by index. */
	#define HWRM_CFA_PAIR_INFO_INPUT_FLAGS_LOOKUP_TYPE      UINT32_C(0x1)
	/* If this flag is set, lookup by PF id and VF id. */
	#define HWRM_CFA_PAIR_INFO_INPUT_FLAGS_LOOKUP_REPRE     UINT32_C(0x2)
	/* Pair table index. */
	uint16_t	pair_index;
	/* Pair pf index. */
	uint8_t	pair_pfid;
	/* Pair vf index. */
	uint8_t	pair_vfid;
	/* Pair name (32 byte string). */
	char	pair_name[32];
} __rte_packed;

/* hwrm_cfa_pair_info_output (size:576b/72B) */
struct hwrm_cfa_pair_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Pair table index. */
	uint16_t	next_pair_index;
	/* Pair member a's fid. */
	uint16_t	a_fid;
	/* Logical host number. */
	uint8_t	host_a_index;
	/* Logical PF number. */
	uint8_t	pf_a_index;
	/* Pair member a's Linux logical VF number. */
	uint16_t	vf_a_index;
	/* Rx CFA code. */
	uint16_t	rx_cfa_code_a;
	/* Tx CFA action. */
	uint16_t	tx_cfa_action_a;
	/* Pair member b's fid. */
	uint16_t	b_fid;
	/* Logical host number. */
	uint8_t	host_b_index;
	/* Logical PF number. */
	uint8_t	pf_b_index;
	/* Pair member a's Linux logical VF number. */
	uint16_t	vf_b_index;
	/* Rx CFA code. */
	uint16_t	rx_cfa_code_b;
	/* Tx CFA action. */
	uint16_t	tx_cfa_action_b;
	/* Pair mode (0-vf2fn, 1-rep2fn, 2-rep2rep, 3-proxy, 4-pfpair). */
	uint8_t	pair_mode;
	/*
	 * Pair between VF on local host with PF or VF on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_VF2FN   UINT32_C(0x0)
	/*
	 * Pair between REP on local host with PF or VF on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_REP2FN  UINT32_C(0x1)
	/*
	 * Pair between REP on local host with REP on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_REP2REP UINT32_C(0x2)
	/* Pair for the proxy interface. (deprecated) */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_PROXY   UINT32_C(0x3)
	/* Pair for the PF interface. (deprecated) */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_PFPAIR  UINT32_C(0x4)
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_LAST \
		HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_PFPAIR
	/* Pair state. */
	uint8_t	pair_state;
	/* Pair has been allocated */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_STATE_ALLOCATED UINT32_C(0x1)
	/* Both pair members are active */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_STATE_ACTIVE    UINT32_C(0x2)
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_STATE_LAST \
		HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_STATE_ACTIVE
	/* Pair name (32 byte string). */
	char	pair_name[32];
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_cfa_vfr_alloc *
 **********************/


/* hwrm_cfa_vfr_alloc_input (size:448b/56B) */
struct hwrm_cfa_vfr_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_id;
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint16_t	reserved;
	uint8_t	unused_0[4];
	/* VF Representor name (32 byte string). */
	char	vfr_name[32];
} __rte_packed;

/* hwrm_cfa_vfr_alloc_output (size:128b/16B) */
struct hwrm_cfa_vfr_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Rx CFA code. */
	uint16_t	rx_cfa_code;
	/* Tx CFA action. */
	uint16_t	tx_cfa_action;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_cfa_vfr_free *
 *********************/


/* hwrm_cfa_vfr_free_input (size:448b/56B) */
struct hwrm_cfa_vfr_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* VF Representor name (32 byte string). */
	char	vfr_name[32];
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_id;
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint16_t	reserved;
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_cfa_vfr_free_output (size:128b/16B) */
struct hwrm_cfa_vfr_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************************
 * hwrm_cfa_redirect_query_tunnel_type *
 ***************************************/


/* hwrm_cfa_redirect_query_tunnel_type_input (size:192b/24B) */
struct hwrm_cfa_redirect_query_tunnel_type_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The source function id. */
	uint16_t	src_fid;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_cfa_redirect_query_tunnel_type_output (size:128b/16B) */
struct hwrm_cfa_redirect_query_tunnel_type_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Tunnel Mask. */
	uint32_t	tunnel_mask;
	/* Non-tunnel */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_NONTUNNEL \
		UINT32_C(0x1)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_VXLAN \
		UINT32_C(0x2)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_NVGRE \
		UINT32_C(0x4)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_L2GRE \
		UINT32_C(0x8)
	/* IP in IP */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_IPIP \
		UINT32_C(0x10)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_GENEVE \
		UINT32_C(0x20)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_MPLS \
		UINT32_C(0x40)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_STT \
		UINT32_C(0x80)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_IPGRE \
		UINT32_C(0x100)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_VXLAN_V4 \
		UINT32_C(0x200)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_IPGRE_V1 \
		UINT32_C(0x400)
	/* Any tunneled traffic */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_ANYTUNNEL \
		UINT32_C(0x800)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_L2_ETYPE \
		UINT32_C(0x1000)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_VXLAN_GPE_V6 \
		UINT32_C(0x2000)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_VXLAN_GPE \
		UINT32_C(0x4000)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_cfa_ctx_mem_rgtr *
 *************************/


/* hwrm_cfa_ctx_mem_rgtr_input (size:256b/32B) */
struct hwrm_cfa_ctx_mem_rgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/* Counter PBL indirect levels. */
	uint8_t	page_level;
	/* PBL pointer is physical start address. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_0 UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_1 UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_2 UINT32_C(0x2)
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_LEVEL_LAST \
		HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_2
	/* Page size. */
	uint8_t	page_size;
	/* 4KB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_4K   UINT32_C(0x0)
	/* 8KB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_8K   UINT32_C(0x1)
	/* 64KB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_64K  UINT32_C(0x4)
	/* 256KB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_256K UINT32_C(0x6)
	/* 1MB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_1M   UINT32_C(0x8)
	/* 2MB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_2M   UINT32_C(0x9)
	/* 4MB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_4M   UINT32_C(0xa)
	/* 1GB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_1G   UINT32_C(0x12)
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_LAST \
		HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_1G
	uint32_t	unused_0;
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	page_dir;
} __rte_packed;

/* hwrm_cfa_ctx_mem_rgtr_output (size:128b/16B) */
struct hwrm_cfa_ctx_mem_rgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Id/Handle to the recently register context memory. This handle is
	 * passed to the CFA feature.
	 */
	uint16_t	ctx_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_cfa_ctx_mem_unrgtr *
 ***************************/


/* hwrm_cfa_ctx_mem_unrgtr_input (size:192b/24B) */
struct hwrm_cfa_ctx_mem_unrgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Id/Handle to the recently register context memory. This handle is
	 * passed to the CFA feature.
	 */
	uint16_t	ctx_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_cfa_ctx_mem_unrgtr_output (size:128b/16B) */
struct hwrm_cfa_ctx_mem_unrgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_cfa_ctx_mem_qctx *
 *************************/


/* hwrm_cfa_ctx_mem_qctx_input (size:192b/24B) */
struct hwrm_cfa_ctx_mem_qctx_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Id/Handle to the recently register context memory. This handle is
	 * passed to the CFA feature.
	 */
	uint16_t	ctx_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_cfa_ctx_mem_qctx_output (size:256b/32B) */
struct hwrm_cfa_ctx_mem_qctx_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint16_t	flags;
	/* Counter PBL indirect levels. */
	uint8_t	page_level;
	/* PBL pointer is physical start address. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_LEVEL_LVL_0 UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_LEVEL_LVL_1 UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_LEVEL_LVL_2 UINT32_C(0x2)
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_LEVEL_LAST \
		HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_LEVEL_LVL_2
	/* Page size. */
	uint8_t	page_size;
	/* 4KB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_4K   UINT32_C(0x0)
	/* 8KB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_8K   UINT32_C(0x1)
	/* 64KB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_64K  UINT32_C(0x4)
	/* 256KB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_256K UINT32_C(0x6)
	/* 1MB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_1M   UINT32_C(0x8)
	/* 2MB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_2M   UINT32_C(0x9)
	/* 4MB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_4M   UINT32_C(0xa)
	/* 1GB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_1G   UINT32_C(0x12)
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_LAST \
		HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_1G
	uint8_t	unused_0[4];
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	page_dir;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_cfa_ctx_mem_qcaps *
 **************************/


/* hwrm_cfa_ctx_mem_qcaps_input (size:128b/16B) */
struct hwrm_cfa_ctx_mem_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_cfa_ctx_mem_qcaps_output (size:128b/16B) */
struct hwrm_cfa_ctx_mem_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Indicates the maximum number of context memory which can be
	 * registered.
	 */
	uint16_t	max_entries;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_cfa_counter_qcaps *
 **************************/


/* hwrm_cfa_counter_qcaps_input (size:128b/16B) */
struct hwrm_cfa_counter_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_cfa_counter_qcaps_output (size:576b/72B) */
struct hwrm_cfa_counter_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/* Enumeration denoting the supported CFA counter format. */
	#define HWRM_CFA_COUNTER_QCAPS_OUTPUT_FLAGS_COUNTER_FORMAT \
		UINT32_C(0x1)
	/* CFA counter types are not supported. */
	#define HWRM_CFA_COUNTER_QCAPS_OUTPUT_FLAGS_COUNTER_FORMAT_NONE \
		UINT32_C(0x0)
	/* 64-bit packet counters followed by 64-bit byte counters format. */
	#define HWRM_CFA_COUNTER_QCAPS_OUTPUT_FLAGS_COUNTER_FORMAT_64_BIT \
		UINT32_C(0x1)
	#define HWRM_CFA_COUNTER_QCAPS_OUTPUT_FLAGS_COUNTER_FORMAT_LAST \
		HWRM_CFA_COUNTER_QCAPS_OUTPUT_FLAGS_COUNTER_FORMAT_64_BIT
	uint32_t	unused_0;
	/*
	 * Minimum guaranteed number of flow counters supported for this
	 * function, in RX direction.
	 */
	uint32_t	min_rx_fc;
	/*
	 * Maximum non-guaranteed number of flow counters supported for this
	 * function, in RX direction.
	 */
	uint32_t	max_rx_fc;
	/*
	 * Minimum guaranteed number of flow counters supported for this
	 * function, in TX direction.
	 */
	uint32_t	min_tx_fc;
	/*
	 * Maximum non-guaranteed number of flow counters supported for this
	 * function, in TX direction.
	 */
	uint32_t	max_tx_fc;
	/*
	 * Minimum guaranteed number of extension flow counters supported for
	 * this function, in RX direction.
	 */
	uint32_t	min_rx_efc;
	/*
	 * Maximum non-guaranteed number of extension flow counters supported
	 * for this function, in RX direction.
	 */
	uint32_t	max_rx_efc;
	/*
	 * Minimum guaranteed number of extension flow counters supported for
	 * this function, in TX direction.
	 */
	uint32_t	min_tx_efc;
	/*
	 * Maximum non-guaranteed number of extension flow counters supported
	 * for this function, in TX direction.
	 */
	uint32_t	max_tx_efc;
	/*
	 * Minimum guaranteed number of meter drop counters supported for
	 * this function, in RX direction.
	 */
	uint32_t	min_rx_mdc;
	/*
	 * Maximum non-guaranteed number of meter drop counters supported for
	 * this function, in RX direction.
	 */
	uint32_t	max_rx_mdc;
	/*
	 * Minimum guaranteed number of meter drop counters supported for this
	 * function, in TX direction.
	 */
	uint32_t	min_tx_mdc;
	/*
	 * Maximum non-guaranteed number of meter drop counters supported for
	 * this function, in TX direction.
	 */
	uint32_t	max_tx_mdc;
	/*
	 * Maximum guaranteed number of flow counters which can be used during
	 * flow alloc.
	 */
	uint32_t	max_flow_alloc_fc;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_cfa_counter_cfg *
 ************************/


/* hwrm_cfa_counter_cfg_input (size:256b/32B) */
struct hwrm_cfa_counter_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/* Enumeration denoting the configuration mode. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_CFG_MODE \
		UINT32_C(0x1)
	/* Disable the configuration mode. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_CFG_MODE_DISABLE \
		UINT32_C(0x0)
	/* Enable the configuration mode. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_CFG_MODE_ENABLE \
		UINT32_C(0x1)
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_CFG_MODE_LAST \
		HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_CFG_MODE_ENABLE
	/* Enumeration denoting the RX, TX type of the resource. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_PATH \
		UINT32_C(0x2)
	/* Tx path. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_PATH_TX \
		(UINT32_C(0x0) << 1)
	/* Rx path. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_PATH_RX \
		(UINT32_C(0x1) << 1)
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_PATH_LAST \
		HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_PATH_RX
	/* Enumeration denoting the data transfer mode. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_MASK \
		UINT32_C(0xc)
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_SFT       2
	/* Push mode. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_PUSH \
		(UINT32_C(0x0) << 2)
	/* Pull mode. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_PULL \
		(UINT32_C(0x1) << 2)
	/* Pull on async update. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_PULL_ASYNC \
		(UINT32_C(0x2) << 2)
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_LAST \
		HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_PULL_ASYNC
	uint16_t	counter_type;
	/* Flow counters. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_COUNTER_TYPE_FC  UINT32_C(0x0)
	/* Extended flow counters. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_COUNTER_TYPE_EFC UINT32_C(0x1)
	/* Meter drop counters. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_COUNTER_TYPE_MDC UINT32_C(0x2)
	#define HWRM_CFA_COUNTER_CFG_INPUT_COUNTER_TYPE_LAST \
		HWRM_CFA_COUNTER_CFG_INPUT_COUNTER_TYPE_MDC
	/* Ctx memory handle to be used for the counter. */
	uint16_t	ctx_id;
	/* Counter update cadence hint (only in Push mode). */
	uint16_t	update_tmr_ms;
	/* Total number of entries. */
	uint32_t	num_entries;
	uint32_t	unused_0;
} __rte_packed;

/* hwrm_cfa_counter_cfg_output (size:128b/16B) */
struct hwrm_cfa_counter_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_cfa_counter_qstats *
 ***************************/


/* hwrm_cfa_counter_qstats_input (size:320b/40B) */
struct hwrm_cfa_counter_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/* Enumeration denoting the RX, TX type of the resource. */
	#define HWRM_CFA_COUNTER_QSTATS_INPUT_FLAGS_PATH     UINT32_C(0x1)
	/* Tx path. */
	#define HWRM_CFA_COUNTER_QSTATS_INPUT_FLAGS_PATH_TX    UINT32_C(0x0)
	/* Rx path. */
	#define HWRM_CFA_COUNTER_QSTATS_INPUT_FLAGS_PATH_RX    UINT32_C(0x1)
	#define HWRM_CFA_COUNTER_QSTATS_INPUT_FLAGS_PATH_LAST \
		HWRM_CFA_COUNTER_QSTATS_INPUT_FLAGS_PATH_RX
	uint16_t	counter_type;
	uint16_t	input_flow_ctx_id;
	uint16_t	num_entries;
	uint16_t	delta_time_ms;
	uint16_t	meter_instance_id;
	uint16_t	mdc_ctx_id;
	uint8_t	unused_0[2];
	uint64_t	expected_count;
} __rte_packed;

/* hwrm_cfa_counter_qstats_output (size:128b/16B) */
struct hwrm_cfa_counter_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_cfa_eem_qcaps *
 **********************/


/* hwrm_cfa_eem_qcaps_input (size:192b/24B) */
struct hwrm_cfa_eem_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When set to 1, indicates the configuration will apply to TX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_rx bit can't be set.
	 */
	#define HWRM_CFA_EEM_QCAPS_INPUT_FLAGS_PATH_TX \
		UINT32_C(0x1)
	/*
	 * When set to 1, indicates the configuration will apply to RX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_tx bit can't be set.
	 */
	#define HWRM_CFA_EEM_QCAPS_INPUT_FLAGS_PATH_RX \
		UINT32_C(0x2)
	/* When set to 1, all offloaded flows will be sent to EEM. */
	#define HWRM_CFA_EEM_QCAPS_INPUT_FLAGS_PREFERRED_OFFLOAD \
		UINT32_C(0x4)
	uint32_t	unused_0;
} __rte_packed;

/* hwrm_cfa_eem_qcaps_output (size:320b/40B) */
struct hwrm_cfa_eem_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When set to 1, indicates the configuration will apply to TX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_rx bit can't be set.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_FLAGS_PATH_TX \
		UINT32_C(0x1)
	/*
	 * When set to 1, indicates the configuration will apply to RX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_tx bit can't be set.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_FLAGS_PATH_RX \
		UINT32_C(0x2)
	/*
	 * When set to 1, indicates the FW supports the Centralized
	 * Memory Model. The concept designates one entity for the
	 * memory allocation while all others subscribe to it.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_FLAGS_CENTRALIZED_MEMORY_MODEL_SUPPORTED \
		UINT32_C(0x4)
	/*
	 * When set to 1, indicates the FW supports the Detached
	 * Centralized Memory Model. The memory is allocated and managed
	 * as a separate entity. All PFs and VFs will be granted direct
	 * or semi-direct access to the allocated memory while none of
	 * which can interfere with the management of the memory.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_FLAGS_DETACHED_CENTRALIZED_MEMORY_MODEL_SUPPORTED \
		UINT32_C(0x8)
	uint32_t	unused_0;
	uint32_t	supported;
	/*
	 * If set to 1, then EEM KEY0 table is supported using crc32 hash.
	 * If set to 0, EEM KEY0 table is not supported.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_SUPPORTED_KEY0_TABLE \
		UINT32_C(0x1)
	/*
	 * If set to 1, then EEM KEY1 table is supported using lookup3 hash.
	 * If set to 0, EEM KEY1 table is not supported.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_SUPPORTED_KEY1_TABLE \
		UINT32_C(0x2)
	/*
	 * If set to 1, then EEM External Record table is supported.
	 * If set to 0, EEM External Record table is not supported.
	 * (This table includes action record, EFC pointers, encap pointers)
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_SUPPORTED_EXTERNAL_RECORD_TABLE \
		UINT32_C(0x4)
	/*
	 * If set to 1, then EEM External Flow Counters table is supported.
	 * If set to 0, EEM External Flow Counters table is not supported.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_SUPPORTED_EXTERNAL_FLOW_COUNTERS_TABLE \
		UINT32_C(0x8)
	/*
	 * If set to 1, then FID table used for implicit flow flush is
	 * supported.
	 * If set to 0, then FID table used for implicit flow flush is
	 * not supported.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_SUPPORTED_FID_TABLE \
		UINT32_C(0x10)
	/*
	 * The maximum number of entries supported by EEM. When configuring
	 * the host memory, the number of numbers of entries that can
	 * supported are:
	 *     32k, 64k 128k, 256k, 512k, 1M, 2M, 4M, 8M, 32M, 64M, 128M
	 *     entries.
	 * Any value that are not these values, the FW will round down to the
	 * closest support number of entries.
	 */
	uint32_t	max_entries_supported;
	/* The entry size in bytes of each entry in the EEM KEY0/KEY1 tables. */
	uint16_t	key_entry_size;
	/* The entry size in bytes of each entry in the EEM RECORD tables. */
	uint16_t	record_entry_size;
	/* The entry size in bytes of each entry in the EEM EFC tables. */
	uint16_t	efc_entry_size;
	/* The FID size in bytes of each entry in the EEM FID tables. */
	uint16_t	fid_entry_size;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/********************
 * hwrm_cfa_eem_cfg *
 ********************/


/* hwrm_cfa_eem_cfg_input (size:384b/48B) */
struct hwrm_cfa_eem_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When set to 1, indicates the configuration will apply to TX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_rx bit can't be set.
	 */
	#define HWRM_CFA_EEM_CFG_INPUT_FLAGS_PATH_TX \
		UINT32_C(0x1)
	/*
	 * When set to 1, indicates the configuration will apply to RX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_tx bit can't be set.
	 */
	#define HWRM_CFA_EEM_CFG_INPUT_FLAGS_PATH_RX \
		UINT32_C(0x2)
	/* When set to 1, all offloaded flows will be sent to EEM. */
	#define HWRM_CFA_EEM_CFG_INPUT_FLAGS_PREFERRED_OFFLOAD \
		UINT32_C(0x4)
	/* When set to 1, secondary, 0 means primary. */
	#define HWRM_CFA_EEM_CFG_INPUT_FLAGS_SECONDARY_PF \
		UINT32_C(0x8)
	/*
	 * Group_id which used by Firmware to identify memory pools belonging
	 * to certain group.
	 */
	uint16_t	group_id;
	uint16_t	unused_0;
	/*
	 * Configured EEM with the given number of entries. All the EEM tables
	 * KEY0, KEY1, RECORD, EFC all have the same number of entries and all
	 * tables will be configured using this value. Current minimum value
	 * is 32k. Current maximum value is 128M.
	 */
	uint32_t	num_entries;
	uint32_t	unused_1;
	/* Configured EEM with the given context if for KEY0 table. */
	uint16_t	key0_ctx_id;
	/* Configured EEM with the given context if for KEY1 table. */
	uint16_t	key1_ctx_id;
	/* Configured EEM with the given context if for RECORD table. */
	uint16_t	record_ctx_id;
	/* Configured EEM with the given context if for EFC table. */
	uint16_t	efc_ctx_id;
	/* Configured EEM with the given context if for EFC table. */
	uint16_t	fid_ctx_id;
	uint16_t	unused_2;
	uint32_t	unused_3;
} __rte_packed;

/* hwrm_cfa_eem_cfg_output (size:128b/16B) */
struct hwrm_cfa_eem_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_cfa_eem_qcfg *
 *********************/


/* hwrm_cfa_eem_qcfg_input (size:192b/24B) */
struct hwrm_cfa_eem_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* When set to 1, indicates the configuration is the TX flow. */
	#define HWRM_CFA_EEM_QCFG_INPUT_FLAGS_PATH_TX     UINT32_C(0x1)
	/* When set to 1, indicates the configuration is the RX flow. */
	#define HWRM_CFA_EEM_QCFG_INPUT_FLAGS_PATH_RX     UINT32_C(0x2)
	uint32_t	unused_0;
} __rte_packed;

/* hwrm_cfa_eem_qcfg_output (size:256b/32B) */
struct hwrm_cfa_eem_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/* When set to 1, indicates the configuration is the TX flow. */
	#define HWRM_CFA_EEM_QCFG_OUTPUT_FLAGS_PATH_TX \
		UINT32_C(0x1)
	/* When set to 1, indicates the configuration is the RX flow. */
	#define HWRM_CFA_EEM_QCFG_OUTPUT_FLAGS_PATH_RX \
		UINT32_C(0x2)
	/* When set to 1, all offloaded flows will be sent to EEM. */
	#define HWRM_CFA_EEM_QCFG_OUTPUT_FLAGS_PREFERRED_OFFLOAD \
		UINT32_C(0x4)
	/* The number of entries the FW has configured for EEM. */
	uint32_t	num_entries;
	/* Configured EEM with the given context if for KEY0 table. */
	uint16_t	key0_ctx_id;
	/* Configured EEM with the given context if for KEY1 table. */
	uint16_t	key1_ctx_id;
	/* Configured EEM with the given context if for RECORD table. */
	uint16_t	record_ctx_id;
	/* Configured EEM with the given context if for EFC table. */
	uint16_t	efc_ctx_id;
	/* Configured EEM with the given context if for EFC table. */
	uint16_t	fid_ctx_id;
	uint8_t	unused_2[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************
 * hwrm_cfa_eem_op *
 *******************/


/* hwrm_cfa_eem_op_input (size:192b/24B) */
struct hwrm_cfa_eem_op_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When set to 1, indicates the host memory which is passed will be
	 * used for the TX flow offload function specified in fid.
	 * Note if this bit is set then the path_rx bit can't be set.
	 */
	#define HWRM_CFA_EEM_OP_INPUT_FLAGS_PATH_TX     UINT32_C(0x1)
	/*
	 * When set to 1, indicates the host memory which is passed will be
	 * used for the RX flow offload function specified in fid.
	 * Note if this bit is set then the path_tx bit can't be set.
	 */
	#define HWRM_CFA_EEM_OP_INPUT_FLAGS_PATH_RX     UINT32_C(0x2)
	uint16_t	unused_0;
	/* The number of EEM key table entries to be configured. */
	uint16_t	op;
	/* This value is reserved and should not be used. */
	#define HWRM_CFA_EEM_OP_INPUT_OP_RESERVED    UINT32_C(0x0)
	/*
	 * To properly stop EEM and ensure there are no DMA's, the caller
	 * must disable EEM for the given PF, using this call. This will
	 * safely disable EEM and ensure that all DMA'ed to the
	 * keys/records/efc have been completed.
	 */
	#define HWRM_CFA_EEM_OP_INPUT_OP_EEM_DISABLE UINT32_C(0x1)
	/*
	 * Once the EEM host memory has been configured, EEM options have
	 * been configured. Then the caller should enable EEM for the given
	 * PF. Note once this call has been made, then the EEM mechanism
	 * will be active and DMA's will occur as packets are processed.
	 */
	#define HWRM_CFA_EEM_OP_INPUT_OP_EEM_ENABLE  UINT32_C(0x2)
	/*
	 * Clear EEM settings for the given PF so that the register values
	 * are reset back to there initial state.
	 */
	#define HWRM_CFA_EEM_OP_INPUT_OP_EEM_CLEANUP UINT32_C(0x3)
	#define HWRM_CFA_EEM_OP_INPUT_OP_LAST \
		HWRM_CFA_EEM_OP_INPUT_OP_EEM_CLEANUP
} __rte_packed;

/* hwrm_cfa_eem_op_output (size:128b/16B) */
struct hwrm_cfa_eem_op_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/********************************
 * hwrm_cfa_adv_flow_mgnt_qcaps *
 ********************************/


/* hwrm_cfa_adv_flow_mgnt_qcaps_input (size:256b/32B) */
struct hwrm_cfa_adv_flow_mgnt_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	unused_0[4];
} __rte_packed;

/* hwrm_cfa_adv_flow_mgnt_qcaps_output (size:128b/16B) */
struct hwrm_cfa_adv_flow_mgnt_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * Value of 1 to indicate firmware support 16-bit flow handle.
	 * Value of 0 to indicate firmware not support 16-bit flow handle.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_FLOW_HND_16BIT_SUPPORTED \
		UINT32_C(0x1)
	/*
	 * Value of 1 to indicate firmware support 64-bit flow handle.
	 * Value of 0 to indicate firmware not support 64-bit flow handle.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_FLOW_HND_64BIT_SUPPORTED \
		UINT32_C(0x2)
	/*
	 * Value of 1 to indicate firmware support flow batch delete
	 * operation through HWRM_CFA_FLOW_FLUSH command.
	 * Value of 0 to indicate that the firmware does not support flow
	 * batch delete operation. (deprecated)
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_FLOW_BATCH_DELETE_SUPPORTED \
		UINT32_C(0x4)
	/*
	 * Value of 1 to indicate that the firmware support flow reset all
	 * operation through HWRM_CFA_FLOW_FLUSH command.
	 * Value of 0 indicates firmware does not support flow reset all
	 * operation. (deprecated)
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_FLOW_RESET_ALL_SUPPORTED \
		UINT32_C(0x8)
	/*
	 * Value of 1 to indicate that firmware supports use of FID as
	 * dest_id in HWRM_CFA_NTUPLE_ALLOC/CFG commands.
	 * Value of 0 indicates firmware does not support use of FID as
	 * dest_id.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_NTUPLE_FLOW_DEST_FUNC_SUPPORTED \
		UINT32_C(0x10)
	/*
	 * Value of 1 to indicate that firmware supports TX EEM flows.
	 * Value of 0 indicates firmware does not support TX EEM flows.
	 * (deprecated)
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_TX_EEM_FLOW_SUPPORTED \
		UINT32_C(0x20)
	/*
	 * Value of 1 to indicate that firmware supports RX EEM flows.
	 * Value of 0 indicates firmware does not support RX EEM flows.
	 * (deprecated)
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_RX_EEM_FLOW_SUPPORTED \
		UINT32_C(0x40)
	/*
	 * Value of 1 to indicate that firmware supports the dynamic
	 * allocation of an on-chip flow counter which can be used for EEM
	 * flows. Value of 0 indicates firmware does not support the dynamic
	 * allocation of an on-chip flow counter.
	 * (deprecated)
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_FLOW_COUNTER_ALLOC_SUPPORTED \
		UINT32_C(0x80)
	/*
	 * Value of 1 to indicate that firmware supports setting of
	 * rfs_ring_tbl_idx in HWRM_CFA_NTUPLE_ALLOC command.
	 * Value of 0 indicates firmware does not support rfs_ring_tbl_idx.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_RFS_RING_TBL_IDX_SUPPORTED \
		UINT32_C(0x100)
	/*
	 * Value of 1 to indicate that firmware supports untagged matching
	 * criteria on HWRM_CFA_L2_FILTER_ALLOC command. Value of 0
	 * indicates firmware does not support untagged matching.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_UNTAGGED_VLAN_SUPPORTED \
		UINT32_C(0x200)
	/*
	 * Value of 1 to indicate that firmware supports XDP filter. Value
	 * of 0 indicates firmware does not support XDP filter.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_XDP_SUPPORTED \
		UINT32_C(0x400)
	/*
	 * Value of 1 to indicate that the firmware support L2 header source
	 * fields matching criteria on HWRM_CFA_L2_FILTER_ALLOC command.
	 * Value of 0 indicates firmware does not support L2 header source
	 * fields matching.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_L2_HEADER_SOURCE_FIELDS_SUPPORTED \
		UINT32_C(0x800)
	/*
	 * If set to 1, firmware is capable of supporting ARP ethertype as
	 * matching criteria for HWRM_CFA_NTUPLE_FILTER_ALLOC command on the
	 * RX direction. By default, this flag should be 0 for older version
	 * of firmware.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_NTUPLE_FLOW_RX_ARP_SUPPORTED \
		UINT32_C(0x1000)
	/*
	 * Value of 1 to indicate that firmware supports setting of
	 * rfs_ring_tbl_idx in dst_id field of the HWRM_CFA_NTUPLE_ALLOC
	 * command. Value of 0 indicates firmware does not support
	 * rfs_ring_tbl_idx in dst_id field.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_RFS_RING_TBL_IDX_V2_SUPPORTED \
		UINT32_C(0x2000)
	/*
	 * If set to 1, firmware is capable of supporting IPv4/IPv6 as
	 * ethertype in HWRM_CFA_NTUPLE_FILTER_ALLOC command on the RX
	 * direction. By default, this flag should be 0 for older version
	 * of firmware.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_NTUPLE_FLOW_RX_ETHERTYPE_IP_SUPPORTED \
		UINT32_C(0x4000)
	/*
	 * When this bit is '1', it indicates that core firmware is
	 * capable of TruFlow. Driver can restrict sending HWRM CFA_FLOW_XXX
	 * and CFA_ENCAP_XXX, CFA_DECAP_XXX commands.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_TRUFLOW_CAPABLE \
		UINT32_C(0x8000)
	/*
	 * If set to 1, firmware is capable of supporting L2/ROCE as
	 * traffic type in flags field of HWRM_CFA_L2_FILTER_ALLOC command.
	 * By default, this flag should be 0 for older version of firmware.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_L2_FILTER_TRAFFIC_TYPE_L2_ROCE_SUPPORTED \
		UINT32_C(0x10000)
	/*
	 * If set to 1, firmware is capable of HW LAG. This bit is only
	 * advertised if the calling function is a PAXC function.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_LAG_SUPPORTED \
		UINT32_C(0x20000)
	/*
	 * If set to 1, firmware is capable installing ntuple rules without
	 * additional classification on the L2 Context.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_NTUPLE_FLOW_NO_L2CTX_SUPPORTED \
		UINT32_C(0x40000)
	/*
	 * If set to 1, firmware is capable returning stats for nic flows
	 * in cfa_flow_stats command where flow_handle value 0xF000.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_NIC_FLOW_STATS_SUPPORTED \
		UINT32_C(0x80000)
	/*
	 * If set to 1, firmware is capable of supporting these additional
	 * ip_protoccols: ICMP, ICMPV6, RSVD for ntuple rules. By default,
	 * this flag should be 0 for older version of firmware.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_NTUPLE_FLOW_RX_EXT_IP_PROTO_SUPPORTED \
		UINT32_C(0x100000)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************
 * hwrm_cfa_tflib *
 ******************/


/* hwrm_cfa_tflib_input (size:1024b/128B) */
struct hwrm_cfa_tflib_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* TFLIB message type. */
	uint16_t	tf_type;
	/* TFLIB message subtype. */
	uint16_t	tf_subtype;
	/* unused. */
	uint8_t	unused0[4];
	/* TFLIB request data. */
	uint32_t	tf_req[26];
} __rte_packed;

/* hwrm_cfa_tflib_output (size:5632b/704B) */
struct hwrm_cfa_tflib_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* TFLIB message type. */
	uint16_t	tf_type;
	/* TFLIB message subtype. */
	uint16_t	tf_subtype;
	/* TFLIB response code */
	uint32_t	tf_resp_code;
	/* TFLIB response data. */
	uint32_t	tf_resp[170];
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************************
 * hwrm_cfa_lag_group_member_rgtr *
 **********************************/


/* hwrm_cfa_lag_group_member_rgtr_input (size:192b/24B) */
struct hwrm_cfa_lag_group_member_rgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	mode;
	/*
	 * Transmit only on the active port. Automatically failover
	 * to backup port.
	 */
	#define HWRM_CFA_LAG_GROUP_MEMBER_RGTR_INPUT_MODE_ACTIVE_BACKUP \
		UINT32_C(0x1)
	/*
	 * Transmit based on packet header ntuple hash. Packet with only
	 * layer 2 headers will hash using the destination MAC, source MAC
	 * and Ethertype fields.  Packets with layer 3 (IP) headers will
	 * hash using the destination MAC, source MAC, IP protocol/next
	 * header, source IP address and destination IP address. Packets
	 * with layer 4 (TCP/UDP) headers will hash using the destination
	 * MAC, source MAC, IP protocol/next header, source IP address,
	 * destination IP address, source port and destination port fields.
	 */
	#define HWRM_CFA_LAG_GROUP_MEMBER_RGTR_INPUT_MODE_BALANCE_XOR \
		UINT32_C(0x2)
	/* Transmit packets on all specified ports. */
	#define HWRM_CFA_LAG_GROUP_MEMBER_RGTR_INPUT_MODE_BROADCAST \
		UINT32_C(0x3)
	#define HWRM_CFA_LAG_GROUP_MEMBER_RGTR_INPUT_MODE_LAST \
		HWRM_CFA_LAG_GROUP_MEMBER_RGTR_INPUT_MODE_BROADCAST
	/*
	 * Supports up to 5 ports. bit0 = port 0, bit1 = port 1,
	 * bit2 = port 2, bit3 = port 4, bit4 = loopback port
	 */
	uint8_t	port_bitmap;
	/* Specify the active port when active-backup mode is specified */
	uint8_t	active_port;
	uint8_t	unused_0[5];
} __rte_packed;

/* hwrm_cfa_lag_group_member_rgtr_output (size:128b/16B) */
struct hwrm_cfa_lag_group_member_rgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* lag group ID configured for the function */
	uint16_t	lag_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************************
 * hwrm_cfa_lag_group_member_unrgtr *
 ************************************/


/* hwrm_cfa_lag_group_member_unrgtr_input (size:192b/24B) */
struct hwrm_cfa_lag_group_member_unrgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* lag group ID configured for the function */
	uint16_t	lag_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_cfa_lag_group_member_unrgtr_output (size:128b/16B) */
struct hwrm_cfa_lag_group_member_unrgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************************
 * hwrm_cfa_tls_filter_alloc *
 *****************************/


/* hwrm_cfa_tls_filter_alloc_input (size:704b/88B) */
struct hwrm_cfa_tls_filter_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	unused_0;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the l2_filter_id field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_L2_FILTER_ID \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the ethertype field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_ETHERTYPE \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the ipaddr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_IPADDR_TYPE \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the src_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_SRC_IPADDR \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the dst_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_DST_IPADDR \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the ip_protocol field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_IP_PROTOCOL \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the src_port field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_SRC_PORT \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the dst_port field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_DST_PORT \
		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the kid field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_KID \
		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_DST_ID \
		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID \
		UINT32_C(0x400)
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	uint8_t	unused_1[6];
	/* This value indicates the ethertype in the Ethernet header. */
	uint16_t	ethertype;
	/*
	 * This value indicates the type of IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	ip_addr_type;
	/* invalid */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_UNKNOWN \
		UINT32_C(0x0)
	/* IPv4 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV4 \
		UINT32_C(0x4)
	/* IPv6 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6 \
		UINT32_C(0x6)
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_LAST \
		HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6
	/*
	 * The value of protocol filed in IP header.
	 * Applies to UDP and TCP traffic.
	 * 6 - TCP
	 * 17 - UDP
	 */
	uint8_t	ip_protocol;
	/* invalid */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_PROTOCOL_UNKNOWN \
		UINT32_C(0x0)
	/* TCP */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_PROTOCOL_TCP \
		UINT32_C(0x6)
	/* UDP */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_PROTOCOL_UDP \
		UINT32_C(0x11)
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_PROTOCOL_LAST \
		HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_PROTOCOL_UDP
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and network port id of the destination port for
	 * the TX path.
	 */
	uint16_t	dst_id;
	/*
	 * Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint16_t	mirror_vnic_id;
	uint8_t	unused_2[2];
	/*
	 * The value of source IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	src_ipaddr[4];
	/*
	 * The value of destination IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	dst_ipaddr[4];
	/*
	 * The value of source port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	src_port;
	/*
	 * The value of destination port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	dst_port;
	/*
	 * The Key Context Identifier (KID) for use with KTLS.
	 * KID is limited to 20-bits.
	 */
	uint32_t	kid;
} __rte_packed;

/* hwrm_cfa_tls_filter_alloc_output (size:192b/24B) */
struct hwrm_cfa_tls_filter_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	tls_filter_id;
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK \
		UINT32_C(0x3fffffff)
	#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE \
		UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_INT \
		(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT \
		(UINT32_C(0x1) << 30)
	#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST \
		HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR \
		UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_RX \
		(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
	#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX \
		(UINT32_C(0x1) << 31)
	#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_LAST \
		HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/****************************
 * hwrm_cfa_tls_filter_free *
 ****************************/


/* hwrm_cfa_tls_filter_free_input (size:192b/24B) */
struct hwrm_cfa_tls_filter_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	tls_filter_id;
} __rte_packed;

/* hwrm_cfa_tls_filter_free_output (size:128b/16B) */
struct hwrm_cfa_tls_filter_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********
 * hwrm_tf *
 ***********/


/* hwrm_tf_input (size:1024b/128B) */
struct hwrm_tf_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* TF message type. */
	uint16_t	type;
	/* TF message subtype. */
	uint16_t	subtype;
	/* unused. */
	uint8_t	unused0[4];
	/* TF request data. */
	uint32_t	req[26];
} __rte_packed;

/* hwrm_tf_output (size:5632b/704B) */
struct hwrm_tf_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* TF message type. */
	uint16_t	type;
	/* TF message subtype. */
	uint16_t	subtype;
	/* TF response code */
	uint32_t	resp_code;
	/* TF response data. */
	uint32_t	resp[170];
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_tf_version_get *
 ***********************/


/* hwrm_tf_version_get_input (size:128b/16B) */
struct hwrm_tf_version_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_tf_version_get_output (size:256b/32B) */
struct hwrm_tf_version_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Version Major number. */
	uint8_t	major;
	/* Version Minor number. */
	uint8_t	minor;
	/* Version Update number. */
	uint8_t	update;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used to indicate device's capabilities and
	 * configurations.
	 */
	uint64_t	dev_caps_cfg;
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_tf_session_open *
 ************************/


/* hwrm_tf_session_open_input (size:640b/80B) */
struct hwrm_tf_session_open_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Name of the session. */
	uint8_t	session_name[64];
} __rte_packed;

/* hwrm_tf_session_open_output (size:192b/24B) */
struct hwrm_tf_session_open_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Unique session identifier for the session created by the
	 * firmware.
	 */
	uint32_t	fw_session_id;
	/*
	 * Unique session client identifier for the first client on
	 * the newly created session.
	 */
	uint32_t	fw_session_client_id;
	/* This field is used to return the status of fw session to host. */
	uint32_t	flags;
	/*
	 * Indicates if the shared session has been created. Shared session
	 * should be the first session created ever. Its fw_rm_client_id
	 * should be 1. The AFM session's fw_rm_client_id is 0.
	 */
	#define HWRM_TF_SESSION_OPEN_OUTPUT_FLAGS_SHARED_SESSION \
		UINT32_C(0x1)
	/*
	 * If this bit set to 0, then it indicates the shared session
	 * has been created by another session.
	 */
	#define HWRM_TF_SESSION_OPEN_OUTPUT_FLAGS_SHARED_SESSION_NOT_CREATOR \
		UINT32_C(0x0)
	/*
	 * If this bit is set to 1, then it indicates the shared session
	 * is created by this session.
	 */
	#define HWRM_TF_SESSION_OPEN_OUTPUT_FLAGS_SHARED_SESSION_CREATOR \
		UINT32_C(0x1)
	#define HWRM_TF_SESSION_OPEN_OUTPUT_FLAGS_SHARED_SESSION_LAST \
		HWRM_TF_SESSION_OPEN_OUTPUT_FLAGS_SHARED_SESSION_CREATOR
	/* unused. */
	uint8_t	unused1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_tf_session_attach *
 **************************/


/* hwrm_tf_session_attach_input (size:704b/88B) */
struct hwrm_tf_session_attach_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Unique session identifier for the session that the attach
	 * request want to attach to. This value originates from the
	 * shared session memory that the attach request opened by
	 * way of the 'attach name' that was passed in to the core
	 * attach API.
	 * The fw_session_id of the attach session includes PCIe bus
	 * info to distinguish the PF and session info to identify
	 * the associated TruFlow session.
	 */
	uint32_t	attach_fw_session_id;
	/* unused. */
	uint32_t	unused0;
	/* Name of the session it self. */
	uint8_t	session_name[64];
} __rte_packed;

/* hwrm_tf_session_attach_output (size:128b/16B) */
struct hwrm_tf_session_attach_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Unique session identifier for the session created by the
	 * firmware. It includes PCIe bus info to distinguish the PF
	 * and session info to identify the associated TruFlow
	 * session. This fw_session_id is unique to the attach
	 * request.
	 */
	uint32_t	fw_session_id;
	/* unused. */
	uint8_t	unused0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/****************************
 * hwrm_tf_session_register *
 ****************************/


/* hwrm_tf_session_register_input (size:704b/88B) */
struct hwrm_tf_session_register_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Unique session identifier for the session that the
	 * register request want to create a new client on. This
	 * value originates from the first open request.
	 * The fw_session_id of the attach session includes PCIe bus
	 * info to distinguish the PF and session info to identify
	 * the associated TruFlow session.
	 */
	uint32_t	fw_session_id;
	/* unused. */
	uint32_t	unused0;
	/* Name of the session client. */
	uint8_t	session_client_name[64];
} __rte_packed;

/* hwrm_tf_session_register_output (size:128b/16B) */
struct hwrm_tf_session_register_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Unique session client identifier for the session created
	 * by the firmware. It includes the session the client it
	 * attached to and session client info.
	 */
	uint32_t	fw_session_client_id;
	/* unused. */
	uint8_t	unused0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************************
 * hwrm_tf_session_unregister *
 ******************************/


/* hwrm_tf_session_unregister_input (size:192b/24B) */
struct hwrm_tf_session_unregister_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Unique session identifier for the session that the
	 * unregister request want to close a session client on.
	 */
	uint32_t	fw_session_id;
	/*
	 * Unique session client identifier for the session that the
	 * unregister request want to close.
	 */
	uint32_t	fw_session_client_id;
} __rte_packed;

/* hwrm_tf_session_unregister_output (size:128b/16B) */
struct hwrm_tf_session_unregister_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_tf_session_close *
 *************************/


/* hwrm_tf_session_close_input (size:192b/24B) */
struct hwrm_tf_session_close_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* unused. */
	uint8_t	unused0[4];
} __rte_packed;

/* hwrm_tf_session_close_output (size:128b/16B) */
struct hwrm_tf_session_close_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_tf_session_qcfg *
 ************************/


/* hwrm_tf_session_qcfg_input (size:192b/24B) */
struct hwrm_tf_session_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* unused. */
	uint8_t	unused0[4];
} __rte_packed;

/* hwrm_tf_session_qcfg_output (size:128b/16B) */
struct hwrm_tf_session_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* RX action control settings flags. */
	uint8_t	rx_act_flags;
	/*
	 * A value of 1 in this field indicates that Global Flow ID
	 * reporting into cfa_code and cfa_metadata is enabled.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_RX_ACT_FLAGS_ABCR_GFID_EN \
		UINT32_C(0x1)
	/*
	 * A value of 1 in this field indicates that both inner and outer
	 * are stripped and inner tag is passed.
	 * Enabled.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_RX_ACT_FLAGS_ABCR_VTAG_DLT_BOTH \
		UINT32_C(0x2)
	/*
	 * A value of 1 in this field indicates that the re-use of
	 * existing tunnel L2 header SMAC is enabled for
	 * Non-tunnel L2, L2-L3 and IP-IP tunnel.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_RX_ACT_FLAGS_TECT_SMAC_OVR_RUTNSL2 \
		UINT32_C(0x4)
	/* TX Action control settings flags. */
	uint8_t	tx_act_flags;
	/* Disabled. */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_TX_ACT_FLAGS_ABCR_VEB_EN \
		UINT32_C(0x1)
	/*
	 * When set to 1 any GRE tunnels will include the
	 * optional Key field.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_TX_ACT_FLAGS_TECT_GRE_SET_K \
		UINT32_C(0x2)
	/*
	 * When set to 1, for GRE tunnels, the IPV6 Traffic Class (TC)
	 * field of the outer header is inherited from the inner header
	 * (if present) or the fixed value as taken from the encap
	 * record.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_TX_ACT_FLAGS_TECT_IPV6_TC_IH \
		UINT32_C(0x4)
	/*
	 * When set to 1, for GRE tunnels, the IPV4 Type Of Service (TOS)
	 * field of the outer header is inherited from the inner header
	 * (if present) or the fixed value as taken from the encap record.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_TX_ACT_FLAGS_TECT_IPV4_TOS_IH \
		UINT32_C(0x8)
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************************
 * hwrm_tf_session_resc_qcaps *
 ******************************/


/* hwrm_tf_session_resc_qcaps_input (size:256b/32B) */
struct hwrm_tf_session_resc_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_RESC_QCAPS_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_SESSION_RESC_QCAPS_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_SESSION_RESC_QCAPS_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_SESSION_RESC_QCAPS_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_SESSION_RESC_QCAPS_INPUT_FLAGS_DIR_TX
	/*
	 * Defines the size of the provided qcaps_addr array
	 * buffer. The size should be set to the Resource Manager
	 * provided max number of qcaps entries which is device
	 * specific. Resource Manager gets the max size from HCAPI
	 * RM.
	 */
	uint16_t	qcaps_size;
	/*
	 * This is the DMA address for the qcaps output data array
	 * buffer. Array is of tf_rm_resc_req_entry type and is
	 * device specific.
	 */
	uint64_t	qcaps_addr;
} __rte_packed;

/* hwrm_tf_session_resc_qcaps_output (size:192b/24B) */
struct hwrm_tf_session_resc_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Control flags. */
	uint32_t	flags;
	/* Session reservation strategy. */
	#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_MASK \
		UINT32_C(0x3)
	#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_SFT \
		0
	/* Static partitioning. */
	#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_STATIC \
		UINT32_C(0x0)
	/* Strategy 1. */
	#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_1 \
		UINT32_C(0x1)
	/* Strategy 2. */
	#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_2 \
		UINT32_C(0x2)
	/* Strategy 3. */
	#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_3 \
		UINT32_C(0x3)
	#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_LAST \
		HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_3
	/*
	 * Size of the returned qcaps_addr data array buffer. The
	 * value cannot exceed the size defined by the input msg,
	 * qcaps_size.
	 */
	uint16_t	size;
	/*
	 * SRAM profile number that sets the partition of SRAM memory
	 * between TF and AFM within the 4 internal memory banks (Thor).
	 */
	uint8_t	sram_profile;
	/* unused. */
	uint8_t	unused0;
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************************
 * hwrm_tf_session_resc_alloc *
 ******************************/


/* hwrm_tf_session_resc_alloc_input (size:320b/40B) */
struct hwrm_tf_session_resc_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_RESC_ALLOC_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_SESSION_RESC_ALLOC_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_SESSION_RESC_ALLOC_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_SESSION_RESC_ALLOC_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_SESSION_RESC_ALLOC_INPUT_FLAGS_DIR_TX
	/*
	 * Defines the array size of the provided req_addr and
	 * resv_addr array buffers. Should be set to the number of
	 * request entries.
	 */
	uint16_t	req_size;
	/*
	 * This is the DMA address for the request input data array
	 * buffer. Array is of tf_rm_resc_req_entry type. Size of the
	 * array buffer is provided by the 'req_size' field in this
	 * message.
	 */
	uint64_t	req_addr;
	/*
	 * This is the DMA address for the resc output data array
	 * buffer. Array is of tf_rm_resc_entry type. Size of the array
	 * buffer is provided by the 'req_size' field in this
	 * message.
	 */
	uint64_t	resc_addr;
} __rte_packed;

/* hwrm_tf_session_resc_alloc_output (size:128b/16B) */
struct hwrm_tf_session_resc_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Size of the returned tf_rm_resc_entry data array. The value
	 * cannot exceed the req_size defined by the input msg. The data
	 * array is returned using the resv_addr specified DMA
	 * address also provided by the input msg.
	 */
	uint16_t	size;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************************
 * hwrm_tf_session_resc_free *
 *****************************/


/* hwrm_tf_session_resc_free_input (size:256b/32B) */
struct hwrm_tf_session_resc_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_RESC_FREE_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_SESSION_RESC_FREE_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_SESSION_RESC_FREE_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_SESSION_RESC_FREE_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_SESSION_RESC_FREE_INPUT_FLAGS_DIR_TX
	/*
	 * Defines the size, in bytes, of the provided free_addr
	 * buffer.
	 */
	uint16_t	free_size;
	/*
	 * This is the DMA address for the free input data array
	 * buffer.  Array is of tf_rm_resc_entry type. Size of the
	 * buffer is provided by the 'free_size' field of this
	 * message.
	 */
	uint64_t	free_addr;
} __rte_packed;

/* hwrm_tf_session_resc_free_output (size:128b/16B) */
struct hwrm_tf_session_resc_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************************
 * hwrm_tf_session_resc_flush *
 ******************************/


/* hwrm_tf_session_resc_flush_input (size:256b/32B) */
struct hwrm_tf_session_resc_flush_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_RESC_FLUSH_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_SESSION_RESC_FLUSH_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_SESSION_RESC_FLUSH_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_SESSION_RESC_FLUSH_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_SESSION_RESC_FLUSH_INPUT_FLAGS_DIR_TX
	/*
	 * Defines the size, in bytes, of the provided flush_addr
	 * buffer.
	 */
	uint16_t	flush_size;
	/*
	 * This is the DMA address for the flush input data array
	 * buffer.  Array of tf_rm_resc_entry type. Size of the
	 * buffer is provided by the 'flush_size' field in this
	 * message.
	 */
	uint64_t	flush_addr;
} __rte_packed;

/* hwrm_tf_session_resc_flush_output (size:128b/16B) */
struct hwrm_tf_session_resc_flush_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************************
 * hwrm_tf_session_resc_info *
 *****************************/


/* hwrm_tf_session_resc_info_input (size:320b/40B) */
struct hwrm_tf_session_resc_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_RESC_INFO_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_SESSION_RESC_INFO_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_SESSION_RESC_INFO_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_SESSION_RESC_INFO_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_SESSION_RESC_INFO_INPUT_FLAGS_DIR_TX
	/*
	 * Defines the array size of the provided req_addr and
	 * resv_addr array buffers. Should be set to the number of
	 * request entries.
	 */
	uint16_t	req_size;
	/*
	 * This is the DMA address for the request input data array
	 * buffer. Array is of tf_rm_resc_req_entry type. Size of the
	 * array buffer is provided by the 'req_size' field in this
	 * message.
	 */
	uint64_t	req_addr;
	/*
	 * This is the DMA address for the resc output data array
	 * buffer. Array is of tf_rm_resc_entry type. Size of the array
	 * buffer is provided by the 'req_size' field in this
	 * message.
	 */
	uint64_t	resc_addr;
} __rte_packed;

/* hwrm_tf_session_resc_info_output (size:128b/16B) */
struct hwrm_tf_session_resc_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Size of the returned tf_rm_resc_entry data array. The value
	 * cannot exceed the req_size defined by the input msg. The data
	 * array is returned using the resv_addr specified DMA
	 * address also provided by the input msg.
	 */
	uint16_t	size;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* TruFlow RM capability of a resource. */
/* tf_rm_resc_req_entry (size:64b/8B) */
struct tf_rm_resc_req_entry {
	/* Type of the resource, defined globally in HCAPI RM. */
	uint32_t	type;
	/* Minimum value. */
	uint16_t	min;
	/* Maximum value. */
	uint16_t	max;
} __rte_packed;

/* TruFlow RM reservation information. */
/* tf_rm_resc_entry (size:64b/8B) */
struct tf_rm_resc_entry {
	/* Type of the resource, defined globally in HCAPI RM. */
	uint32_t	type;
	/* Start offset. */
	uint16_t	start;
	/* Number of resources. */
	uint16_t	stride;
} __rte_packed;

/************************
 * hwrm_tf_tbl_type_get *
 ************************/


/* hwrm_tf_tbl_type_get_input (size:256b/32B) */
struct hwrm_tf_tbl_type_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_DIR \
		UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_DIR_RX \
		UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_DIR_TX \
		UINT32_C(0x1)
	#define HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_DIR_TX
	/*
	 * When set use the special access register access to clear
	 * the table entry on read.
	 */
	#define HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_CLEAR_ON_READ \
		UINT32_C(0x2)
	/* unused. */
	uint8_t	unused0[2];
	/*
	 * Type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of the type to retrieve. */
	uint32_t	index;
} __rte_packed;

/* hwrm_tf_tbl_type_get_output (size:2240b/280B) */
struct hwrm_tf_tbl_type_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Response code. */
	uint32_t	resp_code;
	/* Response size. */
	uint16_t	size;
	/* unused */
	uint16_t	unused0;
	/* Response data. */
	uint8_t	data[256];
	/* unused */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_tf_tbl_type_set *
 ************************/


/* hwrm_tf_tbl_type_set_input (size:1024b/128B) */
struct hwrm_tf_tbl_type_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DIR_TX
	/* Indicate table data is being sent via DMA. */
	#define HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DMA     UINT32_C(0x2)
	/* unused. */
	uint8_t	unused0[2];
	/*
	 * Type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of the type to retrieve. */
	uint32_t	index;
	/* Size of the data to set. */
	uint16_t	size;
	/* unused */
	uint8_t	unused1[6];
	/* Data to be set. */
	uint8_t	data[88];
} __rte_packed;

/* hwrm_tf_tbl_type_set_output (size:128b/16B) */
struct hwrm_tf_tbl_type_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_tf_ctxt_mem_alloc *
 **************************/


/* hwrm_tf_ctxt_mem_alloc_input (size:192b/24B) */
struct hwrm_tf_ctxt_mem_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Size in KB of memory to be allocated. */
	uint32_t	mem_size;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
} __rte_packed;

/* hwrm_tf_ctxt_mem_alloc_output (size:192b/24B) */
struct hwrm_tf_ctxt_mem_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	page_dir;
	/* Size of memory allocated. */
	uint32_t	mem_size;
	/* Counter PBL indirect levels. */
	uint8_t	page_level;
	/* PBL pointer is physical start address. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_LEVEL_LVL_0 UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_LEVEL_LVL_1 UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing
	 * to PTE tables.
	 */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_LEVEL_LVL_2 UINT32_C(0x2)
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_LEVEL_LAST \
		HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_LEVEL_LVL_2
	/* Page size. */
	uint8_t	page_size;
	/* 4KB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_4K   UINT32_C(0x0)
	/* 8KB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_8K   UINT32_C(0x1)
	/* 64KB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_64K  UINT32_C(0x4)
	/* 128KB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_128K UINT32_C(0x5)
	/* 256KB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_256K UINT32_C(0x6)
	/* 512KB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_512K UINT32_C(0x7)
	/* 1MB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_1M   UINT32_C(0x8)
	/* 2MB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_2M   UINT32_C(0x9)
	/* 4MB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_4M   UINT32_C(0xa)
	/* 8MB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_8M   UINT32_C(0xb)
	/* 1GB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_1G   UINT32_C(0x12)
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_LAST \
		HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_1G
	/* unused. */
	uint8_t	unused0;
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_tf_ctxt_mem_free *
 *************************/


/* hwrm_tf_ctxt_mem_free_input (size:320b/40B) */
struct hwrm_tf_ctxt_mem_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Counter PBL indirect levels. */
	uint8_t	page_level;
	/* PBL pointer is physical start address. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_LEVEL_LVL_0 UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_LEVEL_LVL_1 UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing
	 * to PTE tables.
	 */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_LEVEL_LVL_2 UINT32_C(0x2)
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_LEVEL_LAST \
		HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_LEVEL_LVL_2
	/* Page size. */
	uint8_t	page_size;
	/* 4KB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_4K   UINT32_C(0x0)
	/* 8KB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_8K   UINT32_C(0x1)
	/* 64KB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_64K  UINT32_C(0x4)
	/* 128KB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_128K UINT32_C(0x5)
	/* 256KB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_256K UINT32_C(0x6)
	/* 512KB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_512K UINT32_C(0x7)
	/* 1MB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_1M   UINT32_C(0x8)
	/* 2MB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_2M   UINT32_C(0x9)
	/* 4MB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_4M   UINT32_C(0xa)
	/* 8MB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_8M   UINT32_C(0xb)
	/* 1GB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_1G   UINT32_C(0x12)
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_LAST \
		HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_1G
	/* unused. */
	uint8_t	unused0[2];
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	page_dir;
	/* Size of memory allocated. */
	uint32_t	mem_size;
	/* unused. */
	uint8_t	unused1[4];
} __rte_packed;

/* hwrm_tf_ctxt_mem_free_output (size:128b/16B) */
struct hwrm_tf_ctxt_mem_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_tf_ctxt_mem_rgtr *
 *************************/


/* hwrm_tf_ctxt_mem_rgtr_input (size:256b/32B) */
struct hwrm_tf_ctxt_mem_rgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint16_t	flags;
	/* Counter PBL indirect levels. */
	uint8_t	page_level;
	/* PBL pointer is physical start address. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_0 UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_1 UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing
	 * to PTE tables.
	 */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_2 UINT32_C(0x2)
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_LEVEL_LAST \
		HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_2
	/* Page size. */
	uint8_t	page_size;
	/* 4KB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_4K   UINT32_C(0x0)
	/* 8KB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_8K   UINT32_C(0x1)
	/* 64KB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_64K  UINT32_C(0x4)
	/* 128KB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_128K UINT32_C(0x5)
	/* 256KB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_256K UINT32_C(0x6)
	/* 512KB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_512K UINT32_C(0x7)
	/* 1MB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_1M   UINT32_C(0x8)
	/* 2MB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_2M   UINT32_C(0x9)
	/* 4MB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_4M   UINT32_C(0xa)
	/* 8MB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_8M   UINT32_C(0xb)
	/* 1GB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_1G   UINT32_C(0x12)
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_LAST \
		HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_1G
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	page_dir;
} __rte_packed;

/* hwrm_tf_ctxt_mem_rgtr_output (size:128b/16B) */
struct hwrm_tf_ctxt_mem_rgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Id/Handle to the recently register context memory. This
	 * handle is passed to the TF session.
	 */
	uint16_t	ctx_id;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_tf_ctxt_mem_unrgtr *
 ***************************/


/* hwrm_tf_ctxt_mem_unrgtr_input (size:192b/24B) */
struct hwrm_tf_ctxt_mem_unrgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Id/Handle to the recently register context memory. This
	 * handle is passed to the TF session.
	 */
	uint16_t	ctx_id;
	/* unused. */
	uint8_t	unused0[2];
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
} __rte_packed;

/* hwrm_tf_ctxt_mem_unrgtr_output (size:128b/16B) */
struct hwrm_tf_ctxt_mem_unrgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_tf_ext_em_qcaps *
 ************************/


/* hwrm_tf_ext_em_qcaps_input (size:192b/24B) */
struct hwrm_tf_ext_em_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EXT_EM_QCAPS_INPUT_FLAGS_DIR \
		UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_EXT_EM_QCAPS_INPUT_FLAGS_DIR_RX \
		UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_EXT_EM_QCAPS_INPUT_FLAGS_DIR_TX \
		UINT32_C(0x1)
	#define HWRM_TF_EXT_EM_QCAPS_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_EXT_EM_QCAPS_INPUT_FLAGS_DIR_TX
	/* When set to 1, all offloaded flows will be sent to EXT EM. */
	#define HWRM_TF_EXT_EM_QCAPS_INPUT_FLAGS_PREFERRED_OFFLOAD \
		UINT32_C(0x2)
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
} __rte_packed;

/* hwrm_tf_ext_em_qcaps_output (size:384b/48B) */
struct hwrm_tf_ext_em_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When set to 1, indicates the FW supports the Centralized
	 * Memory Model. The concept designates one entity for the
	 * memory allocation while all others subscribe to it.
	 */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_FLAGS_CENTRALIZED_MEMORY_MODEL_SUPPORTED \
		UINT32_C(0x1)
	/*
	 * When set to 1, indicates the FW supports the Detached
	 * Centralized Memory Model. The memory is allocated and managed
	 * as a separate entity. All PFs and VFs will be granted direct
	 * or semi-direct access to the allocated memory while none of
	 * which can interfere with the management of the memory.
	 */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_FLAGS_DETACHED_CENTRALIZED_MEMORY_MODEL_SUPPORTED \
		UINT32_C(0x2)
	/* When set to 1, indicates FW support for host based EEM memory. */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_FLAGS_HOST_MEMORY_SUPPORTED \
		UINT32_C(0x4)
	/* When set to 1, indicates FW support for on-chip based EEM memory. */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_FLAGS_FW_MEMORY_SUPPORTED \
		UINT32_C(0x8)
	/* unused. */
	uint32_t	unused0;
	/* Support flags. */
	uint32_t	supported;
	/*
	 * If set to 1, then EXT EM KEY0 table is supported using
	 * crc32 hash.
	 * If set to 0, EXT EM KEY0 table is not supported.
	 */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_SUPPORTED_KEY0_TABLE \
		UINT32_C(0x1)
	/*
	 * If set to 1, then EXT EM KEY1 table is supported using
	 * lookup3 hash.
	 * If set to 0, EXT EM KEY1 table is not supported.
	 */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_SUPPORTED_KEY1_TABLE \
		UINT32_C(0x2)
	/*
	 * If set to 1, then EXT EM External Record table is supported.
	 * If set to 0, EXT EM External Record table is not
	 * supported.  (This table includes action record, EFC
	 * pointers, encap pointers)
	 */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_SUPPORTED_EXTERNAL_RECORD_TABLE \
		UINT32_C(0x4)
	/*
	 * If set to 1, then EXT EM External Flow Counters table is
	 * supported.
	 * If set to 0, EXT EM External Flow Counters table is not
	 * supported.
	 */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_SUPPORTED_EXTERNAL_FLOW_COUNTERS_TABLE \
		UINT32_C(0x8)
	/*
	 * If set to 1, then FID table used for implicit flow flush
	 * is supported.
	 * If set to 0, then FID table used for implicit flow flush
	 * is not supported.
	 */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_SUPPORTED_FID_TABLE \
		UINT32_C(0x10)
	/*
	 * If set to 1, then table scopes are supported.
	 * If set to 0, then table scopes are not supported.
	 */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_SUPPORTED_TBL_SCOPES \
		UINT32_C(0x20)
	/*
	 * The maximum number of entries supported by EXT EM. When
	 * configuring the host memory the number of numbers of
	 * entries that can supported are -
	 *      32k, 64k 128k, 256k, 512k, 1M, 2M, 4M, 8M, 32M, 64M,
	 *      128M entries.
	 * Any value that are not these values, the FW will round
	 * down to the closest support number of entries.
	 */
	uint32_t	max_entries_supported;
	/*
	 * The entry size in bytes of each entry in the EXT EM
	 * KEY0/KEY1 tables.
	 */
	uint16_t	key_entry_size;
	/*
	 * The entry size in bytes of each entry in the EXT EM RECORD
	 * tables.
	 */
	uint16_t	record_entry_size;
	/* The entry size in bytes of each entry in the EXT EM EFC tables. */
	uint16_t	efc_entry_size;
	/* The FID size in bytes of each entry in the EXT EM FID tables. */
	uint16_t	fid_entry_size;
	/* Maximum number of ctxt mem allocations allowed. */
	uint32_t	max_ctxt_mem_allocs;
	/*
	 * Maximum number of static buckets that can be assigned to lookup
	 * table scopes.
	 */
	uint32_t	max_static_buckets;
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_tf_ext_em_op *
 *********************/


/* hwrm_tf_ext_em_op_input (size:256b/32B) */
struct hwrm_tf_ext_em_op_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EXT_EM_OP_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_EXT_EM_OP_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_EXT_EM_OP_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_EXT_EM_OP_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_EXT_EM_OP_INPUT_FLAGS_DIR_TX
	/* unused. */
	uint16_t	unused0;
	/* The number of EXT EM key table entries to be configured. */
	uint16_t	op;
	/* This value is reserved and should not be used. */
	#define HWRM_TF_EXT_EM_OP_INPUT_OP_RESERVED       UINT32_C(0x0)
	/*
	 * To properly stop EXT EM and ensure there are no DMA's,
	 * the caller must disable EXT EM for the given PF, using
	 * this call. This will safely disable EXT EM and ensure
	 * that all DMA'ed to the keys/records/efc have been
	 * completed.
	 */
	#define HWRM_TF_EXT_EM_OP_INPUT_OP_EXT_EM_DISABLE UINT32_C(0x1)
	/*
	 * Once the EXT EM host memory has been configured, EXT EM
	 * options have been configured. Then the caller should
	 * enable EXT EM for the given PF. Note once this call has
	 * been made, then the EXT EM mechanism will be active and
	 * DMA's will occur as packets are processed.
	 */
	#define HWRM_TF_EXT_EM_OP_INPUT_OP_EXT_EM_ENABLE  UINT32_C(0x2)
	/*
	 * Clear EXT EM settings for the given PF so that the
	 * register values are reset back to their initial state.
	 */
	#define HWRM_TF_EXT_EM_OP_INPUT_OP_EXT_EM_CLEANUP UINT32_C(0x3)
	#define HWRM_TF_EXT_EM_OP_INPUT_OP_LAST \
		HWRM_TF_EXT_EM_OP_INPUT_OP_EXT_EM_CLEANUP
	/* unused. */
	uint16_t	unused1;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* unused. */
	uint32_t	unused2;
} __rte_packed;

/* hwrm_tf_ext_em_op_output (size:128b/16B) */
struct hwrm_tf_ext_em_op_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_tf_ext_em_cfg *
 **********************/


/* hwrm_tf_ext_em_cfg_input (size:512b/64B) */
struct hwrm_tf_ext_em_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EXT_EM_CFG_INPUT_FLAGS_DIR \
		UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_EXT_EM_CFG_INPUT_FLAGS_DIR_RX \
		UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_EXT_EM_CFG_INPUT_FLAGS_DIR_TX \
		UINT32_C(0x1)
	#define HWRM_TF_EXT_EM_CFG_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_EXT_EM_CFG_INPUT_FLAGS_DIR_TX
	/* When set to 1, all offloaded flows will be sent to EXT EM. */
	#define HWRM_TF_EXT_EM_CFG_INPUT_FLAGS_PREFERRED_OFFLOAD \
		UINT32_C(0x2)
	/* When set to 1, secondary, 0 means primary. */
	#define HWRM_TF_EXT_EM_CFG_INPUT_FLAGS_SECONDARY_PF \
		UINT32_C(0x4)
	/*
	 * Group_id which used by Firmware to identify memory pools belonging
	 * to certain group.
	 */
	uint16_t	group_id;
	/*
	 * Dynamically reconfigure EEM pending cache every 1/10th of second.
	 * If set to 0 it will disable the EEM HW flush of the pending cache.
	 */
	uint8_t	flush_interval;
	/* unused. */
	uint8_t	unused0;
	/*
	 * Configured EXT EM with the given number of entries. All
	 * the EXT EM tables KEY0, KEY1, RECORD, EFC all have the
	 * same number of entries and all tables will be configured
	 * using this value. Current minimum value is 32k. Current
	 * maximum value is 128M.
	 */
	uint32_t	num_entries;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the group_id field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_GROUP_ID \
		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the flush_interval field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_FLUSH_INTERVAL \
		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the num_entries field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_NUM_ENTRIES \
		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the key0_ctx_id field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_KEY0_CTX_ID \
		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the key1_ctx_id field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_KEY1_CTX_ID \
		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the record_ctx_id field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_RECORD_CTX_ID \
		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the efc_ctx_id field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_EFC_CTX_ID \
		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the fid_ctx_id field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_FID_CTX_ID \
		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the action_ctx_id field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_ACTION_CTX_ID \
		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the action_tbl_scope field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_ACTION_TBL_SCOPE \
		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the lkup_ctx_id field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_LKUP_CTX_ID \
		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the lkup_tbl_scope field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_LKUP_TBL_SCOPE \
		UINT32_C(0x800)
	/*
	 * This bit must be '1' for the lkup_static_buckets field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_LKUP_STATIC_BUCKETS \
		UINT32_C(0x1000)
	/* Configured EXT EM with the given context if for KEY0 table. */
	uint16_t	key0_ctx_id;
	/* Configured EXT EM with the given context if for KEY1 table. */
	uint16_t	key1_ctx_id;
	/* Configured EXT EM with the given context if for RECORD table. */
	uint16_t	record_ctx_id;
	/* Configured EXT EM with the given context if for EFC table. */
	uint16_t	efc_ctx_id;
	/* Configured EXT EM with the given context if for EFC table. */
	uint16_t	fid_ctx_id;
	/* Context id of action table scope. */
	uint16_t	action_ctx_id;
	/* Table scope id used for action record entries. */
	uint16_t	action_tbl_scope;
	/* Context id of lookup table scope. */
	uint16_t	lkup_ctx_id;
	/* Table scope id used for EM lookup entries. */
	uint16_t	lkup_tbl_scope;
	/* unused. */
	uint16_t	unused1;
	/*
	 * Number of 32B static buckets to be allocated at the beginning
	 * of table scope.
	 */
	uint32_t	lkup_static_buckets;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* unused. */
	uint32_t	unused2;
} __rte_packed;

/* hwrm_tf_ext_em_cfg_output (size:128b/16B) */
struct hwrm_tf_ext_em_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_tf_ext_em_qcfg *
 ***********************/


/* hwrm_tf_ext_em_qcfg_input (size:192b/24B) */
struct hwrm_tf_ext_em_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EXT_EM_QCFG_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_EXT_EM_QCFG_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_EXT_EM_QCFG_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_EXT_EM_QCFG_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_EXT_EM_QCFG_INPUT_FLAGS_DIR_TX
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
} __rte_packed;

/* hwrm_tf_ext_em_qcfg_output (size:448b/56B) */
struct hwrm_tf_ext_em_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_FLAGS_DIR \
		UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_FLAGS_DIR_RX \
		UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_FLAGS_DIR_TX \
		UINT32_C(0x1)
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_FLAGS_DIR_LAST \
		HWRM_TF_EXT_EM_QCFG_OUTPUT_FLAGS_DIR_TX
	/* When set to 1, all offloaded flows will be sent to EXT EM. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_FLAGS_PREFERRED_OFFLOAD \
		UINT32_C(0x2)
	/* The number of entries the FW has configured for EXT EM. */
	uint32_t	num_entries;
	/* Configured EXT EM with the given context if for KEY0 table. */
	uint16_t	key0_ctx_id;
	/* Configured EXT EM with the given context if for KEY1 table. */
	uint16_t	key1_ctx_id;
	/* Configured EXT EM with the given context if for RECORD table. */
	uint16_t	record_ctx_id;
	/* Configured EXT EM with the given context if for EFC table. */
	uint16_t	efc_ctx_id;
	/* Configured EXT EM with the given context if for EFC table. */
	uint16_t	fid_ctx_id;
	/* unused. */
	uint16_t	unused0;
	uint32_t	supported;
	/* This bit must be '1' for the group_id field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_GROUP_ID \
		UINT32_C(0x1)
	/* This bit must be '1' for the flush_interval field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_FLUSH_INTERVAL \
		UINT32_C(0x2)
	/* This bit must be '1' for the num_entries field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_NUM_ENTRIES \
		UINT32_C(0x4)
	/* This bit must be '1' for the key0_ctx_id field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_KEY0_CTX_ID \
		UINT32_C(0x8)
	/* This bit must be '1' for the key1_ctx_id field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_KEY1_CTX_ID \
		UINT32_C(0x10)
	/* This bit must be '1' for the record_ctx_id field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_RECORD_CTX_ID \
		UINT32_C(0x20)
	/* This bit must be '1' for the efc_ctx_id field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_EFC_CTX_ID \
		UINT32_C(0x40)
	/* This bit must be '1' for the fid_ctx_id field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_FID_CTX_ID \
		UINT32_C(0x80)
	/* This bit must be '1' for the action_ctx_id field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_ACTION_CTX_ID \
		UINT32_C(0x100)
	/* This bit must be '1' for the action_tbl_scope field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_ACTION_TBL_SCOPE \
		UINT32_C(0x200)
	/* This bit must be '1' for the lkup_ctx_id field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_LKUP_CTX_ID \
		UINT32_C(0x400)
	/* This bit must be '1' for the lkup_tbl_scope field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_LKUP_TBL_SCOPE \
		UINT32_C(0x800)
	/* This bit must be '1' for the lkup_static_buckets field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_LKUP_STATIC_BUCKETS \
		UINT32_C(0x1000)
	/*
	 * Group id is used by firmware to identify memory pools belonging
	 * to certain group.
	 */
	uint16_t	group_id;
	/* EEM pending cache flush interval in 1/10th of second. */
	uint8_t	flush_interval;
	/* unused. */
	uint8_t	unused1;
	/* Context id of action table scope. */
	uint16_t	action_ctx_id;
	/* Table scope id used for action record entries. */
	uint16_t	action_tbl_scope;
	/* Context id of lookup table scope. */
	uint16_t	lkup_ctx_id;
	/* Table scope id used for EM lookup entries. */
	uint16_t	lkup_tbl_scope;
	/*
	 * Number of 32B static buckets to be allocated at the beginning
	 * of table scope.
	 */
	uint32_t	lkup_static_buckets;
	/* unused. */
	uint8_t	unused2[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_tf_em_insert *
 *********************/


/* hwrm_tf_em_insert_input (size:832b/104B) */
struct hwrm_tf_em_insert_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware Session Id. */
	uint32_t	fw_session_id;
	/* Control Flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EM_INSERT_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_EM_INSERT_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_EM_INSERT_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_EM_INSERT_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_EM_INSERT_INPUT_FLAGS_DIR_TX
	/* Reported match strength. */
	uint16_t	strength;
	/* Index to action. */
	uint32_t	action_ptr;
	/* Index of EM record. */
	uint32_t	em_record_idx;
	/* EM Key value. */
	uint64_t	em_key[8];
	/* Number of bits in em_key. */
	uint16_t	em_key_bitlen;
	/* unused. */
	uint16_t	unused0[3];
} __rte_packed;

/* hwrm_tf_em_insert_output (size:128b/16B) */
struct hwrm_tf_em_insert_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* EM record pointer index. */
	uint16_t	rptr_index;
	/* EM record offset 0~3. */
	uint8_t	rptr_entry;
	/* Number of word entries consumed by the key. */
	uint8_t	num_of_entries;
	/* unused. */
	uint32_t	unused0;
} __rte_packed;

/**************************
 * hwrm_tf_em_hash_insert *
 **************************/


/* hwrm_tf_em_hash_insert_input (size:1024b/128B) */
struct hwrm_tf_em_hash_insert_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware Session Id. */
	uint32_t	fw_session_id;
	/* Control Flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EM_HASH_INSERT_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_EM_HASH_INSERT_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_EM_HASH_INSERT_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_EM_HASH_INSERT_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_EM_HASH_INSERT_INPUT_FLAGS_DIR_TX
	/* Number of bits in the EM record. */
	uint16_t	em_record_size_bits;
	/* CRC32 hash of key. */
	uint32_t	key0_hash;
	/* Lookup3 hash of key. */
	uint32_t	key1_hash;
	/* Index of EM record. */
	uint32_t	em_record_idx;
	/* Unused. */
	uint32_t	unused0;
	/* EM record. */
	uint64_t	em_record[11];
} __rte_packed;

/* hwrm_tf_em_hash_insert_output (size:128b/16B) */
struct hwrm_tf_em_hash_insert_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* EM record pointer index. */
	uint16_t	rptr_index;
	/* EM record offset 0~3. */
	uint8_t	rptr_entry;
	/* Number of word entries consumed by the key. */
	uint8_t	num_of_entries;
	/* unused. */
	uint32_t	unused0;
} __rte_packed;

/*********************
 * hwrm_tf_em_delete *
 *********************/


/* hwrm_tf_em_delete_input (size:832b/104B) */
struct hwrm_tf_em_delete_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Session Id. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EM_DELETE_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_EM_DELETE_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_EM_DELETE_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_EM_DELETE_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_EM_DELETE_INPUT_FLAGS_DIR_TX
	/* Unused0 */
	uint16_t	unused0;
	/* EM internal flow handle. */
	uint64_t	flow_handle;
	/* EM Key value */
	uint64_t	em_key[8];
	/* Number of bits in em_key. */
	uint16_t	em_key_bitlen;
	/* unused. */
	uint16_t	unused1[3];
} __rte_packed;

/* hwrm_tf_em_delete_output (size:128b/16B) */
struct hwrm_tf_em_delete_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Original stack allocation index. */
	uint16_t	em_index;
	/* unused. */
	uint16_t	unused0[3];
} __rte_packed;

/*******************
 * hwrm_tf_em_move *
 *******************/


/* hwrm_tf_em_move_input (size:320b/40B) */
struct hwrm_tf_em_move_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Session Id. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EM_MOVE_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_EM_MOVE_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_EM_MOVE_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_EM_MOVE_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_EM_MOVE_INPUT_FLAGS_DIR_TX
	/* Number of EM entry blocks */
	uint16_t	num_blocks;
	/* New index for entry */
	uint32_t	new_index;
	/* Unused */
	uint32_t	unused0;
	/* EM internal flow handle. */
	uint64_t	flow_handle;
} __rte_packed;

/* hwrm_tf_em_move_output (size:128b/16B) */
struct hwrm_tf_em_move_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Index of old entry. */
	uint16_t	em_index;
	/* unused. */
	uint16_t	unused0[3];
} __rte_packed;

/********************
 * hwrm_tf_tcam_set *
 ********************/


/* hwrm_tf_tcam_set_input (size:1024b/128B) */
struct hwrm_tf_tcam_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TCAM_SET_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_TCAM_SET_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_TCAM_SET_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_TCAM_SET_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_TCAM_SET_INPUT_FLAGS_DIR_TX
	/*
	 * Indicate device data is being sent via DMA, the device
	 * data is packing does not change.
	 */
	#define HWRM_TF_TCAM_SET_INPUT_FLAGS_DMA     UINT32_C(0x2)
	/*
	 * TCAM type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of TCAM entry. */
	uint16_t	idx;
	/* Number of bytes in the TCAM key. */
	uint8_t	key_size;
	/* Number of bytes in the TCAM result. */
	uint8_t	result_size;
	/*
	 * Offset from which the mask bytes start in the device data
	 * array, key offset is always 0.
	 */
	uint8_t	mask_offset;
	/* Offset from which the result bytes start in the device data array. */
	uint8_t	result_offset;
	/* unused. */
	uint8_t	unused0[6];
	/*
	 * TCAM key located at offset 0, mask located at mask_offset
	 * and result at result_offset for the device.
	 */
	uint8_t	dev_data[88];
} __rte_packed;

/* hwrm_tf_tcam_set_output (size:128b/16B) */
struct hwrm_tf_tcam_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/********************
 * hwrm_tf_tcam_get *
 ********************/


/* hwrm_tf_tcam_get_input (size:256b/32B) */
struct hwrm_tf_tcam_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TCAM_GET_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_TCAM_GET_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_TCAM_GET_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_TCAM_GET_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_TCAM_GET_INPUT_FLAGS_DIR_TX
	/*
	 * TCAM type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of a TCAM entry. */
	uint16_t	idx;
	/* unused. */
	uint16_t	unused0;
} __rte_packed;

/* hwrm_tf_tcam_get_output (size:2368b/296B) */
struct hwrm_tf_tcam_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of bytes in the TCAM key. */
	uint8_t	key_size;
	/* Number of bytes in the TCAM entry. */
	uint8_t	result_size;
	/* Offset from which the mask bytes start in the device data array. */
	uint8_t	mask_offset;
	/* Offset from which the result bytes start in the device data array. */
	uint8_t	result_offset;
	/* unused. */
	uint8_t	unused0[4];
	/*
	 * TCAM key located at offset 0, mask located at mask_offset
	 * and result at result_offset for the device.
	 */
	uint8_t	dev_data[272];
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_tf_tcam_move *
 *********************/


/* hwrm_tf_tcam_move_input (size:1024b/128B) */
struct hwrm_tf_tcam_move_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TCAM_MOVE_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_TCAM_MOVE_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_TCAM_MOVE_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_TCAM_MOVE_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_TCAM_MOVE_INPUT_FLAGS_DIR_TX
	/*
	 * TCAM type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Number of TCAM index pairs to be swapped for the device. */
	uint16_t	count;
	/* unused. */
	uint16_t	unused0;
	/* TCAM index pairs to be swapped for the device. */
	uint16_t	idx_pairs[48];
} __rte_packed;

/* hwrm_tf_tcam_move_output (size:128b/16B) */
struct hwrm_tf_tcam_move_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_tf_tcam_free *
 *********************/


/* hwrm_tf_tcam_free_input (size:1024b/128B) */
struct hwrm_tf_tcam_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TCAM_FREE_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_TCAM_FREE_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_TCAM_FREE_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_TCAM_FREE_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_TCAM_FREE_INPUT_FLAGS_DIR_TX
	/*
	 * TCAM type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Number of TCAM index to be deleted for the device. */
	uint16_t	count;
	/* unused. */
	uint16_t	unused0;
	/* TCAM index list to be deleted for the device. */
	uint16_t	idx_list[48];
} __rte_packed;

/* hwrm_tf_tcam_free_output (size:128b/16B) */
struct hwrm_tf_tcam_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_tf_global_cfg_set *
 **************************/


/* hwrm_tf_global_cfg_set_input (size:448b/56B) */
struct hwrm_tf_global_cfg_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_GLOBAL_CFG_SET_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_GLOBAL_CFG_SET_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_GLOBAL_CFG_SET_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_GLOBAL_CFG_SET_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_GLOBAL_CFG_SET_INPUT_FLAGS_DIR_TX
	/* Global Cfg type */
	uint32_t	type;
	/* Offset of the type */
	uint32_t	offset;
	/* Size of the data to set in bytes */
	uint16_t	size;
	/* unused. */
	uint8_t	unused0[6];
	/* Data to set */
	uint8_t	data[8];
	/* Mask of data to set, 0 indicates no mask */
	uint8_t	mask[8];
} __rte_packed;

/* hwrm_tf_global_cfg_set_output (size:128b/16B) */
struct hwrm_tf_global_cfg_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_tf_global_cfg_get *
 **************************/


/* hwrm_tf_global_cfg_get_input (size:320b/40B) */
struct hwrm_tf_global_cfg_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_GLOBAL_CFG_GET_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_GLOBAL_CFG_GET_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_GLOBAL_CFG_GET_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_GLOBAL_CFG_GET_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_GLOBAL_CFG_GET_INPUT_FLAGS_DIR_TX
	/* Global Cfg type */
	uint32_t	type;
	/* Offset of the type */
	uint32_t	offset;
	/* Size of the data to set in bytes */
	uint16_t	size;
	/* unused. */
	uint8_t	unused0[6];
} __rte_packed;

/* hwrm_tf_global_cfg_get_output (size:256b/32B) */
struct hwrm_tf_global_cfg_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Size of the data read in bytes */
	uint16_t	size;
	/* unused. */
	uint8_t	unused0[6];
	/* Data to set */
	uint8_t	data[16];
} __rte_packed;

/**********************
 * hwrm_tf_if_tbl_get *
 **********************/


/* hwrm_tf_if_tbl_get_input (size:256b/32B) */
struct hwrm_tf_if_tbl_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_IF_TBL_GET_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_IF_TBL_GET_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_IF_TBL_GET_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_IF_TBL_GET_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_IF_TBL_GET_INPUT_FLAGS_DIR_TX
	/* Size of the data to set. */
	uint16_t	size;
	/*
	 * Type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of the type to retrieve. */
	uint32_t	index;
} __rte_packed;

/* hwrm_tf_if_tbl_get_output (size:1216b/152B) */
struct hwrm_tf_if_tbl_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Response code. */
	uint32_t	resp_code;
	/* Response size. */
	uint16_t	size;
	/* unused */
	uint16_t	unused0;
	/* Response data. */
	uint8_t	data[128];
	/* unused */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_tf_if_tbl_type_set *
 ***************************/


/* hwrm_tf_if_tbl_set_input (size:1024b/128B) */
struct hwrm_tf_if_tbl_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_IF_TBL_SET_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_IF_TBL_SET_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_IF_TBL_SET_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TF_IF_TBL_SET_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_IF_TBL_SET_INPUT_FLAGS_DIR_TX
	/* unused. */
	uint8_t	unused0[2];
	/*
	 * Type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of the type to set. */
	uint32_t	index;
	/* Size of the data to set. */
	uint16_t	size;
	/* unused */
	uint8_t	unused1[6];
	/* Data to be set. */
	uint8_t	data[88];
} __rte_packed;

/* hwrm_tf_if_tbl_set_output (size:128b/16B) */
struct hwrm_tf_if_tbl_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************************
 * hwrm_tf_tbl_type_bulk_get *
 *****************************/


/* hwrm_tf_tbl_type_bulk_get_input (size:384b/48B) */
struct hwrm_tf_tbl_type_bulk_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_DIR \
		UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_DIR_RX \
		UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_DIR_TX \
		UINT32_C(0x1)
	#define HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_DIR_TX
	/*
	 * When set use the special access register access to clear
	 * the table entries on read.
	 */
	#define HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_CLEAR_ON_READ \
		UINT32_C(0x2)
	/* unused. */
	uint8_t	unused0[2];
	/*
	 * Type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Starting index of the type to retrieve. */
	uint32_t	start_index;
	/* Number of entries to retrieve. */
	uint32_t	num_entries;
	/* Number of entries to retrieve. */
	uint32_t	unused1;
	/* Host memory where data will be stored. */
	uint64_t	host_addr;
} __rte_packed;

/* hwrm_tf_tbl_type_bulk_get_output (size:128b/16B) */
struct hwrm_tf_tbl_type_bulk_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Response code. */
	uint32_t	resp_code;
	/* Response size. */
	uint16_t	size;
	/* unused */
	uint8_t	unused0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************************
 * hwrm_tf_session_hotup_state_set *
 ***********************************/


/* hwrm_tf_session_hotup_state_set_input (size:192b/24B) */
struct hwrm_tf_session_hotup_state_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Shared session state. */
	uint16_t	state;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_HOTUP_STATE_SET_INPUT_FLAGS_DIR \
		UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_SESSION_HOTUP_STATE_SET_INPUT_FLAGS_DIR_RX \
		UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_SESSION_HOTUP_STATE_SET_INPUT_FLAGS_DIR_TX \
		UINT32_C(0x1)
	#define HWRM_TF_SESSION_HOTUP_STATE_SET_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_SESSION_HOTUP_STATE_SET_INPUT_FLAGS_DIR_TX
} __rte_packed;

/* hwrm_tf_session_hotup_state_set_output (size:128b/16B) */
struct hwrm_tf_session_hotup_state_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************************
 * hwrm_tf_session_hotup_state_get *
 ***********************************/


/* hwrm_tf_session_hotup_state_get_input (size:192b/24B) */
struct hwrm_tf_session_hotup_state_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_HOTUP_STATE_GET_INPUT_FLAGS_DIR \
		UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TF_SESSION_HOTUP_STATE_GET_INPUT_FLAGS_DIR_RX \
		UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TF_SESSION_HOTUP_STATE_GET_INPUT_FLAGS_DIR_TX \
		UINT32_C(0x1)
	#define HWRM_TF_SESSION_HOTUP_STATE_GET_INPUT_FLAGS_DIR_LAST \
		HWRM_TF_SESSION_HOTUP_STATE_GET_INPUT_FLAGS_DIR_TX
	/* unused. */
	uint8_t	unused0[2];
} __rte_packed;

/* hwrm_tf_session_hotup_state_get_output (size:128b/16B) */
struct hwrm_tf_session_hotup_state_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Shared session HA state. */
	uint16_t	state;
	/* Shared session HA reference count. */
	uint16_t	ref_cnt;
	/* unused. */
	uint8_t	unused0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/****************************
 * hwrm_tfc_tbl_scope_qcaps *
 ****************************/


/*
 * TruFlow command to check if firmware is capable of
 * supporting table scopes.
 */
/* hwrm_tfc_tbl_scope_qcaps_input (size:128b/16B) */
struct hwrm_tfc_tbl_scope_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_tfc_tbl_scope_qcaps_output (size:192b/24B) */
struct hwrm_tfc_tbl_scope_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The maximum number of lookup records that a table scope can support.
	 * This field is only valid if tbl_scope_capable is not zero.
	 */
	uint32_t	max_lkup_rec_cnt;
	/*
	 * The maximum number of action records that a table scope can support.
	 * This field is only valid if tbl_scope_capable is not zero.
	 */
	uint32_t	max_act_rec_cnt;
	/* Not zero if firmware capable of table scopes. */
	uint8_t	tbl_scope_capable;
	/*
	 * log2 of the number of lookup static buckets that a table scope can
	 * support.  This field is only valid if tbl_scope_capable is not zero.
	 */
	uint8_t	max_lkup_static_buckets_exp;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************************
 * hwrm_tfc_tbl_scope_id_alloc *
 *******************************/


/*
 * TruFlow command to allocate a table scope ID and create the pools.
 *
 * There is no corresponding free command since a table scope
 * ID will automatically be freed once the last FID is removed.
 * That is, when the hwrm_tfc_tbl_scope_fid_rem command returns
 * a fid_cnt of 0 that also means that the table scope ID has
 * been freed.
 */
/* hwrm_tfc_tbl_scope_id_alloc_input (size:192b/24B) */
struct hwrm_tfc_tbl_scope_id_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The maximum number of pools for this table scope. */
	uint16_t	max_pools;
	/* Non-zero if this table scope is shared. */
	uint8_t	shared;
	/*
	 * The size of the lookup pools per direction expressed as
	 * log2(max_records/max_pools).  That is, size=2^exp.
	 *
	 * Array is indexed by enum cfa_dir.
	 */
	uint8_t	lkup_pool_sz_exp[2];
	/*
	 * The size of the action pools per direction expressed as
	 * log2(max_records/max_pools).  That is, size=2^exp.
	 *
	 * Array is indexed by enum cfa_dir.
	 */
	uint8_t	act_pool_sz_exp[2];
	/* unused. */
	uint8_t	unused0;
} __rte_packed;

/* hwrm_tfc_tbl_scope_id_alloc_output (size:128b/16B) */
struct hwrm_tfc_tbl_scope_id_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The table scope ID that was allocated. */
	uint8_t	tsid;
	/*
	 * Non-zero if this is the first FID associated with this table scope
	 * ID.
	 */
	uint8_t	first;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************************
 * hwrm_tfc_tbl_scope_config *
 *****************************/


/* TruFlow command to configure the table scope memory. */
/* hwrm_tfc_tbl_scope_config_input (size:704b/88B) */
struct hwrm_tfc_tbl_scope_config_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The base addresses for lookup memory.
	 * Array is indexed by enum cfa_dir.
	 */
	uint64_t	lkup_base_addr[2];
	/*
	 * The base addresses for action memory.
	 * Array is indexed by enum cfa_dir.
	 */
	uint64_t	act_base_addr[2];
	/*
	 * The number of minimum sized lkup records per direction.
	 * In this usage, records are the minimum lookup memory
	 * allocation unit in a table scope.  This value is the total
	 * memory required for buckets and entries.
	 *
	 * Array is indexed by enum cfa_dir.
	 */
	uint32_t	lkup_rec_cnt[2];
	/*
	 * The number of minimum sized action records per direction.
	 * Similar to the lkup_rec_cnt, records are the minimum
	 * action memory allocation unit in a table scope.
	 *
	 * Array is indexed by enum cfa_dir.
	 */
	uint32_t	act_rec_cnt[2];
	/*
	 * The number of static lookup buckets in the table scope.
	 * Array is indexed by enum cfa_dir.
	 */
	uint32_t	lkup_static_bucket_cnt[2];
	/* The page size of the table scope. */
	uint32_t	pbl_page_sz;
	/*
	 * The PBL level for lookup memory.
	 * Array is indexed by enum cfa_dir.
	 */
	uint8_t	lkup_pbl_level[2];
	/*
	 * The PBL level for action memory.
	 * Array is indexed by enum cfa_dir.
	 */
	uint8_t	act_pbl_level[2];
	/* The table scope ID. */
	uint8_t	tsid;
	/* unused. */
	uint8_t	unused0[7];
} __rte_packed;

/* hwrm_tfc_tbl_scope_config_output (size:128b/16B) */
struct hwrm_tfc_tbl_scope_config_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*******************************
 * hwrm_tfc_tbl_scope_deconfig *
 *******************************/


/* TruFlow command to deconfigure the table scope memory. */
/* hwrm_tfc_tbl_scope_deconfig_input (size:192b/24B) */
struct hwrm_tfc_tbl_scope_deconfig_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The table scope ID. */
	uint8_t	tsid;
	/* unused. */
	uint8_t	unused0[7];
} __rte_packed;

/* hwrm_tfc_tbl_scope_deconfig_output (size:128b/16B) */
struct hwrm_tfc_tbl_scope_deconfig_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************************
 * hwrm_tfc_tbl_scope_fid_add *
 ******************************/


/* TruFlow command to add a FID to a table scope. */
/* hwrm_tfc_tbl_scope_fid_add_input (size:192b/24B) */
struct hwrm_tfc_tbl_scope_fid_add_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The table scope ID. */
	uint8_t	tsid;
	/* unused. */
	uint8_t	unused0[7];
} __rte_packed;

/* hwrm_tfc_tbl_scope_fid_add_output (size:128b/16B) */
struct hwrm_tfc_tbl_scope_fid_add_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The number of FIDs currently in the table scope ID. */
	uint8_t	fid_cnt;
	/* unused. */
	uint8_t	unused0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************************
 * hwrm_tfc_tbl_scope_fid_rem *
 ******************************/


/* TruFlow command to remove a FID from a table scope. */
/* hwrm_tfc_tbl_scope_fid_rem_input (size:192b/24B) */
struct hwrm_tfc_tbl_scope_fid_rem_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The table scope ID. */
	uint8_t	tsid;
	/* unused. */
	uint8_t	unused0[7];
} __rte_packed;

/* hwrm_tfc_tbl_scope_fid_rem_output (size:128b/16B) */
struct hwrm_tfc_tbl_scope_fid_rem_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The number of FIDs remaining in the table scope ID. */
	uint16_t	fid_cnt;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************************
 * hwrm_tfc_tbl_scope_pool_alloc *
 *********************************/


/* hwrm_tfc_tbl_scope_pool_alloc_input (size:192b/24B) */
struct hwrm_tfc_tbl_scope_pool_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Table Scope ID */
	uint8_t	tsid;
	/* Control flags. Direction and type. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_TBL_SCOPE_POOL_ALLOC_INPUT_FLAGS_DIR \
		UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TFC_TBL_SCOPE_POOL_ALLOC_INPUT_FLAGS_DIR_RX \
		UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TFC_TBL_SCOPE_POOL_ALLOC_INPUT_FLAGS_DIR_TX \
		UINT32_C(0x1)
	#define HWRM_TFC_TBL_SCOPE_POOL_ALLOC_INPUT_FLAGS_DIR_LAST \
		HWRM_TFC_TBL_SCOPE_POOL_ALLOC_INPUT_FLAGS_DIR_TX
	/* Indicates the table type. */
	#define HWRM_TFC_TBL_SCOPE_POOL_ALLOC_INPUT_FLAGS_TYPE \
		UINT32_C(0x2)
	/* Lookup table */
	#define HWRM_TFC_TBL_SCOPE_POOL_ALLOC_INPUT_FLAGS_TYPE_LOOKUP \
		(UINT32_C(0x0) << 1)
	/* Action table */
	#define HWRM_TFC_TBL_SCOPE_POOL_ALLOC_INPUT_FLAGS_TYPE_ACTION \
		(UINT32_C(0x1) << 1)
	#define HWRM_TFC_TBL_SCOPE_POOL_ALLOC_INPUT_FLAGS_TYPE_LAST \
		HWRM_TFC_TBL_SCOPE_POOL_ALLOC_INPUT_FLAGS_TYPE_ACTION
	/* Unused */
	uint8_t	unused[6];
} __rte_packed;

/* hwrm_tfc_tbl_scope_pool_alloc_output (size:128b/16B) */
struct hwrm_tfc_tbl_scope_pool_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Pool ID */
	uint16_t	pool_id;
	/* Pool size exponent. An exponent of 0 indicates a failure. */
	uint8_t	pool_sz_exp;
	/* unused. */
	uint8_t	unused1[4];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/********************************
 * hwrm_tfc_tbl_scope_pool_free *
 ********************************/


/* hwrm_tfc_tbl_scope_pool_free_input (size:192b/24B) */
struct hwrm_tfc_tbl_scope_pool_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Table Scope ID */
	uint8_t	tsid;
	/* Control flags. Direction and type. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_TBL_SCOPE_POOL_FREE_INPUT_FLAGS_DIR \
		UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TFC_TBL_SCOPE_POOL_FREE_INPUT_FLAGS_DIR_RX \
		UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TFC_TBL_SCOPE_POOL_FREE_INPUT_FLAGS_DIR_TX \
		UINT32_C(0x1)
	#define HWRM_TFC_TBL_SCOPE_POOL_FREE_INPUT_FLAGS_DIR_LAST \
		HWRM_TFC_TBL_SCOPE_POOL_FREE_INPUT_FLAGS_DIR_TX
	/* Indicates the table type. */
	#define HWRM_TFC_TBL_SCOPE_POOL_FREE_INPUT_FLAGS_TYPE \
		UINT32_C(0x2)
	/* Lookup table */
	#define HWRM_TFC_TBL_SCOPE_POOL_FREE_INPUT_FLAGS_TYPE_LOOKUP \
		(UINT32_C(0x0) << 1)
	/* Action table */
	#define HWRM_TFC_TBL_SCOPE_POOL_FREE_INPUT_FLAGS_TYPE_ACTION \
		(UINT32_C(0x1) << 1)
	#define HWRM_TFC_TBL_SCOPE_POOL_FREE_INPUT_FLAGS_TYPE_LAST \
		HWRM_TFC_TBL_SCOPE_POOL_FREE_INPUT_FLAGS_TYPE_ACTION
	/* Pool ID */
	uint16_t	pool_id;
	/* Unused */
	uint8_t	unused[4];
} __rte_packed;

/* hwrm_tfc_tbl_scope_pool_free_output (size:128b/16B) */
struct hwrm_tfc_tbl_scope_pool_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************************
 * hwrm_tfc_session_id_alloc *
 *****************************/


/*
 * Allocate a TFC session. Requests the firmware to allocate a TFC
 * session identifier and associate a forwarding function with the
 * session.  Though there's not an explicit matching free for a session
 * id alloc, dis-associating the last fid from a session id (fid_cnt goes
 * to 0), will result in this session id being freed automatically.
 */
/* hwrm_tfc_session_id_alloc_input (size:128b/16B) */
struct hwrm_tfc_session_id_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_tfc_session_id_alloc_output (size:128b/16B) */
struct hwrm_tfc_session_id_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Unique session identifier for the session created by the
	 * firmware.
	 */
	uint16_t	sid;
	/* Unused field */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/****************************
 * hwrm_tfc_session_fid_add *
 ****************************/


/*
 * Associate a TFC session id with a forwarding function. The target_fid
 * will be associated with the passed in sid.
 */
/* hwrm_tfc_session_fid_add_input (size:192b/24B) */
struct hwrm_tfc_session_fid_add_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Unique session identifier for the session created by the
	 * firmware.
	 */
	uint16_t	sid;
	/* Unused field */
	uint8_t	unused0[6];
} __rte_packed;

/* hwrm_tfc_session_fid_add_output (size:128b/16B) */
struct hwrm_tfc_session_fid_add_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The number of FIDs that share this session. */
	uint16_t	fid_cnt;
	/* Unused field */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/****************************
 * hwrm_tfc_session_fid_rem *
 ****************************/


/*
 * Dis-associate a TFC session from the target_fid.
 * Though there's not an explicit matching free for a
 * session id alloc, dis-associating the last fid from a session id
 * (fid_cnt goes to 0), will result in this session id being freed
 * automatically.
 */
/* hwrm_tfc_session_fid_rem_input (size:192b/24B) */
struct hwrm_tfc_session_fid_rem_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Unique session identifier for the session created by the
	 * firmware.
	 */
	uint16_t	sid;
	/* Unused field */
	uint8_t	unused0[6];
} __rte_packed;

/* hwrm_tfc_session_fid_rem_output (size:128b/16B) */
struct hwrm_tfc_session_fid_rem_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The number of FIDs that share this session. */
	uint16_t	fid_cnt;
	/* Unused field */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_tfc_ident_alloc *
 ************************/


/*
 * Allocate a TFC identifier. Requests the firmware to
 * allocate a TFC identifier. The session id and track_type are passed
 * in. The tracking_id is either the sid or target_fid depends on the
 * track_type. The resource subtype is passed in, an id corresponding
 * to all these is allocated and returned in the HWRM response.
 */
/* hwrm_tfc_ident_alloc_input (size:192b/24B) */
struct hwrm_tfc_ident_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Unique session identifier for the session created by the
	 * firmware. Will be used to track this identifier.
	 */
	uint16_t	sid;
	/* Control flags. Direction. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IDENT_ALLOC_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TFC_IDENT_ALLOC_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TFC_IDENT_ALLOC_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TFC_IDENT_ALLOC_INPUT_FLAGS_DIR_LAST \
		HWRM_TFC_IDENT_ALLOC_INPUT_FLAGS_DIR_TX
	/*
	 * CFA resource subtype. For definitions, please see
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/* Describes the type of tracking tag to be used */
	uint8_t	track_type;
	/* Invalid track type */
	#define HWRM_TFC_IDENT_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_INVALID \
		UINT32_C(0x0)
	/* Tracked by session id */
	#define HWRM_TFC_IDENT_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_SID \
		UINT32_C(0x1)
	/* Tracked by function id */
	#define HWRM_TFC_IDENT_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_FID \
		UINT32_C(0x2)
	#define HWRM_TFC_IDENT_ALLOC_INPUT_TRACK_TYPE_LAST \
		HWRM_TFC_IDENT_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_FID
	/* Unused field */
	uint8_t	unused0[3];
} __rte_packed;

/* hwrm_tfc_ident_alloc_output (size:128b/16B) */
struct hwrm_tfc_ident_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Resource identifier allocated by the firmware using
	 * parameters above.
	 */
	uint16_t	ident_id;
	/* Unused field */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_tfc_ident_free *
 ***********************/


/*
 * Requests the firmware to free a TFC resource identifier.
 * A resource subtype and session id are passed in.
 * An identifier (previously allocated) corresponding to all these is
 * freed, only after various sanity checks are completed.
 */
/* hwrm_tfc_ident_free_input (size:192b/24B) */
struct hwrm_tfc_ident_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Unique session identifier for the session created by the
	 * firmware. Will be used to validate this request.
	 */
	uint16_t	sid;
	/*
	 * CFA resource subtype. For definitions, please see
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/* Control flags. Direction. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IDENT_FREE_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TFC_IDENT_FREE_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TFC_IDENT_FREE_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TFC_IDENT_FREE_INPUT_FLAGS_DIR_LAST \
		HWRM_TFC_IDENT_FREE_INPUT_FLAGS_DIR_TX
	/* The resource identifier to be freed */
	uint16_t	ident_id;
	/* Reserved */
	uint8_t	unused0[2];
} __rte_packed;

/* hwrm_tfc_ident_free_output (size:128b/16B) */
struct hwrm_tfc_ident_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Reserved */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_tfc_idx_tbl_alloc *
 **************************/


/* hwrm_tfc_idx_tbl_alloc_input (size:192b/24B) */
struct hwrm_tfc_idx_tbl_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Unique session id for the session created by the
	 * firmware. Will be used to track this index table entry
	 * only if track type is track_type_sid.
	 */
	uint16_t	sid;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_FLAGS_DIR_LAST \
		HWRM_TFC_IDX_TBL_ALLOC_INPUT_FLAGS_DIR_TX
	/*
	 * CFA resource subtype. For definitions, please see
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/* Describes the type of tracking id to be used */
	uint8_t	track_type;
	/* Invalid track type */
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_INVALID \
		UINT32_C(0x0)
	/* Tracked by session id */
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_SID \
		UINT32_C(0x1)
	/* Tracked by function id */
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_FID \
		UINT32_C(0x2)
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_TRACK_TYPE_LAST \
		HWRM_TFC_IDX_TBL_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_FID
	/* Reserved */
	uint8_t	unused0[3];
} __rte_packed;

/* hwrm_tfc_idx_tbl_alloc_output (size:128b/16B) */
struct hwrm_tfc_idx_tbl_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Index table entry allocated by the firmware using the
	 * parameters above.
	 */
	uint16_t	idx_tbl_id;
	/* Reserved */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************************
 * hwrm_tfc_idx_tbl_alloc_set *
 ******************************/


/* hwrm_tfc_idx_tbl_alloc_set_input (size:1088b/136B) */
struct hwrm_tfc_idx_tbl_alloc_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Unique session id for the session created by the
	 * firmware. Will be used to track this index table entry
	 * only if track type is track_type_sid.
	 */
	uint16_t	sid;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_FLAGS_DIR_LAST \
		HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_FLAGS_DIR_TX
	/*
	 * Indicate device data is being sent via DMA, the device
	 * data packing does not change.
	 */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_FLAGS_DMA     UINT32_C(0x2)
	/*
	 * CFA resource subtype. For definitions, please see
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/* Describes the type of tracking id to be used */
	uint8_t	track_type;
	/* Invalid track type */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_TRACK_TYPE_TRACK_TYPE_INVALID \
		UINT32_C(0x0)
	/* Tracked by session id */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_TRACK_TYPE_TRACK_TYPE_SID \
		UINT32_C(0x1)
	/* Tracked by function id */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_TRACK_TYPE_TRACK_TYPE_FID \
		UINT32_C(0x2)
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_TRACK_TYPE_LAST \
		HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_TRACK_TYPE_TRACK_TYPE_FID
	/* Reserved */
	uint8_t	unused0;
	/* The size of the index table entry in bytes. */
	uint16_t	data_size;
	/* The location of the dma buffer */
	uint64_t	dma_addr;
	/*
	 * Index table data located at offset 0.  If dma bit is set,
	 * then this field contains the DMA buffer pointer.
	 */
	uint8_t	dev_data[104];
} __rte_packed;

/* hwrm_tfc_idx_tbl_alloc_set_output (size:128b/16B) */
struct hwrm_tfc_idx_tbl_alloc_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Index table entry allocated by the firmware using the
	 * parameters above.
	 */
	uint16_t	idx_tbl_id;
	/* Reserved */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_tfc_idx_tbl_set *
 ************************/


/* hwrm_tfc_idx_tbl_set_input (size:1088b/136B) */
struct hwrm_tfc_idx_tbl_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IDX_TBL_SET_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TFC_IDX_TBL_SET_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TFC_IDX_TBL_SET_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TFC_IDX_TBL_SET_INPUT_FLAGS_DIR_LAST \
		HWRM_TFC_IDX_TBL_SET_INPUT_FLAGS_DIR_TX
	/*
	 * Indicate device data is being sent via DMA, the device
	 * data packing does not change.
	 */
	#define HWRM_TFC_IDX_TBL_SET_INPUT_FLAGS_DMA     UINT32_C(0x2)
	/*
	 * CFA resource subtype. For definitions, please see
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/*
	 * Session id associated with the firmware. Will be used
	 * for validation if the track type matches.
	 */
	uint16_t	sid;
	/*
	 * Index table index returned during alloc by the
	 * firmware.
	 */
	uint16_t	idx_tbl_id;
	/* The size of the index table entry in bytes. */
	uint16_t	data_size;
	/* The location of the dma buffer */
	uint64_t	dma_addr;
	/*
	 * Index table data located at offset 0.  If dma bit is set,
	 * then this field contains the DMA buffer pointer.
	 */
	uint8_t	dev_data[104];
} __rte_packed;

/* hwrm_tfc_idx_tbl_set_output (size:128b/16B) */
struct hwrm_tfc_idx_tbl_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_tfc_idx_tbl_get *
 ************************/


/* hwrm_tfc_idx_tbl_get_input (size:256b/32B) */
struct hwrm_tfc_idx_tbl_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IDX_TBL_GET_INPUT_FLAGS_DIR \
		UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TFC_IDX_TBL_GET_INPUT_FLAGS_DIR_RX \
		UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TFC_IDX_TBL_GET_INPUT_FLAGS_DIR_TX \
		UINT32_C(0x1)
	#define HWRM_TFC_IDX_TBL_GET_INPUT_FLAGS_DIR_LAST \
		HWRM_TFC_IDX_TBL_GET_INPUT_FLAGS_DIR_TX
	/*
	 * When set use the special access register access to clear
	 * the table entry on read.
	 */
	#define HWRM_TFC_IDX_TBL_GET_INPUT_FLAGS_CLEAR_ON_READ \
		UINT32_C(0x2)
	/*
	 * CFA resource subtype. For definitions, please see
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/*
	 * Session id associated with the firmware. Will be used
	 * for validation if the track type matches.
	 */
	uint16_t	sid;
	/*
	 * Index table index returned during alloc by the
	 * firmware.
	 */
	uint16_t	idx_tbl_id;
	/* The size of the index table entry buffer in bytes. */
	uint16_t	buffer_size;
	/* The location of the response dma buffer */
	uint64_t	dma_addr;
} __rte_packed;

/* hwrm_tfc_idx_tbl_get_output (size:128b/16B) */
struct hwrm_tfc_idx_tbl_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The size of the index table buffer returned in device size bytes. */
	uint16_t	data_size;
	/* unused */
	uint8_t	unused1[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_tfc_idx_tbl_free *
 *************************/


/* hwrm_tfc_idx_tbl_free_input (size:192b/24B) */
struct hwrm_tfc_idx_tbl_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IDX_TBL_FREE_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TFC_IDX_TBL_FREE_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TFC_IDX_TBL_FREE_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TFC_IDX_TBL_FREE_INPUT_FLAGS_DIR_LAST \
		HWRM_TFC_IDX_TBL_FREE_INPUT_FLAGS_DIR_TX
	/*
	 * CFA resource subtype. For definitions, please see
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/*
	 * Session id associated with the firmware. Will be used
	 * for validation if the track type matches.
	 */
	uint16_t	sid;
	/* Index table id to be freed by the firmware. */
	uint16_t	idx_tbl_id;
	/* Reserved */
	uint8_t	unused0[2];
} __rte_packed;

/* hwrm_tfc_idx_tbl_free_output (size:128b/16B) */
struct hwrm_tfc_idx_tbl_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Reserved */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* TruFlow resources request for a global id. */
/* tfc_global_id_hwrm_req (size:64b/8B) */
struct tfc_global_id_hwrm_req {
	/* Type of the resource, defined in enum cfa_resource_type HCAPI RM. */
	uint16_t	rtype;
	/* Indicates the flow direction in type of cfa_dir. */
	uint16_t	dir;
	/* Subtype of the resource type. */
	uint16_t	subtype;
	/* Number of the type of resources. */
	uint16_t	cnt;
} __rte_packed;

/* The reserved resources for the global id. */
/* tfc_global_id_hwrm_rsp (size:64b/8B) */
struct tfc_global_id_hwrm_rsp {
	/* Type of the resource, defined in enum cfa_resource_type HCAPI RM. */
	uint16_t	rtype;
	/* Indicates the flow direction in type of cfa_dir. */
	uint16_t	dir;
	/* Subtype of the resource type. */
	uint16_t	subtype;
	/* The global id that the resources reserved for. */
	uint16_t	id;
} __rte_packed;

/****************************
 * hwrm_tfc_global_id_alloc *
 ****************************/


/* hwrm_tfc_global_id_alloc_input (size:320b/40B) */
struct hwrm_tfc_global_id_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint16_t	sid;
	/* Global domain id. */
	uint16_t	global_id;
	/*
	 * Defines the array size of the provided req_addr and
	 * resv_addr array buffers. Should be set to the number of
	 * request entries.
	 */
	uint16_t	req_cnt;
	/* unused. */
	uint8_t	unused0[2];
	/*
	 * This is the DMA address for the request input data array
	 * buffer. Array is of tfc_global_id_hwrm_req type. Size of the
	 * array buffer is provided by the 'req_cnt' field in this
	 * message.
	 */
	uint64_t	req_addr;
	/*
	 * This is the DMA address for the resc output data array
	 * buffer. Array is of tfc_global_id_hwrm_rsp type. Size of the array
	 * buffer is provided by the 'req_cnt' field in this
	 * message.
	 */
	uint64_t	resc_addr;
} __rte_packed;

/* hwrm_tfc_global_id_alloc_output (size:128b/16B) */
struct hwrm_tfc_global_id_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Size of the returned hwrm_tfc_global_id_req data array. The value
	 * cannot exceed the req_cnt defined by the input msg. The data
	 * array is returned using the resv_addr specified DMA
	 * address also provided by the input msg.
	 */
	uint16_t	rsp_cnt;
	/* Non-zero if this is the first allocation for the global ID. */
	uint8_t	first;
	/* unused. */
	uint8_t	unused0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_tfc_tcam_set *
 *********************/


/* hwrm_tfc_tcam_set_input (size:1088b/136B) */
struct hwrm_tfc_tcam_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Session id associated with the firmware. Will be used
	 * for validation if the track type matches.
	 */
	uint16_t	sid;
	/* Logical TCAM ID. */
	uint16_t	tcam_id;
	/* Number of bytes in the TCAM key. */
	uint16_t	key_size;
	/* Number of bytes in the TCAM result. */
	uint16_t	result_size;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_TCAM_SET_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TFC_TCAM_SET_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TFC_TCAM_SET_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TFC_TCAM_SET_INPUT_FLAGS_DIR_LAST \
		HWRM_TFC_TCAM_SET_INPUT_FLAGS_DIR_TX
	/* Indicate device data is being sent via DMA. */
	#define HWRM_TFC_TCAM_SET_INPUT_FLAGS_DMA     UINT32_C(0x2)
	/*
	 * Subtype of TCAM resource. See
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/* unused. */
	uint8_t	unused0[6];
	/* The location of the response dma buffer */
	uint64_t	dma_addr;
	/*
	 * TCAM key located at offset 0, mask located at mask_offset
	 * and result at result_offset for the device.
	 */
	uint8_t	dev_data[96];
} __rte_packed;

/* hwrm_tfc_tcam_set_output (size:128b/16B) */
struct hwrm_tfc_tcam_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_tfc_tcam_get *
 *********************/


/* hwrm_tfc_tcam_get_input (size:192b/24B) */
struct hwrm_tfc_tcam_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_TCAM_GET_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TFC_TCAM_GET_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TFC_TCAM_GET_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TFC_TCAM_GET_INPUT_FLAGS_DIR_LAST \
		HWRM_TFC_TCAM_GET_INPUT_FLAGS_DIR_TX
	/*
	 * Subtype of TCAM resource See
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/*
	 * Session id associated with the firmware. Will be used
	 * for validation if the track type matches.
	 */
	uint16_t	sid;
	/* Logical TCAM ID. */
	uint16_t	tcam_id;
	/* unused. */
	uint8_t	unused0[2];
} __rte_packed;

/* hwrm_tfc_tcam_get_output (size:2368b/296B) */
struct hwrm_tfc_tcam_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of bytes in the TCAM key. */
	uint16_t	key_size;
	/* Number of bytes in the TCAM result. */
	uint16_t	result_size;
	/* unused. */
	uint8_t	unused0[4];
	/*
	 * TCAM key located at offset 0, mask located at key_size
	 * and result at 2 * key_size for the device.
	 */
	uint8_t	dev_data[272];
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_tfc_tcam_alloc *
 ***********************/


/* hwrm_tfc_tcam_alloc_input (size:256b/32B) */
struct hwrm_tfc_tcam_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_TCAM_ALLOC_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TFC_TCAM_ALLOC_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TFC_TCAM_ALLOC_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TFC_TCAM_ALLOC_INPUT_FLAGS_DIR_LAST \
		HWRM_TFC_TCAM_ALLOC_INPUT_FLAGS_DIR_TX
	/*
	 * Subtype of TCAM resource. See
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/*
	 * Unique session id for the session created by the
	 * firmware. Will be used to track this index table entry
	 * only if track type is track_type_sid.
	 */
	uint16_t	sid;
	/* Number of bytes in the TCAM key. */
	uint16_t	key_size;
	/* Entry priority. */
	uint16_t	priority;
	/* Describes the type of tracking id to be used */
	uint8_t	track_type;
	/* Invalid track type */
	#define HWRM_TFC_TCAM_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_INVALID \
		UINT32_C(0x0)
	/* Tracked by session id */
	#define HWRM_TFC_TCAM_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_SID \
		UINT32_C(0x1)
	/* Tracked by function id */
	#define HWRM_TFC_TCAM_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_FID \
		UINT32_C(0x2)
	#define HWRM_TFC_TCAM_ALLOC_INPUT_TRACK_TYPE_LAST \
		HWRM_TFC_TCAM_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_FID
	/* Unused. */
	uint8_t	unused0[7];
} __rte_packed;

/* hwrm_tfc_tcam_alloc_output (size:128b/16B) */
struct hwrm_tfc_tcam_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Index table entry allocated by the firmware using the
	 * parameters above.
	 */
	uint16_t	idx;
	/* Reserved */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_tfc_tcam_alloc_set *
 ***************************/


/* hwrm_tfc_tcam_alloc_set_input (size:1088b/136B) */
struct hwrm_tfc_tcam_alloc_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_FLAGS_DIR_LAST \
		HWRM_TFC_TCAM_ALLOC_SET_INPUT_FLAGS_DIR_TX
	/* Indicate device data is being sent via DMA. */
	#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_FLAGS_DMA     UINT32_C(0x2)
	/*
	 * Subtype of TCAM resource. See
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/*
	 * Unique session id for the session created by the
	 * firmware. Will be used to track this index table entry
	 * only if track type is track_type_sid.
	 */
	uint16_t	sid;
	/* Number of bytes in the TCAM key. */
	uint16_t	key_size;
	/* The size of the TCAM table entry in bytes. */
	uint16_t	result_size;
	/* Entry priority. */
	uint16_t	priority;
	/* Describes the type of tracking id to be used */
	uint8_t	track_type;
	/* Invalid track type */
	#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_TRACK_TYPE_TRACK_TYPE_INVALID \
		UINT32_C(0x0)
	/* Tracked by session id */
	#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_TRACK_TYPE_TRACK_TYPE_SID \
		UINT32_C(0x1)
	/* Tracked by function id */
	#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_TRACK_TYPE_TRACK_TYPE_FID \
		UINT32_C(0x2)
	#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_TRACK_TYPE_LAST \
		HWRM_TFC_TCAM_ALLOC_SET_INPUT_TRACK_TYPE_TRACK_TYPE_FID
	/* Unused */
	uint8_t	unused[5];
	/* The location of the response dma buffer */
	uint64_t	dma_addr;
	/*
	 * Index table data located at offset 0.  If dma bit is set,
	 * then this field contains the DMA buffer pointer.
	 */
	uint8_t	dev_data[96];
} __rte_packed;

/* hwrm_tfc_tcam_alloc_set_output (size:128b/16B) */
struct hwrm_tfc_tcam_alloc_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Logical TCAM ID. */
	uint16_t	tcam_id;
	/* Reserved */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_tfc_tcam_free *
 **********************/


/* hwrm_tfc_tcam_free_input (size:192b/24B) */
struct hwrm_tfc_tcam_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_TCAM_FREE_INPUT_FLAGS_DIR     UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
	#define HWRM_TFC_TCAM_FREE_INPUT_FLAGS_DIR_RX    UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
	#define HWRM_TFC_TCAM_FREE_INPUT_FLAGS_DIR_TX    UINT32_C(0x1)
	#define HWRM_TFC_TCAM_FREE_INPUT_FLAGS_DIR_LAST \
		HWRM_TFC_TCAM_FREE_INPUT_FLAGS_DIR_TX
	/*
	 * Subtype of TCAM resource. See
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/*
	 * Session id associated with the firmware. Will be used
	 * for validation if the track type matches.
	 */
	uint16_t	sid;
	/* Logical TCAM ID. */
	uint16_t	tcam_id;
	/* Reserved */
	uint8_t	unused0[2];
} __rte_packed;

/* hwrm_tfc_tcam_free_output (size:128b/16B) */
struct hwrm_tfc_tcam_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Reserved */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************************
 * hwrm_tunnel_dst_port_query *
 ******************************/


/* hwrm_tunnel_dst_port_query_input (size:192b/24B) */
struct hwrm_tunnel_dst_port_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_VXLAN \
		UINT32_C(0x1)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_GENEVE \
		UINT32_C(0x5)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_VXLAN_V4 \
		UINT32_C(0x9)
	/* Enhance Generic Routing Encapsulation (GRE version 1) inside IP datagram payload */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_IPGRE_V1 \
		UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_L2_ETYPE \
		UINT32_C(0xb)
	/* IPV6 over virtual eXtensible Local Area Network with GPE header (IPV6oVXLANGPE) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 \
		UINT32_C(0xc)
	/* Custom GRE uses UPAR to parse customized GRE packets */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_CUSTOM_GRE \
		UINT32_C(0xd)
	/* Enhanced Common Packet Radio Interface (eCPRI) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_ECPRI \
		UINT32_C(0xe)
	/* IPv6 Segment Routing (SRv6) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_SRV6 \
		UINT32_C(0xf)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_VXLAN_GPE \
		UINT32_C(0x10)
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_LAST \
		HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_VXLAN_GPE
	uint8_t	unused_0[7];
} __rte_packed;

/* hwrm_tunnel_dst_port_query_output (size:128b/16B) */
struct hwrm_tunnel_dst_port_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field represents the identifier of L4 destination port
	 * used for the given tunnel type. This field is valid for
	 * specific tunnel types that use layer 4 (e.g. UDP)
	 * transports for tunneling.
	 */
	uint16_t	tunnel_dst_port_id;
	/*
	 * This field represents the value of L4 destination port
	 * identified by tunnel_dst_port_id. This field is valid for
	 * specific tunnel types that use layer 4 (e.g. UDP)
	 * transports for tunneling.
	 * This field is in network byte order.
	 *
	 * A value of 0 means that the destination port is not
	 * configured.
	 */
	uint16_t	tunnel_dst_port_val;
	/*
	 * This field represents the UPAR usage status.
	 * Available UPARs on wh+ are UPAR0 and UPAR1
	 * Available UPARs on Thor are UPAR0 to UPAR3
	 * Available UPARs on Thor2 are UPAR0 to UPAR7
	 */
	uint8_t	upar_in_use;
	/* This bit will be '1' when UPAR0 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_UPAR_IN_USE_UPAR0 \
		UINT32_C(0x1)
	/* This bit will be '1' when UPAR1 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_UPAR_IN_USE_UPAR1 \
		UINT32_C(0x2)
	/* This bit will be '1' when UPAR2 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_UPAR_IN_USE_UPAR2 \
		UINT32_C(0x4)
	/* This bit will be '1' when UPAR3 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_UPAR_IN_USE_UPAR3 \
		UINT32_C(0x8)
	/* This bit will be '1' when UPAR4 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_UPAR_IN_USE_UPAR4 \
		UINT32_C(0x10)
	/* This bit will be '1' when UPAR5 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_UPAR_IN_USE_UPAR5 \
		UINT32_C(0x20)
	/* This bit will be '1' when UPAR6 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_UPAR_IN_USE_UPAR6 \
		UINT32_C(0x40)
	/* This bit will be '1' when UPAR7 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_UPAR_IN_USE_UPAR7 \
		UINT32_C(0x80)
	uint8_t	unused_0[2];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************************
 * hwrm_tunnel_dst_port_alloc *
 ******************************/


/* hwrm_tunnel_dst_port_alloc_input (size:192b/24B) */
struct hwrm_tunnel_dst_port_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_VXLAN \
		UINT32_C(0x1)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_GENEVE \
		UINT32_C(0x5)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4 \
		UINT32_C(0x9)
	/* Enhance Generic Routing Encapsulation (GRE version 1) inside IP datagram payload */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1 \
		UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE \
		UINT32_C(0xb)
	/* IPV6 over virtual eXtensible Local Area Network with GPE header (IPV6oVXLANGPE) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 \
		UINT32_C(0xc)
	/* Custom GRE uses UPAR to parse customized GRE packets. This is not supported. */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_CUSTOM_GRE \
		UINT32_C(0xd)
	/* Enhanced Common Packet Radio Interface (eCPRI) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_ECPRI \
		UINT32_C(0xe)
	/* IPv6 Segment Routing (SRv6) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_SRV6 \
		UINT32_C(0xf)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE \
		UINT32_C(0x10)
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_LAST \
		HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE
	uint8_t	unused_0;
	/*
	 * This field represents the value of L4 destination port used
	 * for the given tunnel type. This field is valid for
	 * specific tunnel types that use layer 4 (e.g. UDP)
	 * transports for tunneling.
	 *
	 * This field is in network byte order.
	 *
	 * A value of 0 shall fail the command.
	 */
	uint16_t	tunnel_dst_port_val;
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_tunnel_dst_port_alloc_output (size:128b/16B) */
struct hwrm_tunnel_dst_port_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Identifier of a tunnel L4 destination port value. Only applies to tunnel
	 * types that has l4 destination port parameters.
	 */
	uint16_t	tunnel_dst_port_id;
	/* Error information */
	uint8_t	error_info;
	/* No error */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_ERROR_INFO_SUCCESS \
		UINT32_C(0x0)
	/* Tunnel port is already allocated */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_ERROR_INFO_ERR_ALLOCATED \
		UINT32_C(0x1)
	/* Out of resources error */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_ERROR_INFO_ERR_NO_RESOURCE \
		UINT32_C(0x2)
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_ERROR_INFO_LAST \
		HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_ERROR_INFO_ERR_NO_RESOURCE
	/*
	 * This field represents the UPAR usage status.
	 * Available UPARs on wh+ are UPAR0 and UPAR1
	 * Available UPARs on Thor are UPAR0 to UPAR3
	 * Available UPARs on Thor2 are UPAR0 to UPAR7
	 */
	uint8_t	upar_in_use;
	/* This bit will be '1' when UPAR0 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_UPAR_IN_USE_UPAR0 \
		UINT32_C(0x1)
	/* This bit will be '1' when UPAR1 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_UPAR_IN_USE_UPAR1 \
		UINT32_C(0x2)
	/* This bit will be '1' when UPAR2 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_UPAR_IN_USE_UPAR2 \
		UINT32_C(0x4)
	/* This bit will be '1' when UPAR3 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_UPAR_IN_USE_UPAR3 \
		UINT32_C(0x8)
	/* This bit will be '1' when UPAR4 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_UPAR_IN_USE_UPAR4 \
		UINT32_C(0x10)
	/* This bit will be '1' when UPAR5 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_UPAR_IN_USE_UPAR5 \
		UINT32_C(0x20)
	/* This bit will be '1' when UPAR6 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_UPAR_IN_USE_UPAR6 \
		UINT32_C(0x40)
	/* This bit will be '1' when UPAR7 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_UPAR_IN_USE_UPAR7 \
		UINT32_C(0x80)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************************
 * hwrm_tunnel_dst_port_free *
 *****************************/


/* hwrm_tunnel_dst_port_free_input (size:192b/24B) */
struct hwrm_tunnel_dst_port_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_VXLAN \
		UINT32_C(0x1)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_GENEVE \
		UINT32_C(0x5)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_VXLAN_V4 \
		UINT32_C(0x9)
	/* Enhance Generic Routing Encapsulation (GRE version 1) inside IP datagram payload */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_IPGRE_V1 \
		UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_L2_ETYPE \
		UINT32_C(0xb)
	/* IPV6 over virtual eXtensible Local Area Network with GPE header (IPV6oVXLANGPE) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 \
		UINT32_C(0xc)
	/* Custom GRE uses UPAR to parse customized GRE packets. This is not supported. */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_CUSTOM_GRE \
		UINT32_C(0xd)
	/* Enhanced Common Packet Radio Interface (eCPRI) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_ECPRI \
		UINT32_C(0xe)
	/* IPv6 Segment Routing (SRv6) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_SRV6 \
		UINT32_C(0xf)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_VXLAN_GPE \
		UINT32_C(0x10)
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_LAST \
		HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_VXLAN_GPE
	uint8_t	unused_0;
	/*
	 * Identifier of a tunnel L4 destination port value. Only applies to tunnel
	 * types that has l4 destination port parameters.
	 */
	uint16_t	tunnel_dst_port_id;
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_tunnel_dst_port_free_output (size:128b/16B) */
struct hwrm_tunnel_dst_port_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Error information */
	uint8_t	error_info;
	/* No error */
	#define HWRM_TUNNEL_DST_PORT_FREE_OUTPUT_ERROR_INFO_SUCCESS \
		UINT32_C(0x0)
	/* Not owner error */
	#define HWRM_TUNNEL_DST_PORT_FREE_OUTPUT_ERROR_INFO_ERR_NOT_OWNER \
		UINT32_C(0x1)
	/* Not allocated error */
	#define HWRM_TUNNEL_DST_PORT_FREE_OUTPUT_ERROR_INFO_ERR_NOT_ALLOCATED \
		UINT32_C(0x2)
	#define HWRM_TUNNEL_DST_PORT_FREE_OUTPUT_ERROR_INFO_LAST \
		HWRM_TUNNEL_DST_PORT_FREE_OUTPUT_ERROR_INFO_ERR_NOT_ALLOCATED
	uint8_t	unused_1[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* Periodic statistics context DMA to host. */
/* ctx_hw_stats (size:1280b/160B) */
struct ctx_hw_stats {
	/* Number of received unicast packets */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets */
	uint64_t	rx_bcast_pkts;
	/* Number of discarded packets on receive path */
	uint64_t	rx_discard_pkts;
	/* Number of packets on receive path with error */
	uint64_t	rx_error_pkts;
	/* Number of received bytes for unicast traffic */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic */
	uint64_t	rx_bcast_bytes;
	/* Number of transmitted unicast packets */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets */
	uint64_t	tx_bcast_pkts;
	/* Number of packets on transmit path with error */
	uint64_t	tx_error_pkts;
	/* Number of discarded packets on transmit path */
	uint64_t	tx_discard_pkts;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	tx_bcast_bytes;
	/* Number of TPA packets */
	uint64_t	tpa_pkts;
	/* Number of TPA bytes */
	uint64_t	tpa_bytes;
	/* Number of TPA events */
	uint64_t	tpa_events;
	/* Number of TPA aborts */
	uint64_t	tpa_aborts;
} __rte_packed;

/*
 * Extended periodic statistics context DMA to host. On cards that
 * support TPA v2, additional TPA related stats exist and can be retrieved
 * by DMA of ctx_hw_stats_ext, rather than legacy ctx_hw_stats structure.
 */
/* ctx_hw_stats_ext (size:1408b/176B) */
struct ctx_hw_stats_ext {
	/* Number of received unicast packets */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets */
	uint64_t	rx_bcast_pkts;
	/* Number of discarded packets on receive path */
	uint64_t	rx_discard_pkts;
	/* Number of packets on receive path with error */
	uint64_t	rx_error_pkts;
	/* Number of received bytes for unicast traffic */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic */
	uint64_t	rx_bcast_bytes;
	/* Number of transmitted unicast packets */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets */
	uint64_t	tx_bcast_pkts;
	/* Number of packets on transmit path with error */
	uint64_t	tx_error_pkts;
	/* Number of discarded packets on transmit path */
	uint64_t	tx_discard_pkts;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	tx_bcast_bytes;
	/* Number of TPA eligible packets */
	uint64_t	rx_tpa_eligible_pkt;
	/* Number of TPA eligible bytes */
	uint64_t	rx_tpa_eligible_bytes;
	/* Number of TPA packets */
	uint64_t	rx_tpa_pkt;
	/* Number of TPA bytes */
	uint64_t	rx_tpa_bytes;
	/* Number of TPA errors */
	uint64_t	rx_tpa_errors;
	/* Number of TPA events */
	uint64_t	rx_tpa_events;
} __rte_packed;

/* Periodic Engine statistics context DMA to host. */
/* ctx_eng_stats (size:512b/64B) */
struct ctx_eng_stats {
	/*
	 * Count of data bytes into the Engine.
	 * This includes any user supplied prefix,
	 * but does not include any predefined
	 * prefix data.
	 */
	uint64_t	eng_bytes_in;
	/* Count of data bytes out of the Engine. */
	uint64_t	eng_bytes_out;
	/*
	 * Count, in 4-byte (dword) units, of bytes
	 * that are input as auxiliary data.
	 * This includes the aux_cmd data.
	 */
	uint64_t	aux_bytes_in;
	/*
	 * Count, in 4-byte (dword) units, of bytes
	 * that are output as auxiliary data.
	 * This count is the buffer space for aux_data
	 * output provided in the RQE, not the actual
	 * aux_data written
	 */
	uint64_t	aux_bytes_out;
	/* Count of number of commands executed. */
	uint64_t	commands;
	/*
	 * Count of number of error commands.
	 * These are the commands with a
	 * non-zero status value.
	 */
	uint64_t	error_commands;
	/*
	 * Compression/Encryption Engine usage,
	 * the unit is count of clock cycles
	 */
	uint64_t	cce_engine_usage;
	/*
	 * De-Compression/De-cryption Engine usage,
	 * the unit is count of clock cycles
	 */
	uint64_t	cdd_engine_usage;
} __rte_packed;

/***********************
 * hwrm_stat_ctx_alloc *
 ***********************/


/* hwrm_stat_ctx_alloc_input (size:256b/32B) */
struct hwrm_stat_ctx_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the address for statistic block.
	 * > For new versions of the chip, this address should be 128B
	 * > aligned.
	 */
	uint64_t	stats_dma_addr;
	/*
	 * The statistic block update period in ms.
	 * e.g. 250ms, 500ms, 750ms, 1000ms.
	 * If update_period_ms is 0, then the stats update
	 * shall be never done and the DMA address shall not be used.
	 * In this case, the stat block can only be read by
	 * hwrm_stat_ctx_query command.
	 * On Ethernet/L2 based devices:
	 *   if tpa v2 supported (hwrm_vnic_qcaps[max_aggs_supported]>0),
	 *       ctx_hw_stats_ext is used for DMA,
	 *   else
	 *       ctx_hw_stats is used for DMA.
	 */
	uint32_t	update_period_ms;
	/*
	 * This field is used to specify statistics context specific
	 * configuration flags.
	 */
	uint8_t	stat_ctx_flags;
	/*
	 * When this bit is set to '1', the statistics context shall be
	 * allocated for RoCE traffic only. In this case, traffic other
	 * than offloaded RoCE traffic shall not be included in this
	 * statistic context.
	 * When this bit is set to '0', the statistics context shall be
	 * used for network traffic or engine traffic.
	 */
	#define HWRM_STAT_CTX_ALLOC_INPUT_STAT_CTX_FLAGS_ROCE     UINT32_C(0x1)
	uint8_t	unused_0;
	/*
	 * This is the size of the structure (ctx_hw_stats or
	 * ctx_hw_stats_ext) that the driver has allocated to be used
	 * for the periodic DMA updates.
	 */
	uint16_t	stats_dma_length;
} __rte_packed;

/* hwrm_stat_ctx_alloc_output (size:128b/16B) */
struct hwrm_stat_ctx_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This is the statistics context ID value. */
	uint32_t	stat_ctx_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**********************
 * hwrm_stat_ctx_free *
 **********************/


/* hwrm_stat_ctx_free_input (size:192b/24B) */
struct hwrm_stat_ctx_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* ID of the statistics context that is being queried. */
	uint32_t	stat_ctx_id;
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_stat_ctx_free_output (size:128b/16B) */
struct hwrm_stat_ctx_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This is the statistics context ID value. */
	uint32_t	stat_ctx_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***********************
 * hwrm_stat_ctx_query *
 ***********************/


/* hwrm_stat_ctx_query_input (size:192b/24B) */
struct hwrm_stat_ctx_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* ID of the statistics context that is being queried. */
	uint32_t	stat_ctx_id;
	uint8_t	flags;
	/*
	 * This bit is set to 1 when request is for a counter mask,
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_STAT_CTX_QUERY_INPUT_FLAGS_COUNTER_MASK     UINT32_C(0x1)
	uint8_t	unused_0[3];
} __rte_packed;

/* hwrm_stat_ctx_query_output (size:1408b/176B) */
struct hwrm_stat_ctx_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of transmitted unicast packets */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets */
	uint64_t	tx_bcast_pkts;
	/* Number of packets discarded in transmit path */
	uint64_t	tx_discard_pkts;
	/* Number of packets in transmit path with error */
	uint64_t	tx_error_pkts;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	tx_bcast_bytes;
	/* Number of received unicast packets */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets */
	uint64_t	rx_bcast_pkts;
	/* Number of packets discarded in receive path */
	uint64_t	rx_discard_pkts;
	/* Number of packets in receive path with errors */
	uint64_t	rx_error_pkts;
	/* Number of received bytes for unicast traffic */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic */
	uint64_t	rx_bcast_bytes;
	/* Number of aggregated unicast packets */
	uint64_t	rx_agg_pkts;
	/* Number of aggregated unicast bytes */
	uint64_t	rx_agg_bytes;
	/* Number of aggregation events */
	uint64_t	rx_agg_events;
	/* Number of aborted aggregations */
	uint64_t	rx_agg_aborts;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_stat_ext_ctx_query *
 ***************************/


/* hwrm_stat_ext_ctx_query_input (size:192b/24B) */
struct hwrm_stat_ext_ctx_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* ID of the extended statistics context that is being queried. */
	uint32_t	stat_ctx_id;
	uint8_t	flags;
	/*
	 * This bit is set to 1 when request is for a counter mask,
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_STAT_EXT_CTX_QUERY_INPUT_FLAGS_COUNTER_MASK \
		UINT32_C(0x1)
	uint8_t	unused_0[3];
} __rte_packed;

/* hwrm_stat_ext_ctx_query_output (size:1536b/192B) */
struct hwrm_stat_ext_ctx_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of received unicast packets */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets */
	uint64_t	rx_bcast_pkts;
	/* Number of discarded packets on receive path */
	uint64_t	rx_discard_pkts;
	/* Number of packets on receive path with error */
	uint64_t	rx_error_pkts;
	/* Number of received bytes for unicast traffic */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic */
	uint64_t	rx_bcast_bytes;
	/* Number of transmitted unicast packets */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets */
	uint64_t	tx_bcast_pkts;
	/* Number of packets on transmit path with error */
	uint64_t	tx_error_pkts;
	/* Number of discarded packets on transmit path */
	uint64_t	tx_discard_pkts;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	tx_bcast_bytes;
	/* Number of TPA eligible packets */
	uint64_t	rx_tpa_eligible_pkt;
	/* Number of TPA eligible bytes */
	uint64_t	rx_tpa_eligible_bytes;
	/* Number of TPA packets */
	uint64_t	rx_tpa_pkt;
	/* Number of TPA bytes */
	uint64_t	rx_tpa_bytes;
	/* Number of TPA errors */
	uint64_t	rx_tpa_errors;
	/* Number of TPA events */
	uint64_t	rx_tpa_events;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_stat_ctx_eng_query *
 ***************************/


/* hwrm_stat_ctx_eng_query_input (size:192b/24B) */
struct hwrm_stat_ctx_eng_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* ID of the statistics context that is being queried. */
	uint32_t	stat_ctx_id;
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_stat_ctx_eng_query_output (size:640b/80B) */
struct hwrm_stat_ctx_eng_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Count of data bytes into the Engine.
	 * This includes any user supplied prefix,
	 * but does not include any predefined
	 * prefix data.
	 */
	uint64_t	eng_bytes_in;
	/* Count of data bytes out of the Engine. */
	uint64_t	eng_bytes_out;
	/*
	 * Count, in 4-byte (dword) units, of bytes
	 * that are input as auxiliary data.
	 * This includes the aux_cmd data.
	 */
	uint64_t	aux_bytes_in;
	/*
	 * Count, in 4-byte (dword) units, of bytes
	 * that are output as auxiliary data.
	 * This count is the buffer space for aux_data
	 * output provided in the RQE, not the actual
	 * aux_data written
	 */
	uint64_t	aux_bytes_out;
	/* Count of number of commands executed. */
	uint64_t	commands;
	/*
	 * Count of number of error commands.
	 * These are the commands with a
	 * non-zero status value.
	 */
	uint64_t	error_commands;
	/*
	 * Compression/Encryption Engine usage,
	 * the unit is count of clock cycles
	 */
	uint64_t	cce_engine_usage;
	/*
	 * De-Compression/De-cryption Engine usage,
	 * the unit is count of clock cycles
	 */
	uint64_t	cdd_engine_usage;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_stat_ctx_clr_stats *
 ***************************/


/* hwrm_stat_ctx_clr_stats_input (size:192b/24B) */
struct hwrm_stat_ctx_clr_stats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* ID of the statistics context that is being queried. */
	uint32_t	stat_ctx_id;
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_stat_ctx_clr_stats_output (size:128b/16B) */
struct hwrm_stat_ctx_clr_stats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/********************
 * hwrm_pcie_qstats *
 ********************/


/* hwrm_pcie_qstats_input (size:256b/32B) */
struct hwrm_pcie_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The size of PCIe statistics block in bytes.
	 * Firmware will DMA the PCIe statistics to
	 * the host with this field size in the response.
	 */
	uint16_t	pcie_stat_size;
	uint8_t	unused_0[6];
	/*
	 * This is the host address where
	 * PCIe statistics will be stored
	 */
	uint64_t	pcie_stat_host_addr;
} __rte_packed;

/* hwrm_pcie_qstats_output (size:128b/16B) */
struct hwrm_pcie_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The size of PCIe statistics block in bytes. */
	uint16_t	pcie_stat_size;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* PCIe Statistics Formats */
/* pcie_ctx_hw_stats (size:768b/96B) */
struct pcie_ctx_hw_stats {
	/* Number of physical layer receiver errors */
	uint64_t	pcie_pl_signal_integrity;
	/* Number of DLLP CRC errors detected by Data Link Layer */
	uint64_t	pcie_dl_signal_integrity;
	/*
	 * Number of TLP LCRC and sequence number errors detected
	 * by Data Link Layer
	 */
	uint64_t	pcie_tl_signal_integrity;
	/* Number of times LTSSM entered Recovery state */
	uint64_t	pcie_link_integrity;
	/* Report number of TLP bits that have been transmitted in Mbps */
	uint64_t	pcie_tx_traffic_rate;
	/* Report number of TLP bits that have been received in Mbps */
	uint64_t	pcie_rx_traffic_rate;
	/* Number of DLLP bytes that have been transmitted */
	uint64_t	pcie_tx_dllp_statistics;
	/* Number of DLLP bytes that have been received */
	uint64_t	pcie_rx_dllp_statistics;
	/*
	 * Number of times spent in each phase of gen3
	 * equalization
	 */
	uint64_t	pcie_equalization_time;
	/* Records the last 16 transitions of the LTSSM */
	uint32_t	pcie_ltssm_histogram[4];
	/*
	 * Record the last 8 reasons on why LTSSM transitioned
	 * to Recovery
	 */
	uint64_t	pcie_recovery_histogram;
} __rte_packed;

/****************************
 * hwrm_stat_generic_qstats *
 ****************************/


/* hwrm_stat_generic_qstats_input (size:256b/32B) */
struct hwrm_stat_generic_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The size of the generic statistics buffer passed in the
	 * generic_stat_host_addr in bytes.
	 * Firmware will not exceed this size when it DMAs the
	 * statistics structure to the host.  The actual DMA size
	 * will be returned in the response.
	 */
	uint16_t	generic_stat_size;
	uint8_t	flags;
	/*
	 * The bit should be set to 1 when request is for the counter mask
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_STAT_GENERIC_QSTATS_INPUT_FLAGS_COUNTER_MASK \
		UINT32_C(0x1)
	uint8_t	unused_0[5];
	/*
	 * This is the host address where
	 * generic statistics will be stored
	 */
	uint64_t	generic_stat_host_addr;
} __rte_packed;

/* hwrm_stat_generic_qstats_output (size:128b/16B) */
struct hwrm_stat_generic_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The size of Generic Statistics block in bytes. */
	uint16_t	generic_stat_size;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* Generic Statistic Format */
/* generic_sw_hw_stats (size:1408b/176B) */
struct generic_sw_hw_stats {
	/*
	 * This is the number of TLP bytes that have been transmitted for
	 * the caller PF.
	 */
	uint64_t	pcie_statistics_tx_tlp;
	/*
	 * This is the number of TLP bytes that have been received
	 * for the caller PF.
	 */
	uint64_t	pcie_statistics_rx_tlp;
	/* Posted Header Flow Control credits available for the caller PF. */
	uint64_t	pcie_credit_fc_hdr_posted;
	/* Non-posted Header Flow Control credits available for the caller PF. */
	uint64_t	pcie_credit_fc_hdr_nonposted;
	/* Completion Header Flow Control credits available for the caller PF. */
	uint64_t	pcie_credit_fc_hdr_cmpl;
	/* Posted Data Flow Control credits available for the caller PF. */
	uint64_t	pcie_credit_fc_data_posted;
	/* Non-Posted Data Flow Control credits available for the caller PF. */
	uint64_t	pcie_credit_fc_data_nonposted;
	/* Completion Data Flow Control credits available for the caller PF. */
	uint64_t	pcie_credit_fc_data_cmpl;
	/*
	 * Available Non-posted credit for target flow control reads or
	 * config for the caller PF.
	 */
	uint64_t	pcie_credit_fc_tgt_nonposted;
	/*
	 * Available posted data credit for target flow control writes
	 * for the caller PF.
	 */
	uint64_t	pcie_credit_fc_tgt_data_posted;
	/*
	 * Available posted header credit for target flow control writes
	 * for the caller PF.
	 */
	uint64_t	pcie_credit_fc_tgt_hdr_posted;
	/* Available completion flow control header credits for the caller PF. */
	uint64_t	pcie_credit_fc_cmpl_hdr_posted;
	/* Available completion flow control data credits. */
	uint64_t	pcie_credit_fc_cmpl_data_posted;
	/*
	 * Displays Time information of the longest completon time from any of
	 * the 4 tags for the caller PF.  The unit of time recorded is in
	 * microseconds.
	 */
	uint64_t	pcie_cmpl_longest;
	/*
	 * Displays Time information of the shortest completon time from any of
	 * the 4 tags for the caller PF.  The unit of time recorded is in
	 * microseconds.
	 */
	uint64_t	pcie_cmpl_shortest;
	/*
	 * This field contains the total number of CFCQ 'misses' observed for
	 * all the PF's.
	 */
	uint64_t	cache_miss_count_cfcq;
	/*
	 * This field contains the total number of CFCS 'misses' observed for
	 * all the PF's.
	 */
	uint64_t	cache_miss_count_cfcs;
	/*
	 * This field contains the total number of CFCC 'misses' observed for
	 * all the PF's.
	 */
	uint64_t	cache_miss_count_cfcc;
	/*
	 * This field contains the total number of CFCM 'misses' observed
	 * for all the PF's.
	 */
	uint64_t	cache_miss_count_cfcm;
	/*
	 * Total number of Doorbell messages dropped from the DB FIFO.
	 * This counter is only applicable for devices that support
	 * the hardware based doorbell drop recovery feature.
	 */
	uint64_t	hw_db_recov_dbs_dropped;
	/*
	 * Total number of doorbell drops serviced.
	 * This counter is only applicable for devices that support
	 * the hardware based doorbell drop recovery feature.
	 */
	uint64_t	hw_db_recov_drops_serviced;
	/*
	 * Total number of dropped doorbells recovered.
	 * This counter is only applicable for devices that support
	 * the hardware based doorbell drop recovery feature.
	 */
	uint64_t	hw_db_recov_dbs_recovered;
} __rte_packed;

/**********************
 * hwrm_exec_fwd_resp *
 **********************/


/* hwrm_exec_fwd_resp_input (size:1024b/128B) */
struct hwrm_exec_fwd_resp_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is an encapsulated request. This request should
	 * be executed by the HWRM and the response should be
	 * provided in the response buffer inside the encapsulated
	 * request.
	 */
	uint32_t	encap_request[26];
	/*
	 * This value indicates the target id of the response to
	 * the encapsulated request.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	encap_resp_target_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_exec_fwd_resp_output (size:128b/16B) */
struct hwrm_exec_fwd_resp_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/************************
 * hwrm_reject_fwd_resp *
 ************************/


/* hwrm_reject_fwd_resp_input (size:1024b/128B) */
struct hwrm_reject_fwd_resp_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is an encapsulated request. This request should
	 * be rejected by the HWRM and the error response should be
	 * provided in the response buffer inside the encapsulated
	 * request.
	 */
	uint32_t	encap_request[26];
	/*
	 * This value indicates the target id of the response to
	 * the encapsulated request.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	encap_resp_target_id;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_reject_fwd_resp_output (size:128b/16B) */
struct hwrm_reject_fwd_resp_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************
 * hwrm_fwd_resp *
 *****************/


/* hwrm_fwd_resp_input (size:1024b/128B) */
struct hwrm_fwd_resp_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value indicates the target id of the encapsulated
	 * response.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	encap_resp_target_id;
	/*
	 * This value indicates the completion ring the encapsulated
	 * response will be optionally completed on.  If the value is
	 * -1, then no CR completion shall be generated for the
	 * encapsulated response. Any other value must be a
	 * valid CR ring_id value. If a valid encap_resp_cmpl_ring
	 * is provided, then a CR completion shall be generated for
	 * the encapsulated response.
	 */
	uint16_t	encap_resp_cmpl_ring;
	/* This field indicates the length of encapsulated response. */
	uint16_t	encap_resp_len;
	uint8_t	unused_0;
	uint8_t	unused_1;
	/*
	 * This is the host address where the encapsulated response
	 * will be written.
	 * This area must be 16B aligned and must be cleared to zero
	 * before the original request is made.
	 */
	uint64_t	encap_resp_addr;
	/* This is an encapsulated response. */
	uint32_t	encap_resp[24];
} __rte_packed;

/* hwrm_fwd_resp_output (size:128b/16B) */
struct hwrm_fwd_resp_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************************
 * hwrm_fwd_async_event_cmpl *
 *****************************/


/* hwrm_fwd_async_event_cmpl_input (size:320b/40B) */
struct hwrm_fwd_async_event_cmpl_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value indicates the target id of the encapsulated
	 * asynchronous event.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - Broadcast to all children VFs (only applicable when
	 * a PF is the requester)
	 */
	uint16_t	encap_async_event_target_id;
	uint8_t	unused_0[6];
	/* This is an encapsulated asynchronous event completion. */
	uint32_t	encap_async_event_cmpl[4];
} __rte_packed;

/* hwrm_fwd_async_event_cmpl_output (size:128b/16B) */
struct hwrm_fwd_async_event_cmpl_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_nvm_raw_write_blk *
 **************************/


/* hwrm_nvm_raw_write_blk_input (size:256b/32B) */
struct hwrm_nvm_raw_write_blk_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Source Address.
	 * This is the location of the source data to be written.
	 */
	uint64_t	host_src_addr;
	/*
	 * 32-bit Destination Address.
	 * This is the NVRAM byte-offset where the source data will be written to.
	 */
	uint32_t	dest_addr;
	/* Length of data to be written, in bytes. */
	uint32_t	len;
} __rte_packed;

/* hwrm_nvm_raw_write_blk_output (size:128b/16B) */
struct hwrm_nvm_raw_write_blk_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************
 * hwrm_nvm_read *
 *****************/


/* hwrm_nvm_read_input (size:320b/40B) */
struct hwrm_nvm_read_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Destination Address.
	 * This is the host address where the data will be written to.
	 */
	uint64_t	host_dest_addr;
	/* The 0-based index of the directory entry. */
	uint16_t	dir_idx;
	uint8_t	unused_0[2];
	/* The NVRAM byte-offset to read from. */
	uint32_t	offset;
	/* The length of the data to be read, in bytes. */
	uint32_t	len;
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_nvm_read_output (size:128b/16B) */
struct hwrm_nvm_read_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*********************
 * hwrm_nvm_raw_dump *
 *********************/


/* hwrm_nvm_raw_dump_input (size:256b/32B) */
struct hwrm_nvm_raw_dump_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Destination Address.
	 * This is the host address where the data will be written to.
	 */
	uint64_t	host_dest_addr;
	/* 32-bit NVRAM byte-offset to read from. */
	uint32_t	offset;
	/* Total length of NVRAM contents to be read, in bytes. */
	uint32_t	len;
} __rte_packed;

/* hwrm_nvm_raw_dump_output (size:128b/16B) */
struct hwrm_nvm_raw_dump_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/****************************
 * hwrm_nvm_get_dir_entries *
 ****************************/


/* hwrm_nvm_get_dir_entries_input (size:192b/24B) */
struct hwrm_nvm_get_dir_entries_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Destination Address.
	 * This is the host address where the directory will be written.
	 */
	uint64_t	host_dest_addr;
} __rte_packed;

/* hwrm_nvm_get_dir_entries_output (size:128b/16B) */
struct hwrm_nvm_get_dir_entries_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_nvm_get_dir_info *
 *************************/


/* hwrm_nvm_get_dir_info_input (size:128b/16B) */
struct hwrm_nvm_get_dir_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_nvm_get_dir_info_output (size:192b/24B) */
struct hwrm_nvm_get_dir_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of directory entries in the directory. */
	uint32_t	entries;
	/* Size of each directory entry, in bytes. */
	uint32_t	entry_length;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/******************
 * hwrm_nvm_write *
 ******************/


/* hwrm_nvm_write_input (size:448b/56B) */
struct hwrm_nvm_write_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Source Address.
	 * This is where the source data is.
	 */
	uint64_t	host_src_addr;
	/*
	 * The Directory Entry Type (valid values are defined in the
	 * bnxnvm_directory_type enum defined in the file bnxnvm_defs.h).
	 */
	uint16_t	dir_type;
	/*
	 * Directory ordinal.
	 * The 0-based instance of the combined Directory Entry Type and Extension.
	 */
	uint16_t	dir_ordinal;
	/*
	 * The Directory Entry Extension flags (see BNX_DIR_EXT_* in the file
	 * bnxnvm_defs.h).
	 */
	uint16_t	dir_ext;
	/*
	 * Directory Entry Attribute flags (see BNX_DIR_ATTR_* in the file
	 * bnxnvm_defs.h).
	 */
	uint16_t	dir_attr;
	/*
	 * Length of data to write, in bytes. May be less than or equal to the
	 * allocated size for the directory entry.
	 * The data length stored in the directory entry will be updated to
	 * reflect this value once the write is complete.
	 */
	uint32_t	dir_data_length;
	/* Option. */
	uint16_t	option;
	uint16_t	flags;
	/*
	 * When this bit is '1', the original active image
	 * will not be removed. TBD: what purpose is this?
	 */
	#define HWRM_NVM_WRITE_INPUT_FLAGS_KEEP_ORIG_ACTIVE_IMG \
		UINT32_C(0x1)
	/*
	 * This flag indicates the sender wants to modify a continuous
	 * NVRAM area using a batch of this HWRM requests. The
	 * offset of a request must be continuous to the end of previous
	 * request's. Firmware does not update the directory entry until
	 * receiving the last request, which is indicated by the batch_last
	 * flag. This flag is set usually when a sender does not have a
	 * block of memory that is big enough to hold the entire NVRAM
	 * data for send at one time.
	 */
	#define HWRM_NVM_WRITE_INPUT_FLAGS_BATCH_MODE \
		UINT32_C(0x2)
	/*
	 * This flag can be used only when the batch_mode flag is set. It
	 * indicates this request is the last of batch requests.
	 */
	#define HWRM_NVM_WRITE_INPUT_FLAGS_BATCH_LAST \
		UINT32_C(0x4)
	/*
	 * The requested length of the allocated NVM for the item, in bytes.
	 * This value may be greater than or equal to the specified data
	 * length (dir_data_length).
	 * If this value is less than the specified data length, it will be ignored.
	 * The response will contain the actual allocated item length,
	 * which may be greater than the requested item length.
	 * The purpose for allocating more than the required number of bytes
	 * for an item's data is to pre-allocate extra storage (padding) to
	 * accommodate the potential future growth of an item (e.g. upgraded
	 * firmware with a size increase, log growth, expanded configuration data).
	 */
	uint32_t	dir_item_length;
	/*
	 * 32-bit offset of data blob from where data is being written.
	 * Only valid for batch mode. For non-batch writes 'dont care'.
	 */
	uint32_t	offset;
	/*
	 * Length of data to be written.Should be non-zero.
	 * Only valid for batch mode. For non-batch writes 'dont care'.
	 */
	uint32_t	len;
	uint32_t	unused_0;
} __rte_packed;

/* hwrm_nvm_write_output (size:128b/16B) */
struct hwrm_nvm_write_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Length of the allocated NVM for the item, in bytes. The value may be
	 * greater than or equal to the specified data length or the requested
	 * item length.
	 * The actual item length used when creating a new directory entry will
	 * be a multiple of an NVM block size.
	 */
	uint32_t	dir_item_length;
	/* The directory index of the created or modified item. */
	uint16_t	dir_idx;
	uint8_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* hwrm_nvm_write_cmd_err (size:64b/8B) */
struct hwrm_nvm_write_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_WRITE_CMD_ERR_CODE_UNKNOWN  UINT32_C(0x0)
	/* Unable to complete operation due to fragmentation */
	#define HWRM_NVM_WRITE_CMD_ERR_CODE_FRAG_ERR UINT32_C(0x1)
	/* nvm is completely full. */
	#define HWRM_NVM_WRITE_CMD_ERR_CODE_NO_SPACE UINT32_C(0x2)
	#define HWRM_NVM_WRITE_CMD_ERR_CODE_LAST \
		HWRM_NVM_WRITE_CMD_ERR_CODE_NO_SPACE
	uint8_t	unused_0[7];
} __rte_packed;

/*******************
 * hwrm_nvm_modify *
 *******************/


/* hwrm_nvm_modify_input (size:320b/40B) */
struct hwrm_nvm_modify_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Source Address.
	 * This is where the modified data is.
	 */
	uint64_t	host_src_addr;
	/* 16-bit directory entry index. */
	uint16_t	dir_idx;
	uint16_t	flags;
	/*
	 * This flag indicates the sender wants to modify a continuous NVRAM
	 * area using a batch of this HWRM requests. The offset of a request
	 * must be continuous to the end of previous request's. Firmware does
	 * not update the directory entry until receiving the last request,
	 * which is indicated by the batch_last flag.
	 * This flag is set usually when a sender does not have a block of
	 * memory that is big enough to hold the entire NVRAM data for send
	 * at one time.
	 */
	#define HWRM_NVM_MODIFY_INPUT_FLAGS_BATCH_MODE     UINT32_C(0x1)
	/*
	 * This flag can be used only when the batch_mode flag is set.
	 * It indicates this request is the last of batch requests.
	 */
	#define HWRM_NVM_MODIFY_INPUT_FLAGS_BATCH_LAST     UINT32_C(0x2)
	/* 32-bit NVRAM byte-offset to modify content from. */
	uint32_t	offset;
	/*
	 * Length of data to be modified, in bytes. The length shall
	 * be non-zero.
	 */
	uint32_t	len;
	uint8_t	unused_1[4];
} __rte_packed;

/* hwrm_nvm_modify_output (size:128b/16B) */
struct hwrm_nvm_modify_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_nvm_find_dir_entry *
 ***************************/


/* hwrm_nvm_find_dir_entry_input (size:256b/32B) */
struct hwrm_nvm_find_dir_entry_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the dir_idx_valid field to be
	 * configured.
	 */
	#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_ENABLES_DIR_IDX_VALID \
		UINT32_C(0x1)
	/* Directory Entry Index */
	uint16_t	dir_idx;
	/* Directory Entry (Image) Type */
	uint16_t	dir_type;
	/*
	 * Directory ordinal.
	 * The instance of this Directory Type
	 */
	uint16_t	dir_ordinal;
	/* The Directory Entry Extension flags. */
	uint16_t	dir_ext;
	/* This value indicates the search option using dir_ordinal. */
	uint8_t	opt_ordinal;
	/* This value indicates the search option using dir_ordinal. */
	#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_MASK UINT32_C(0x3)
	#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_SFT 0
	/* Equal to specified ordinal value. */
	#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_EQ    UINT32_C(0x0)
	/* Greater than or equal to specified ordinal value */
	#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_GE    UINT32_C(0x1)
	/* Greater than specified ordinal value */
	#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_GT    UINT32_C(0x2)
	#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_LAST \
		HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_GT
	uint8_t	unused_0[3];
} __rte_packed;

/* hwrm_nvm_find_dir_entry_output (size:256b/32B) */
struct hwrm_nvm_find_dir_entry_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Allocated NVRAM for this directory entry, in bytes. */
	uint32_t	dir_item_length;
	/* Size of the stored data for this directory entry, in bytes. */
	uint32_t	dir_data_length;
	/*
	 * Firmware version.
	 * Only valid if the directory entry is for embedded firmware stored
	 * in APE_BIN Format.
	 */
	uint32_t	fw_ver;
	/* Directory ordinal. */
	uint16_t	dir_ordinal;
	/* Directory Entry Index */
	uint16_t	dir_idx;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/****************************
 * hwrm_nvm_erase_dir_entry *
 ****************************/


/* hwrm_nvm_erase_dir_entry_input (size:192b/24B) */
struct hwrm_nvm_erase_dir_entry_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Directory Entry Index */
	uint16_t	dir_idx;
	uint8_t	unused_0[6];
} __rte_packed;

/* hwrm_nvm_erase_dir_entry_output (size:128b/16B) */
struct hwrm_nvm_erase_dir_entry_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*************************
 * hwrm_nvm_get_dev_info *
 *************************/


/* hwrm_nvm_get_dev_info_input (size:128b/16B) */
struct hwrm_nvm_get_dev_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_nvm_get_dev_info_output (size:640b/80B) */
struct hwrm_nvm_get_dev_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Manufacturer ID. */
	uint16_t	manufacturer_id;
	/* Device ID. */
	uint16_t	device_id;
	/* Sector size of the NVRAM device. */
	uint32_t	sector_size;
	/* Total size, in bytes of the NVRAM device. */
	uint32_t	nvram_size;
	uint32_t	reserved_size;
	/*
	 * Available size that can be used, in bytes.  Available size is the
	 * NVRAM size take away the used size and reserved size.
	 */
	uint32_t	available_size;
	/* This field represents the major version of NVM cfg */
	uint8_t	nvm_cfg_ver_maj;
	/* This field represents the minor version of NVM cfg */
	uint8_t	nvm_cfg_ver_min;
	/* This field represents the update version of NVM cfg */
	uint8_t	nvm_cfg_ver_upd;
	uint8_t	flags;
	/*
	 * If set to 1, firmware will provide various firmware version
	 * information stored in the flash.
	 */
	#define HWRM_NVM_GET_DEV_INFO_OUTPUT_FLAGS_FW_VER_VALID \
		UINT32_C(0x1)
	/*
	 * This field represents the board package name stored in the flash.
	 * (ASCII chars with NULL at the end).
	 */
	char	pkg_name[16];
	/*
	 * This field represents the major version of HWRM firmware, stored in
	 * the flash.
	 */
	uint16_t	hwrm_fw_major;
	/*
	 * This field represents the minor version of HWRM firmware, stored in
	 * the flash.
	 */
	uint16_t	hwrm_fw_minor;
	/*
	 * This field represents the build version of HWRM firmware, stored in
	 * the flash.
	 */
	uint16_t	hwrm_fw_build;
	/*
	 * This field can be used to represent firmware branches or customer
	 * specific releases tied to a specific (major, minor, build) version
	 * of the HWRM firmware.
	 */
	uint16_t	hwrm_fw_patch;
	/*
	 * This field represents the major version of mgmt firmware, stored in
	 * the flash.
	 */
	uint16_t	mgmt_fw_major;
	/*
	 * This field represents the minor version of mgmt firmware, stored in
	 * the flash.
	 */
	uint16_t	mgmt_fw_minor;
	/*
	 * This field represents the build version of mgmt firmware, stored in
	 * the flash.
	 */
	uint16_t	mgmt_fw_build;
	/*
	 * This field can be used to represent firmware branches or customer
	 * specific releases tied to a specific (major, minor, build) version
	 * of the mgmt firmware.
	 */
	uint16_t	mgmt_fw_patch;
	/*
	 * This field represents the major version of roce firmware, stored in
	 * the flash.
	 */
	uint16_t	roce_fw_major;
	/*
	 * This field represents the minor version of roce firmware, stored in
	 * the flash.
	 */
	uint16_t	roce_fw_minor;
	/*
	 * This field represents the build version of roce firmware, stored in
	 * the flash.
	 */
	uint16_t	roce_fw_build;
	/*
	 * This field can be used to represent firmware branches or customer
	 * specific releases tied to a specific (major, minor, build) version
	 * of the roce firmware.
	 */
	uint16_t	roce_fw_patch;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_nvm_mod_dir_entry *
 **************************/


/* hwrm_nvm_mod_dir_entry_input (size:256b/32B) */
struct hwrm_nvm_mod_dir_entry_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the checksum field to be
	 * configured.
	 */
	#define HWRM_NVM_MOD_DIR_ENTRY_INPUT_ENABLES_CHECKSUM     UINT32_C(0x1)
	/* Directory Entry Index */
	uint16_t	dir_idx;
	/*
	 * Directory ordinal.
	 * The (0-based) instance of this Directory Type.
	 */
	uint16_t	dir_ordinal;
	/*
	 * The Directory Entry Extension flags (see BNX_DIR_EXT_* for
	 * extension flag definitions).
	 */
	uint16_t	dir_ext;
	/*
	 * Directory Entry Attribute flags (see BNX_DIR_ATTR_* for attribute
	 * flag definitions).
	 */
	uint16_t	dir_attr;
	/*
	 * If valid, then this field updates the checksum
	 * value of the content in the directory entry.
	 */
	uint32_t	checksum;
} __rte_packed;

/* hwrm_nvm_mod_dir_entry_output (size:128b/16B) */
struct hwrm_nvm_mod_dir_entry_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/**************************
 * hwrm_nvm_verify_update *
 **************************/


/* hwrm_nvm_verify_update_input (size:192b/24B) */
struct hwrm_nvm_verify_update_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Directory Entry Type, to be verified. */
	uint16_t	dir_type;
	/*
	 * Directory ordinal.
	 * The instance of the Directory Type to be verified.
	 */
	uint16_t	dir_ordinal;
	/*
	 * The Directory Entry Extension flags.
	 * The "UPDATE" extension flag must be set in this value.
	 * A corresponding directory entry with the same type and ordinal
	 * values but *without*
	 * the "UPDATE" extension flag must also exist. The other flags of
	 * the extension must
	 * be identical between the active and update entries.
	 */
	uint16_t	dir_ext;
	uint8_t	unused_0[2];
} __rte_packed;

/* hwrm_nvm_verify_update_output (size:128b/16B) */
struct hwrm_nvm_verify_update_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/***************************
 * hwrm_nvm_install_update *
 ***************************/


/* hwrm_nvm_install_update_input (size:192b/24B) */
struct hwrm_nvm_install_update_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Installation type. If the value 3 through 0xffff is used,
	 * only packaged items with that type value will be installed and
	 * conditional installation directives for those packaged items
	 * will be over-ridden (i.e. 'create' or 'replace' will be treated
	 * as 'install').
	 */
	uint32_t	install_type;
	/*
	 * Perform a normal package installation. Conditional installation
	 * directives (e.g. 'create' and 'replace') of packaged items
	 * will be followed.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_INSTALL_TYPE_NORMAL UINT32_C(0x0)
	/*
	 * Install all packaged items regardless of installation directive
	 * (i.e. treat all packaged items as though they have an installation
	 * directive of 'install').
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_INSTALL_TYPE_ALL \
		UINT32_C(0xffffffff)
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_INSTALL_TYPE_LAST \
		HWRM_NVM_INSTALL_UPDATE_INPUT_INSTALL_TYPE_ALL
	uint16_t	flags;
	/*
	 * If set to 1, then securely erase all unused locations in
	 * persistent storage.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_FLAGS_ERASE_UNUSED_SPACE \
		UINT32_C(0x1)
	/*
	 * If set to 1, then unspecified images, images not in the package
	 * file, will be safely deleted.
	 * When combined with erase_unused_space then unspecified images will
	 * be securely erased.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_FLAGS_REMOVE_UNUSED_PKG \
		UINT32_C(0x2)
	/*
	 * If set to 1, FW will defragment the NVM if defragmentation is
	 * required for the update.
	 * Allow additional time for this command to complete if this bit is
	 * set to 1.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_FLAGS_ALLOWED_TO_DEFRAG \
		UINT32_C(0x4)
	/*
	 * If set to 1, FW will verify the package in the "UPDATE" NVM item
	 * without installing it. This flag is for FW internal use only.
	 * Users should not set this flag. The request will otherwise fail.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_FLAGS_VERIFY_ONLY \
		UINT32_C(0x8)
	uint8_t	unused_0[2];
} __rte_packed;

/* hwrm_nvm_install_update_output (size:192b/24B) */
struct hwrm_nvm_install_update_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Bit-mask of successfully installed items.
	 * Bit-0 corresponding to the first packaged item, Bit-1 for the second item, etc.
	 * A value of 0 indicates that no items were successfully installed.
	 */
	uint64_t	installed_items;
	/* result is 8 b corresponding to BCMRETVAL error codes */
	uint8_t	result;
	/* There was no problem with the package installation. */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_SUCCESS \
		UINT32_C(0x0)
	/* Generic failure */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_FAILURE \
		UINT32_C(0xff)
	/* Allocation error malloc failure */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_MALLOC_FAILURE \
		UINT32_C(0xfd)
	/* NVM install error due to invalid index */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_INDEX_PARAMETER \
		UINT32_C(0xfb)
	/* NVM install error due to invalid type */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_TYPE_PARAMETER \
		UINT32_C(0xf3)
	/* Invalid package due to invalid prerequisite */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_PREREQUISITE \
		UINT32_C(0xf2)
	/* Invalid package due to invalid file header */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_FILE_HEADER \
		UINT32_C(0xec)
	/* Invalid package due to invalid format */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_SIGNATURE \
		UINT32_C(0xeb)
	/* Invalid package due to invalid property stream */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_PROP_STREAM \
		UINT32_C(0xea)
	/* Invalid package due to invalid property length */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_PROP_LENGTH \
		UINT32_C(0xe9)
	/* Invalid package due to invalid manifest */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_MANIFEST \
		UINT32_C(0xe8)
	/* Invalid package due to invalid trailer */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_TRAILER \
		UINT32_C(0xe7)
	/* Invalid package due to invalid checksum */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_CHECKSUM \
		UINT32_C(0xe6)
	/* Invalid package due to invalid item checksum */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_ITEM_CHECKSUM \
		UINT32_C(0xe5)
	/* Invalid package due to invalid length */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_DATA_LENGTH \
		UINT32_C(0xe4)
	/* Invalid package due to invalid directive */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_DIRECTIVE \
		UINT32_C(0xe1)
	/* Invalid device due to unsupported chip revision */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_UNSUPPORTED_CHIP_REV \
		UINT32_C(0xce)
	/* Invalid device due to unsupported device ID */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_UNSUPPORTED_DEVICE_ID \
		UINT32_C(0xcd)
	/* Invalid device due to unsupported subsystem vendor */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_UNSUPPORTED_SUBSYS_VENDOR \
		UINT32_C(0xcc)
	/* Invalid device due to unsupported subsystem ID */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_UNSUPPORTED_SUBSYS_ID \
		UINT32_C(0xcb)
	/* Invalid device due to unsupported product ID or customer ID */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_UNSUPPORTED_PLATFORM \
		UINT32_C(0xc5)
	/* Invalid package due to duplicate item */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_DUPLICATE_ITEM \
		UINT32_C(0xc4)
	/* Invalid package due to zero length item */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_ZERO_LENGTH_ITEM \
		UINT32_C(0xc3)
	/* NVM integrity error checksum */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INSTALL_CHECKSUM_ERROR \
		UINT32_C(0xb9)
	/* NVM integrity error */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INSTALL_DATA_ERROR \
		UINT32_C(0xb8)
	/* Authentication error */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INSTALL_AUTHENTICATION_ERROR \
		UINT32_C(0xb7)
	/* NVM install error item not found */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_ITEM_NOT_FOUND \
		UINT32_C(0xb0)
	/* NVM install error item locked */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_ITEM_LOCKED \
		UINT32_C(0xa7)
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_LAST \
		HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_ITEM_LOCKED
	/* problem_item is 8 b */
	uint8_t	problem_item;
	/* There was no problem with any packaged items. */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_PROBLEM_ITEM_NONE \
		UINT32_C(0x0)
	/* There was a problem with the NVM package itself. */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_PROBLEM_ITEM_PACKAGE \
		UINT32_C(0xff)
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_PROBLEM_ITEM_LAST \
		HWRM_NVM_INSTALL_UPDATE_OUTPUT_PROBLEM_ITEM_PACKAGE
	/* reset_required is 8 b */
	uint8_t	reset_required;
	/*
	 * No reset is required for installed/updated firmware or
	 * microcode to take effect.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_NONE \
		UINT32_C(0x0)
	/*
	 * A PCIe reset (e.g. system reboot) is
	 * required for newly installed/updated firmware or
	 * microcode to take effect.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_PCI \
		UINT32_C(0x1)
	/*
	 * A controller power reset (e.g. system power-cycle) is
	 * required for newly installed/updated firmware or
	 * microcode to take effect. Some newly installed/updated
	 * firmware or microcode may still take effect upon the
	 * next PCIe reset.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_POWER \
		UINT32_C(0x2)
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_LAST \
		HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_POWER
	uint8_t	unused_0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* hwrm_nvm_install_update_cmd_err (size:64b/8B) */
struct hwrm_nvm_install_update_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_UNKNOWN \
		UINT32_C(0x0)
	/* Unable to complete operation due to fragmentation */
	#define HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_FRAG_ERR \
		UINT32_C(0x1)
	/* nvm is completely full. */
	#define HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_NO_SPACE \
		UINT32_C(0x2)
	/* Firmware update failed due to Anti-rollback. */
	#define HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_ANTI_ROLLBACK \
		UINT32_C(0x3)
	/* Firmware update does not support voltage regulators on the device. */
	#define HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_NO_VOLTREG_SUPPORT \
		UINT32_C(0x4)
	#define HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_LAST \
		HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_NO_VOLTREG_SUPPORT
	uint8_t	unused_0[7];
} __rte_packed;

/******************
 * hwrm_nvm_flush *
 ******************/


/* hwrm_nvm_flush_input (size:128b/16B) */
struct hwrm_nvm_flush_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} __rte_packed;

/* hwrm_nvm_flush_output (size:128b/16B) */
struct hwrm_nvm_flush_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* hwrm_nvm_flush_cmd_err (size:64b/8B) */
struct hwrm_nvm_flush_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_FLUSH_CMD_ERR_CODE_UNKNOWN UINT32_C(0x0)
	/* flush could not be performed */
	#define HWRM_NVM_FLUSH_CMD_ERR_CODE_FAIL    UINT32_C(0x1)
	#define HWRM_NVM_FLUSH_CMD_ERR_CODE_LAST \
		HWRM_NVM_FLUSH_CMD_ERR_CODE_FAIL
	uint8_t	unused_0[7];
} __rte_packed;

/*************************
 * hwrm_nvm_get_variable *
 *************************/


/* hwrm_nvm_get_variable_input (size:320b/40B) */
struct hwrm_nvm_get_variable_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where
	 * nvm variable will be stored
	 */
	uint64_t	dest_data_addr;
	/* size of data in bits */
	uint16_t	data_len;
	/* nvm cfg option number */
	uint16_t	option_num;
	/* reserved. */
	#define HWRM_NVM_GET_VARIABLE_INPUT_OPTION_NUM_RSVD_0    UINT32_C(0x0)
	/* reserved. */
	#define HWRM_NVM_GET_VARIABLE_INPUT_OPTION_NUM_RSVD_FFFF \
		UINT32_C(0xffff)
	#define HWRM_NVM_GET_VARIABLE_INPUT_OPTION_NUM_LAST \
		HWRM_NVM_GET_VARIABLE_INPUT_OPTION_NUM_RSVD_FFFF
	/*
	 * Number of dimensions for this nvm configuration variable.
	 * This value indicates how many of the indexN values to use.
	 * A value of 0 means that none of the indexN values are valid.
	 * A value of 1 requires at index0 is valued, a value of 2
	 * requires that index0 and index1 are valid, and so forth
	 */
	uint16_t	dimensions;
	/* index for the 1st dimensions */
	uint16_t	index_0;
	/* index for the 2nd dimensions */
	uint16_t	index_1;
	/* index for the 3rd dimensions */
	uint16_t	index_2;
	/* index for the 4th dimensions */
	uint16_t	index_3;
	uint8_t	flags;
	/*
	 * When this bit is set to 1, the factory default value will be returned,
	 * 0 returns the operational value.
	 */
	#define HWRM_NVM_GET_VARIABLE_INPUT_FLAGS_FACTORY_DFLT \
		UINT32_C(0x1)
	uint8_t	unused_0;
} __rte_packed;

/* hwrm_nvm_get_variable_output (size:128b/16B) */
struct hwrm_nvm_get_variable_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* size of data of the actual variable retrieved in bits */
	uint16_t	data_len;
	/*
	 * option_num is the option number for the data retrieved. It is
	 * possible in the future that the option number returned would be
	 * different than requested. This condition could occur if an option is
	 * deprecated and a new option id is defined with similar
	 * characteristics, but has a slightly different definition. This
	 * also makes it convenient for the caller to identify the variable
	 * result with the option id from the response.
	 */
	uint16_t	option_num;
	/* reserved. */
	#define HWRM_NVM_GET_VARIABLE_OUTPUT_OPTION_NUM_RSVD_0    UINT32_C(0x0)
	/* reserved. */
	#define HWRM_NVM_GET_VARIABLE_OUTPUT_OPTION_NUM_RSVD_FFFF \
		UINT32_C(0xffff)
	#define HWRM_NVM_GET_VARIABLE_OUTPUT_OPTION_NUM_LAST \
		HWRM_NVM_GET_VARIABLE_OUTPUT_OPTION_NUM_RSVD_FFFF
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* hwrm_nvm_get_variable_cmd_err (size:64b/8B) */
struct hwrm_nvm_get_variable_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_UNKNOWN       UINT32_C(0x0)
	/* variable does not exist */
	#define HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_VAR_NOT_EXIST UINT32_C(0x1)
	/* configuration is corrupted and the variable cannot be saved */
	#define HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_CORRUPT_VAR   UINT32_C(0x2)
	/* length specified is too small */
	#define HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_LEN_TOO_SHORT UINT32_C(0x3)
	#define HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_LAST \
		HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_LEN_TOO_SHORT
	uint8_t	unused_0[7];
} __rte_packed;

/*************************
 * hwrm_nvm_set_variable *
 *************************/


/* hwrm_nvm_set_variable_input (size:320b/40B) */
struct hwrm_nvm_set_variable_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where
	 * nvm variable will be copied from
	 */
	uint64_t	src_data_addr;
	/* size of data in bits */
	uint16_t	data_len;
	/* nvm cfg option number */
	uint16_t	option_num;
	/* reserved. */
	#define HWRM_NVM_SET_VARIABLE_INPUT_OPTION_NUM_RSVD_0    UINT32_C(0x0)
	/* reserved. */
	#define HWRM_NVM_SET_VARIABLE_INPUT_OPTION_NUM_RSVD_FFFF \
		UINT32_C(0xffff)
	#define HWRM_NVM_SET_VARIABLE_INPUT_OPTION_NUM_LAST \
		HWRM_NVM_SET_VARIABLE_INPUT_OPTION_NUM_RSVD_FFFF
	/*
	 * Number of dimensions for this nvm configuration variable.
	 * This value indicates how many of the indexN values to use.
	 * A value of 0 means that none of the indexN values are valid.
	 * A value of 1 requires at index0 is valued, a value of 2
	 * requires that index0 and index1 are valid, and so forth
	 */
	uint16_t	dimensions;
	/* index for the 1st dimensions */
	uint16_t	index_0;
	/* index for the 2nd dimensions */
	uint16_t	index_1;
	/* index for the 3rd dimensions */
	uint16_t	index_2;
	/* index for the 4th dimensions */
	uint16_t	index_3;
	uint8_t	flags;
	/*
	 * When this bit is 1, flush internal cache after this write
	 * operation (see hwrm_nvm_flush command.)
	 */
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_FORCE_FLUSH \
		UINT32_C(0x1)
	/* encryption method */
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_MASK \
		UINT32_C(0xe)
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_SFT           1
	/* No encryption. */
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_NONE \
		(UINT32_C(0x0) << 1)
	/* one-way encryption. */
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_HMAC_SHA1 \
		(UINT32_C(0x1) << 1)
	/* symmetric AES256 encryption. */
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_AES256 \
		(UINT32_C(0x2) << 1)
	/* SHA1 digest appended to plaintext contents, for authentication */
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_HMAC_SHA1_AUTH \
		(UINT32_C(0x3) << 1)
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_LAST \
		HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_HMAC_SHA1_AUTH
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_FLAGS_UNUSED_0_MASK \
		UINT32_C(0x70)
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_FLAGS_UNUSED_0_SFT         4
	/* When this bit is 1, update the factory default region */
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_FACTORY_DEFAULT \
		UINT32_C(0x80)
	uint8_t	unused_0;
} __rte_packed;

/* hwrm_nvm_set_variable_output (size:128b/16B) */
struct hwrm_nvm_set_variable_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* hwrm_nvm_set_variable_cmd_err (size:64b/8B) */
struct hwrm_nvm_set_variable_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_UNKNOWN       UINT32_C(0x0)
	/* variable does not exist */
	#define HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_VAR_NOT_EXIST UINT32_C(0x1)
	/* configuration is corrupted and the variable cannot be saved */
	#define HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_CORRUPT_VAR   UINT32_C(0x2)
	#define HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_LAST \
		HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_CORRUPT_VAR
	uint8_t	unused_0[7];
} __rte_packed;

/****************************
 * hwrm_nvm_validate_option *
 ****************************/


/* hwrm_nvm_validate_option_input (size:320b/40B) */
struct hwrm_nvm_validate_option_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where
	 * nvm variable will be copied from
	 */
	uint64_t	src_data_addr;
	/* size of data in bits */
	uint16_t	data_len;
	/* nvm cfg option number */
	uint16_t	option_num;
	/* reserved. */
	#define HWRM_NVM_VALIDATE_OPTION_INPUT_OPTION_NUM_RSVD_0 \
		UINT32_C(0x0)
	/* reserved. */
	#define HWRM_NVM_VALIDATE_OPTION_INPUT_OPTION_NUM_RSVD_FFFF \
		UINT32_C(0xffff)
	#define HWRM_NVM_VALIDATE_OPTION_INPUT_OPTION_NUM_LAST \
		HWRM_NVM_VALIDATE_OPTION_INPUT_OPTION_NUM_RSVD_FFFF
	/*
	 * Number of dimensions for this nvm configuration variable.
	 * This value indicates how many of the indexN values to use.
	 * A value of 0 means that none of the indexN values are valid.
	 * A value of 1 requires at index0 is valued, a value of 2
	 * requires that index0 and index1 are valid, and so forth
	 */
	uint16_t	dimensions;
	/* index for the 1st dimensions */
	uint16_t	index_0;
	/* index for the 2nd dimensions */
	uint16_t	index_1;
	/* index for the 3rd dimensions */
	uint16_t	index_2;
	/* index for the 4th dimensions */
	uint16_t	index_3;
	uint8_t	unused_0[2];
} __rte_packed;

/* hwrm_nvm_validate_option_output (size:128b/16B) */
struct hwrm_nvm_validate_option_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	result;
	/*
	 * indicates that the value provided for the option is not matching
	 * with the saved data.
	 */
	#define HWRM_NVM_VALIDATE_OPTION_OUTPUT_RESULT_NOT_MATCH UINT32_C(0x0)
	/*
	 * indicates that the value provided for the option is matching the
	 * saved data.
	 */
	#define HWRM_NVM_VALIDATE_OPTION_OUTPUT_RESULT_MATCH     UINT32_C(0x1)
	#define HWRM_NVM_VALIDATE_OPTION_OUTPUT_RESULT_LAST \
		HWRM_NVM_VALIDATE_OPTION_OUTPUT_RESULT_MATCH
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* hwrm_nvm_validate_option_cmd_err (size:64b/8B) */
struct hwrm_nvm_validate_option_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_VALIDATE_OPTION_CMD_ERR_CODE_UNKNOWN UINT32_C(0x0)
	#define HWRM_NVM_VALIDATE_OPTION_CMD_ERR_CODE_LAST \
		HWRM_NVM_VALIDATE_OPTION_CMD_ERR_CODE_UNKNOWN
	uint8_t	unused_0[7];
} __rte_packed;

/*******************
 * hwrm_nvm_defrag *
 *******************/


/* hwrm_nvm_defrag_input (size:192b/24B) */
struct hwrm_nvm_defrag_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* This bit must be '1' to perform NVM defragmentation. */
	#define HWRM_NVM_DEFRAG_INPUT_FLAGS_DEFRAG     UINT32_C(0x1)
	uint8_t	unused_0[4];
} __rte_packed;

/* hwrm_nvm_defrag_output (size:128b/16B) */
struct hwrm_nvm_defrag_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/* hwrm_nvm_defrag_cmd_err (size:64b/8B) */
struct hwrm_nvm_defrag_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_DEFRAG_CMD_ERR_CODE_UNKNOWN UINT32_C(0x0)
	/* NVM defragmentation could not be performed */
	#define HWRM_NVM_DEFRAG_CMD_ERR_CODE_FAIL    UINT32_C(0x1)
	#define HWRM_NVM_DEFRAG_CMD_ERR_CODE_LAST \
		HWRM_NVM_DEFRAG_CMD_ERR_CODE_FAIL
	uint8_t	unused_0[7];
} __rte_packed;

/****************
 * hwrm_oem_cmd *
 ****************/


/* hwrm_oem_cmd_input (size:1024b/128B) */
struct hwrm_oem_cmd_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	IANA;
	uint32_t	unused_0;
	/* This field contains the vendor specific command data. */
	uint32_t	oem_data[26];
} __rte_packed;

/* hwrm_oem_cmd_output (size:768b/96B) */
struct hwrm_oem_cmd_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	IANA;
	uint32_t	unused_0;
	/* This field contains the vendor specific response data. */
	uint32_t	oem_data[18];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;

/*****************
 * hwrm_fw_reset *
 ******************/


/* hwrm_fw_reset_input (size:192b/24B) */
struct hwrm_fw_reset_input {
	/* The HWRM command request type. */
	uint16_t        req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t        cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t        seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFE - Reserved for internal processors
	 * * 0xFFFF - HWRM
	 */
	uint16_t        target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t        resp_addr;
	/* Type of embedded processor. */
	uint8_t embedded_proc_type;
	/* Boot Processor */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_BOOT \
		UINT32_C(0x0)
	/* Management Processor */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_MGMT \
		UINT32_C(0x1)
	/* Network control processor */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_NETCTRL \
		UINT32_C(0x2)
	/* RoCE control processor */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_ROCE \
		UINT32_C(0x3)
	/*
	 * Host (in multi-host environment): This is only valid if requester is IPC.
	 * Reinit host hardware resources and PCIe.
	 */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_HOST \
		UINT32_C(0x4)
	/*
	 * AP processor complex (in multi-host environment).
	 * Use host_idx to control which core is reset
	 */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_AP \
		UINT32_C(0x5)
	/* Reset all blocks of the chip (including all processors) */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_CHIP \
		UINT32_C(0x6)
	/*
	 * Host (in multi-host environment): This is only valid if requester is IPC.
	 * Reinit host hardware resources.
	 */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_HOST_RESOURCE_REINIT \
		UINT32_C(0x7)
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_LAST \
		HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_HOST_RESOURCE_REINIT
	/* Type of self reset. */
	uint8_t selfrst_status;
	/* No Self Reset */
	#define HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTNONE \
		UINT32_C(0x0)
	/* Self Reset as soon as possible to do so safely */
	#define HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTASAP \
		UINT32_C(0x1)
	/* Self Reset on PCIe Reset */
	#define HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTPCIERST \
		UINT32_C(0x2)
	/* Self Reset immediately after notification to all clients. */
	#define HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTIMMEDIATE \
		UINT32_C(0x3)
	#define HWRM_FW_RESET_INPUT_SELFRST_STATUS_LAST \
		HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTIMMEDIATE
	/*
	 * Indicate which host is being reset. 0 means first host.
	 * Only valid when embedded_proc_type is host in multihost
	 * environment
	 */
	uint8_t host_idx;
	uint8_t flags;
	/*
	 * When this bit is '1', then the core firmware initiates
	 * the reset only after graceful shut down of all registered instances.
	 * If not, the device will continue with the existing firmware.
	 */
	#define HWRM_FW_RESET_INPUT_FLAGS_RESET_GRACEFUL     UINT32_C(0x1)
	uint8_t unused_0[4];
} __rte_packed;

/* hwrm_fw_reset_output (size:128b/16B) */
struct hwrm_fw_reset_output {
	/* The specific error status for the command. */
	uint16_t        error_code;
	/* The HWRM command request type. */
	uint16_t        req_type;
	/* The sequence ID from the original command. */
	uint16_t        seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t        resp_len;
	/* Type of self reset. */
	uint8_t selfrst_status;
	/* No Self Reset */
	#define HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTNONE \
		UINT32_C(0x0)
	/* Self Reset as soon as possible to do so safely */
	#define HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTASAP \
		UINT32_C(0x1)
	/* Self Reset on PCIe Reset */
	#define HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTPCIERST \
		UINT32_C(0x2)
	/* Self Reset immediately after notification to all clients. */
	#define HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTIMMEDIATE \
		UINT32_C(0x3)
	#define HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_LAST \
		HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTIMMEDIATE
	uint8_t unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t valid;
} __rte_packed;

/**********************
 * hwrm_port_ts_query *
 ***********************/


/* hwrm_port_ts_query_input (size:192b/24B) */
struct hwrm_port_ts_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_PORT_TS_QUERY_INPUT_FLAGS_PATH		0x1UL
	/* tx path */
	#define HWRM_PORT_TS_QUERY_INPUT_FLAGS_PATH_TX		0x0UL
	/* rx path */
	#define HWRM_PORT_TS_QUERY_INPUT_FLAGS_PATH_RX		0x1UL
	#define HWRM_PORT_TS_QUERY_INPUT_FLAGS_PATH_LAST	\
		HWRM_PORT_TS_QUERY_INPUT_FLAGS_PATH_RX
	/*
	 * If set, the response includes the current value of the free
	 * running timer.
	 */
	#define HWRM_PORT_TS_QUERY_INPUT_FLAGS_CURRENT_TIME	0x2UL
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	uint8_t		unused_0[2];
} __rte_packed;

/* hwrm_port_ts_query_output (size:192b/24B) */
struct hwrm_port_ts_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Timestamp value of PTP message captured, or current value of
	 * free running timer.
	 */
	uint32_t	ptp_msg_ts[2];
	/* Sequence ID of the PTP message captured. */
	uint16_t	ptp_msg_seqid;
	uint8_t		unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t		valid;
} __rte_packed;

/*
 * This structure is fixed at the beginning of the ChiMP SRAM (GRC
 * offset: 0x31001F0). Host software is expected to read from this
 * location for a defined signature. If it exists, the software can
 * assume the presence of this structure and the validity of the
 * FW_STATUS location in the next field.
 */
/* hcomm_status (size:64b/8B) */
struct hcomm_status {
	uint32_t	sig_ver;
	/*
	 * This field defines the version of the structure. The latest
	 * version value is 1.
	 */
	#define HCOMM_STATUS_VER_MASK		UINT32_C(0xff)
	#define HCOMM_STATUS_VER_SFT		0
	#define HCOMM_STATUS_VER_LATEST		UINT32_C(0x1)
	#define HCOMM_STATUS_VER_LAST		HCOMM_STATUS_VER_LATEST
	/*
	 * This field is to store the signature value to indicate the
	 * presence of the structure.
	 */
	#define HCOMM_STATUS_SIGNATURE_MASK	UINT32_C(0xffffff00)
	#define HCOMM_STATUS_SIGNATURE_SFT	8
	#define HCOMM_STATUS_SIGNATURE_VAL	(UINT32_C(0x484353) << 8)
	#define HCOMM_STATUS_SIGNATURE_LAST	HCOMM_STATUS_SIGNATURE_VAL
	uint32_t	fw_status_loc;
	#define HCOMM_STATUS_TRUE_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HCOMM_STATUS_TRUE_ADDR_SPACE_SFT	0
	/* PCIE configuration space */
	#define HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_PCIE_CFG	UINT32_C(0x0)
	/* GRC space */
	#define HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_GRC	UINT32_C(0x1)
	/* BAR0 space */
	#define HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/* BAR1 space */
	#define HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_BAR1	UINT32_C(0x3)
	#define HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_LAST	\
		HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_BAR1
	/*
	 * This offset where the fw_status register is located. The value
	 * is generally 4-byte aligned.
	 */
	#define HCOMM_STATUS_TRUE_OFFSET_MASK		UINT32_C(0xfffffffc)
	#define HCOMM_STATUS_TRUE_OFFSET_SFT		2
} __rte_packed;
/* This is the GRC offset where the hcomm_status struct resides. */
#define HCOMM_STATUS_STRUCT_LOC		0x31001F0UL

/**************************
 * hwrm_port_phy_i2c_read *
 **************************/


/* hwrm_port_phy_i2c_read_input (size:320b/40B) */
struct hwrm_port_phy_i2c_read_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the page_offset field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_I2C_READ_INPUT_ENABLES_PAGE_OFFSET     0x1UL
	/* Port ID of port. */
	uint16_t	port_id;
	/* 8-bit I2C slave address. */
	uint8_t	i2c_slave_addr;
	uint8_t	unused_0;
	/* The page number that is being accessed over I2C. */
	uint16_t	page_number;
	/* Offset within the page that is being accessed over I2C. */
	uint16_t	page_offset;
	/*
	 * Length of data to read, in bytes starting at the offset
	 * specified above. If the offset is not specified, then
	 * the data shall be read from the beginning of the page.
	 */
	uint8_t	data_length;
	uint8_t	unused_1[7];
} __rte_packed;

/* hwrm_port_phy_i2c_read_output (size:640b/80B) */
struct hwrm_port_phy_i2c_read_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Up to 64B of data. */
	uint32_t	data[16];
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} __rte_packed;
#endif /* _HSI_STRUCT_DEF_DPDK_H_ */
